#!/usr/bin/env bash

# @todo
#   - use $KMO_LAYOUT_DIR > if exists, else check in config/kmonad
#   - add dorothy help file.
#   - dorothy flags while

# TODO: rename this command to `setup-kmonad`

# # ensure valid layout path
# action="$(
# 	choose-option --required \
# 		--question='which action to perform?' \
# 		--filter="$action" -- "${actions[@]}"
# )"

function kmonad_run_new() {
	# index a string in bash
	# https://unix.stackexchange.com/questions/303960/index-a-string-in-bash

	# Paths
	KMONAD_CONFIG_DIR="$XDG_CONFIG_HOME/kmonad"
	LOCAL_BIN_DIR="$HOME/.local/bin"

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Utility for running a kmonad. Requires that you have an existing config.

			install

			cat

			dry-run

			run

			write

			USAGE:
			echo-clear-line
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# # TODO: how should i handle arguments.
	# #
	# # kmo -c
	# #     select hw and print
	# #
	# # kmo -c -d
	# #     select hw, print, and dry run
	# #
	# # kmo -c -- <path>
	# #     print layout at path
	# #
	# # kmo -c -r
	# #     select layout print and run
	# #
	# # kmo -c -r -- <path>
	# #   print and run layout at path
	# #
	# # Process action arguments
	# local item action='' option_branch='' option_commit='' args=()
	# while test "$#" -ne 0; do
	# 	item="$1"
	# 	shift
	# 	case "$item" in
	# 	'--help' | '-h') help ;;
	# 	'-d' | '--dry-run') action='dry_run' ;;
	# 	'-c' | '--cat') action='cat' ;;
	# 	'-w' | '--write') action='write' ;;
	# 	'-r' | '--run') action='run' ;;
	# 	# custom config path
	# 	#
	# 	'--'*) help "An unrecognised flag was provided: $item" ;;
	# 	*) help "An unrecognised argument was provided: $item" ;;
	# 	esac
	# done
	#
	# if test -z "$action"; then
	# 	help "<action> must be provided."
	# fi

	local action="$1"

	# =================================
	# Helpers

	# TODO: check if the kmonad repo exists under GHQ

	function build_kmonad() {
		:
	}

	# NOTE: INSTALL DOCS:
	# [ https://github.com/kmonad/kmonad/blob/master/doc/installation.md#binaries ]

	# https://aur.archlinux.org/packages/kmonad-bin
	# https://github.com/kmonad/kmonad/blob/master/doc/installation.md#void-linux
	# https://github.com/kmonad/kmonad/blob/master/doc/installation.md#gnu-guix
	function install_kmonad_linux_packages() {
		setup-util --name='kmonad' --cli='kmonad' --order='aur xbps guix' \
			AUR='kmonad-bin' \
			XBPS='kmonad' \
			GUIX='kmonad'
	}

	# Find executables
	function get_executable() {
		local KMO_EXECUTABLE

		if ! command-exists kmonad; then
			if is-mac; then

				:
			else
				:
			fi
		fi

		# NOTE: if doesn't exist need to build on mac
		local_bin_exec_path=($(find $LOCAL_BIN_DIR | grep "kmonad"))

		echo "MACOS: local bin grep exit code: $?"
		local local_bin_found=''
		if [ $? -eq 0 ]; then
			local_bin_found='yes'
		else
			local_bin_found='no'
		fi

		if is-mac; then
			if test "$local_bin_found" = "yes"; then
				KMO_EXECUTABLE="$(choose-option --confirm --question='Select executable name.' -- "${local_bin_exec_path[@]}")"
			else
				# FIX: build for mac here
				:
			fi

		else

			# TODO: if
			# 1. no .local/bin binary AND
			# 2. no package found via `which kmonad`

      # TEST: since there can be multiple occurences of a command on linux,
      # I can use `which -a`
      #
      # NOTE: `which -a | grep "$HOME/.local/bin/kmonad`
      # can be used to capture all local builds
      #
			# command_name="your_command_name"
			# while IFS= read -r path; do
			# 	echo "Command '$command_name' found at: $path"
			# done < <(which -a "$command_name")

			KMO_PACKAGE=$(which kmonad)

			# install_kmonad_linux_packages
			if test "$local_bin_found" = "yes"; then
				KMO_EXECUTABLE="$(choose-option --confirm --question='Select executable name.' -- "${local_bin_exec_path[@]}")"
			else
				# FIX: build for mac here
				:
			fi

			# TODO: check if an executable exists under local/bin
			# Do you want to build kmonad

			:
		fi
		echo "$KMO_EXECUTABLE"
	}

	function get_select_hardware() {
		user_hardwares_list=(
			"ergo"
			"pro"
			"air"
		)
		SELECTED_HARDWARE="$(choose-option --confirm --question='Select hardware to run kmonad for.' -- "${user_hardwares_list[@]}")"
		echo "$SELECTED_HARDWARE"
	}

	# function get_cfg_block() {
	# 	local SELECTED_HARDWARE=$1
	# }

	# function get_src_file_for_hardware() {
	# }

	function compile_layout() {
		local SELECTED_HARDWARE=$1

		# Get source keymap file
		declare -A defsrc_files=(
			[ergo]="defsrc_ergodox.kbd"
			[pro]="defsrc_mbpro_swe.kbd"
			[air]="defsrc_mbair.kbd"
		)
		DEFSRC="$KMONAD_CONFIG_DIR/defsrc/${defsrc_files[$SELECTED_HARDWARE]}"

		# Create kmonad `cfg` block
		declare -A defcfg_input_str=(
			[ergo]="Ergodox EZ"
			[pro]="Apple Internal Keyboard / Trackpad"
			[air]="Apple Internal Keyboard / Trackpad"
		)
		input="${defcfg_input_str[$SELECTED_HARDWARE]}"
		output="kext"
		fallthrough=false
		DEFCFG="(defcfg
      input (iokit-name \"$input\")
      output ($output)
      fallthrough $fallthrough
    )"

		# Compile final layout
		echo "$DEFCFG"
		cat "$DEFSRC"
		# Load each layer file
		for f in "$KMONAD_CONFIG_DIR/common/"*.kbd; do
			local filename
			filename="$(basename "$f")"
			# FIX: rewrite this as a `continue` statement
			# I wanted literal match here because layers ending with `~.kbd` are ignored
			# Do this instead with a [if match xyz then continue..]
			if [[ ! $filename =~ "~.kbd" ]]; then
				cat "$f"
			fi
		done
	}

	function get_compiled_layout_file() {
		SELECTED_HARDWARE=$1
		layout_temp_file="/tmp/kmonad_compiled_layout" # "$(mktemp /tmp/kmonad-XXX)"
		compile_layout "$SELECTED_HARDWARE" >"$layout_temp_file"
		echo "$layout_temp_file"
	}

	# =================================
	# Main functions

	function print_layout() {
		local title="Printed kmonad layout"
		echo-segment --h2="$title"
		cat "$layout_temp_file"
		echo-segment --g2="$title"
	}

	# TODO: this could be renamed into get_necessary_parameters() which
	# returns everything necessary to run kmonad.
	# Then, I can reuse this function to get all of the data and then run
	# kmonad in various ways
	# echo "hardware" "layout" "executable"

	function get_necessary_parts() {
		SELECTED_HARDWARE=$(get_select_hardware)
		SELECTED_LAYOUT_FILE=$(get_compiled_layout_file "$SELECTED_HARDWARE")
		KMO_EXECUTABLE=$(get_executable)
		echo "$KMO_EXECUTABLE" "$SELECTED_LAYOUT_FILE"
	}

	function dry_run() {
		echo-style --bold="Dry running kmonad now..."

		# SELECTED_HARDWARE=$(get_select_hardware)
		# SELECTED_LAYOUT_FILE=$(get_compiled_layout_file "$SELECTED_HARDWARE")
		# KMO_EXECUTABLE=$(get_executable)
		#
		# echo "Hardware: $SELECTED_HARDWARE"
		# echo "Layout: $SELECTED_LAYOUT_FILE"
		# echo "Executable: $KMO_EXECUTABLE"
		#
		# I can also get the commands this way.
		parts=($(get_necessary_parts))

		"${parts[@]}" -d

		# $KMO_EXECUTABLE "$layout_temp_file" -d
	}

	function run() {
		echo-style --bold="Running kmonad now..."
		sudo "$KMO_EXECUTABLE" "$layout_temp_file" --allow-cmd
	}

	function write_layout_to_file() {
		:
	}

	# =================================
	# Arguments

	# mode="d" # run
	# for arg in "$@"; do
	# 	if test "$arg" = '--cat' -o "$arg" = '-c'; then
	# 		mode="c"
	# 	elif test "$arg" = '--write' -o "$arg" = '-w'; then
	# 		mode="w" # TODO
	# 	elif test "$arg" = '--run' -o "$arg" = '-r'; then
	# 		mode="r"
	# 	fi
	# done

	if [ $# -eq 0 ]; then
		# help "<action> must be provided."
		dry_run
	elif test "$action" = "install"; then
		install
	elif test "$action" = "run"; then
		run
	elif test "$action" = 'cat'; then
		print_layout
	elif test "$action" = 'write'; then
		echo "write layout -> todo..."
	elif test "$action" = 'dry'; then
		dry_run
	fi
}

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	kmonad_run_new "$@"
fi
