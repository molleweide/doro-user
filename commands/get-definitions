#! /usr/bin/env bash

# https://stackoverflow.com/questions/42420717/print-out-a-list-of-all-cases-of-a-switch
# https://stackoverflow.com/questions/4471364/how-do-i-list-the-functions-defined-in-my-shell

# NOTE: declare lists all func defs in sourced files as well, ie. we need to
# ensure that we only get func defs from the current file.
# See: https://superuser.com/questions/1111219/can-i-get-all-functions-in-a-script-file-using-bash
# Basically we make a custom call to this file itself with env -i so that we
# can parse the file exclusively.
# ...
# Hmmm, now that I think about it. We could just run echo-regexp on the file
# itself and check for all the func names which would be the easiest solution.
# ...
# TODO: Create command `get-definitions`
# So there are three cases.
# 1. [ ] Get all existing func defs -> declare -f
# 2. [ ] Get all existing func defs in current file, including dynamically
#    created ones -> custom solution.
# 3. [*] Only get explicitly defined func defs -> use echo-regexp on self.

function get_definitions() (
	source "$DOROTHY/sources/bash.bash"

	# =================================
	# Arguments

	# TODO: [ ] Finish the help text.
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Query code for bash definitions and identifiers.
			If no path is supplied then query current env/shell.

			USAGE:
			get-definitions [...options] [--] ..<paths>

			OPTIONS:
			--search=<search> | <search>
			    The regular expression to search for.

			--replace=<replace> | <replace>
			    The string to replace the search with.

			--flags=<flags> | <flags>
			    Regular expression flags, e.g. 'i' for case-insensitive.

			    --globally:

			    --executing-cmd:

			    --dorothy-cmd-top-level: Funcs inside a dorothy command are indented by one
			                so this could be checked for in order to avoid/filter out unwanted
			                func defs.

			      --funcs
			      --vars
			      --both

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_flags='' option_args=() option_inputs=() option_echo_regexp='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--flags='*) option_flags="${item#*=}" ;;
		'--global') option_flags+='g' ;;
		'--ignore-case') option_flags+='i' ;;
		'--echo-regexp') option_echo_regexp='yes' ;;
		'--')
			option_inputs+=("$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# WARN: currently only expects one single path!

	# Check for search pattern
	if [[ ${#option_inputs[@]} -eq 0 ]]; then
		help 'No <search> file path(s) were provided.'
	fi
	# "$1" # "${BASH_SOURCE[0]}"
	local exec_path="${option_inputs[0]}"

	# =================================
	# Action

	# FIX: [ ] named caputers are actually used in config-helper.
	#       Add this to the echo-regexp js patterns.
	# FIX: Support
	# [ ] sed
	# [ ] standard grep
	# [ ] ripgrep

	local fn_regex='' supports_named_captures='no'
	if [[ $option_echo_regexp == 'yes' ]]; then
		# TODO: since ripgrep is the fastest use it to find the func names.
		if command-exits rg; then
			:
		elif command-exists grep; then
			:
		elif command-exists sed; then
			:
		fi
	else
		# JS regexp cheat sheet: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences
		local fn_pat1="^\s*function\s+([\w_]+)(\(\))?\s*\{" # captures: `function <name>()? {`
		local fn_pat2="^\s*([\w_]+)\(\)\s*\{"               # captures: `<name>() {`
		if [[ "$supports_named_captures" == "yes" ]]; then
			fn_regex="$fn_pat1|$fn_pat2"
		else
			fn_regex="$fn_pat1"
		fi
		echo-file --raw -- "$exec_path" | echo-regexp -gmon --search="$fn_regex" --replace='$1'
	fi
)

# Fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	get_definitions "$@"
fi
