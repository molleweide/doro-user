#! /usr/bin/env bash

# https://stackoverflow.com/questions/42420717/print-out-a-list-of-all-cases-of-a-switch
# https://stackoverflow.com/questions/4471364/how-do-i-list-the-functions-defined-in-my-shell

function get_definitions() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# # TODO: Obtain func contents from arbitrary script.
	# # See: https://superuser.com/questions/1111219/can-i-get-all-functions-in-a-script-file-using-bash
	#
	# # get_fcn_list () {
	# #   env -i bash --noprofile --norc -c '
	# #     source "'"$1"'" >/dev/null
	# #     while read -r line; do
	# #       echo ${line##* }
	# #     done < <(declare -F)
	# #     '
	# # }
	# #
	# # for fcn_name in $(get_fcn_list dome.sh); do
	# #     echo "$fcn_name"
	# # done
	# #

	# =================================
	# Arguments

	# TODO: [ ] Finish the help text.
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Query code for bash definitions and identifiers.
			If no path is supplied then query current env/shell.

			USAGE:
			get-definitions [...options] [--] ..<paths>

			OPTIONS:
			--search=<search> | <search>
			    The regular expression to search for.

			--replace=<replace> | <replace>
			    The string to replace the search with.

			--map-id-to-body
			  Iterate all func ids and return an array where each $(id) is followed
			  by the contents of respective func.

			--flags=<flags> | <flags>
			    Regular expression flags, e.g. 'i' for case-insensitive.

			--exclude-prefix=...

			--exclude-suffix=...

			--exclude-substring=...
			    Iterate all matches and filter out specific patterns.

			    --globally:

			    --executing-cmd:

			    --dorothy-cmd-top-level: Funcs inside a dorothy command are indented by one
			                so this could be checked for in order to avoid/filter out unwanted
			                func defs.

			      --funcs
			      --vars
			      --both

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_flags='' option_args=() option_inputs=() option_echo_regexp='no' option_get_func_contsents='no' option_target_func=''
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--flags='*) option_flags="${item#*=}" ;;
		'--global') option_flags+='g' ;;
		'--ignore-case') option_flags+='i' ;;
		'--echo-regexp') option_echo_regexp='yes' ;;
		'--contents') option_get_func_contsents='yes' ;;
		'--target-func='*) option_target_func="${item#*=}" ;;
		'--')
			option_inputs+=("$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# WARN: currently only expects one single path!

	# Check for search pattern
	if [[ ${#option_inputs[@]} -eq 0 ]]; then
		help 'No <search> file path(s) were provided.'
	fi
	# "$1" # "${BASH_SOURCE[0]}"
	local exec_path="${option_inputs[0]}"

	# =================================
	# Action

	# ----------------------
	# GET FUNC CONTENTS

	if [[ "$option_get_func_contsents" == "yes" ]]; then
		echo "TARGET FUNC: $option_target_func"
		if [[ -z "$option_target_func" ]]; then
			help "Obtaining the contents of a function requires passing the target function."
		fi

		local get_target_func_body='
		    source "'"$exec_path"'" >/dev/null
		    while read -r line; do
		      echo ${line##* }
		    done < <(declare -f "'"$option_target_func"'")
		    '
		# env -i bash --noprofile --norc -c "$get_target_func_body"
		# env -i bash -c "$get_target_func_body"
		env -i bash -c "$get_target_func_body"

		# env -i bash --noprofile --norc -c '
		#     source "'"$exec_path"'" >/dev/null
		#     while read -r line; do
		#       echo ${line##* }
		#     done < <(declare -f "'"$option_target_func"'")
		#     '

		# set -x
		# # --noprofile --norc
		# env -i bash -c '
		#     source "'"$exec_path"'" >/dev/null
		#     declare -f "'"$option_target_func"'"
		#     '
		# set +x

		# function get_body() {
		# 	env -i bash --noprofile --norc -c '
		#     source "'"$exec_path"'" >/dev/null
		#     while read -r line; do
		#       echo ${line##* }
		#     done < <(declare -F "'"$option_target_func"'")
		#     '
		# }
		#
		# for fcn_name in $(get_body); do
		#     echo "$fcn_name"
		# done

		# __print_lines "$get_target_func_body"

		return 0
	fi

	# ----------------------
	# GET ID'S

	# FIX: [ ] named caputers are actually used in config-helper.
	#       Add this to the echo-regexp js patterns.
	# FIX: Support
	# [ ] sed
	# [ ] standard grep
	# [ ] ripgrep

	local fn_regex='' supports_named_captures='no' func_ids_found=()
	if [[ $option_echo_regexp == 'yes' ]]; then
		# TODO: since ripgrep is the fastest use it to find the func names.
		if command-exits rg; then
			:
		elif command-exists grep; then
			:
		elif command-exists sed; then
			:
		fi
	else
		# JS regexp cheat sheet: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences
		local fn_pat1="^\s*function\s+([\w_]+)(\(\))?\s*\{" # captures: `function <name>()? {`
		local fn_pat2="^\s*([\w_]+)\(\)\s*\{"               # captures: `<name>() {`
		if [[ "$supports_named_captures" == "yes" ]]; then
			fn_regex="$fn_pat1|$fn_pat2"
		else
			fn_regex="$fn_pat1"
		fi
		mapfile -t func_ids_found < <(
			echo-file --raw -- "$exec_path" |
				echo-regexp -gmon --search="$fn_regex" --replace='$1'
		)
	fi

	# --------------------------------------------
	# filter unwanted ids

	# NOTE: Since this is now running in an isolated command, this block might
	# be unnecessary.
	# However, we might always want to exclude definitis in certain commands,
	# such as this one??

	# FIX: [ ] Move this filter into the `get-definitions` command

	# # This should prolly go into a command called echo-filter
	# local remove_ids=(
	# 	"render_choose_data"
	# )
	local func_names_final=() remove_ids=()
	for id in "${func_ids_found[@]}"; do
		local add='yes'
		local rm_id

		if [[ "$id" == _* ]]; then
			add='no'
		else
			for rm_id in "${remove_ids[@]}"; do
				if [[ "$id" == _* || "$rm_id" == "$id" ]]; then
					add='no'
				fi
			done
		fi
		if [[ "$add" == 'yes' ]]; then
			func_names_final+=("$id")
		fi
	done

	echo-lines -- "${func_names_final[@]}"

)

# Fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	get_definitions "$@"
fi
