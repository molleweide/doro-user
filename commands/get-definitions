#! /usr/bin/env bash

# https://stackoverflow.com/questions/42420717/print-out-a-list-of-all-cases-of-a-switch
# https://stackoverflow.com/questions/4471364/how-do-i-list-the-functions-defined-in-my-shell

function get_definitions() (
	source "$DOROTHY/sources/bash.bash"

	# # TODO: Obtain func contents from arbitrary script.
	# # See: https://superuser.com/questions/1111219/can-i-get-all-functions-in-a-script-file-using-bash
	#
	# # get_fcn_list () {
	# #   env -i bash --noprofile --norc -c '
	# #     source "'"$1"'" >/dev/null
	# #     while read -r line; do
	# #       echo ${line##* }
	# #     done < <(declare -F)
	# #     '
	# # }
	# #
	# # for fcn_name in $(get_fcn_list dome.sh); do
	# #     echo "$fcn_name"
	# # done
	# #

	# =================================
	# Arguments

	# TODO: [ ] Finish the help text.
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Query code for bash definitions and identifiers.
			If no path is supplied then query current env/shell.

			USAGE:
			get-definitions [...options] [--] ..<paths>

			OPTIONS:
			--search=<search> | <search>
			    The regular expression to search for.

			--replace=<replace> | <replace>
			    The string to replace the search with.

			--map-id-to-body
			  Iterate all func ids and return an array where each `id` is followed
			  by the contents of respective func.

			--flags=<flags> | <flags>
			    Regular expression flags, e.g. 'i' for case-insensitive.

			--exclude-prefix=...

			--exclude-suffix=...

			--exclude-substring=...
			    Iterate all matches and filter out specific patterns.

			    --globally:

			    --executing-cmd:

			    --dorothy-cmd-top-level: Funcs inside a dorothy command are indented by one
			                so this could be checked for in order to avoid/filter out unwanted
			                func defs.

			      --funcs
			      --vars
			      --both

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_flags='' option_args=() option_inputs=() option_echo_regexp='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--flags='*) option_flags="${item#*=}" ;;
		'--global') option_flags+='g' ;;
		'--ignore-case') option_flags+='i' ;;
		'--echo-regexp') option_echo_regexp='yes' ;;
		'--')
			option_inputs+=("$@")
			shift $#
			break
			;;
		*) option_args+=("$item") ;;
		esac
	done

	# WARN: currently only expects one single path!

	# Check for search pattern
	if [[ ${#option_inputs[@]} -eq 0 ]]; then
		help 'No <search> file path(s) were provided.'
	fi
	# "$1" # "${BASH_SOURCE[0]}"
	local exec_path="${option_inputs[0]}"

	# =================================
	# Action

	# FIX: [ ] named caputers are actually used in config-helper.
	#       Add this to the echo-regexp js patterns.
	# FIX: Support
	# [ ] sed
	# [ ] standard grep
	# [ ] ripgrep

	local fn_regex='' supports_named_captures='no'
	if [[ $option_echo_regexp == 'yes' ]]; then
		# TODO: since ripgrep is the fastest use it to find the func names.
		if command-exits rg; then
			:
		elif command-exists grep; then
			:
		elif command-exists sed; then
			:
		fi
	else
		# JS regexp cheat sheet: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences
		local fn_pat1="^\s*function\s+([\w_]+)(\(\))?\s*\{" # captures: `function <name>()? {`
		local fn_pat2="^\s*([\w_]+)\(\)\s*\{"               # captures: `<name>() {`
		if [[ "$supports_named_captures" == "yes" ]]; then
			fn_regex="$fn_pat1|$fn_pat2"
		else
			fn_regex="$fn_pat1"
		fi
		echo-file --raw -- "$exec_path" | echo-regexp -gmon --search="$fn_regex" --replace='$1'
	fi
)

# Fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	get_definitions "$@"
fi
