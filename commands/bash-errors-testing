#!/usr/bin/env bash

# TODO: [ ] choose -> select run all tests
#       [ ] If possible, try to re run the choose menu after having run the
#       select function so that user can continuously select and run funcs
#       multiple times
#       [ ] bash.bash -> enable/disable dorothy opts

# NOTE: instruct user to reset shell opts for test-case functions.
# -> This should allow us to use dorothy to setup the test UX but also
# manually setup the environment for each test case and have best of both
# worlds. IE. reset shopts inside of each test case func.

# NOTE: [ ] custom choose-test-current-file
#           [ ] Use a custom flag that sets how many preview lines of each
#           function that we want to allow for output in the terminal.
#           Or maybe this could be done dynamically inside of the command
#           by reusing Ben's custom commands for getting terminal dimensions
#           etc.
#           --
#           Name ideas:
#           choose-function-runner, choose-fn-tester, choose-tester,
#           func-runner-ui
#           --
#           >> run this command in a command where you keep various func
#           test cases that you want to run by selecting them via choose.

function bash_error_testing() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# =======================================================
	# Test cases

	# Prepare

	# Our standard failure functions, these will be used by our examples
	function _a_function_which_failure_IS_NOT_the_last_command {
		printf '%s\n' 'before failure'
		false # emit an error to this function, as this returns a non-zero exit status
		printf '%s\n' 'after failure'
	}

	function _a_function_which_failure_IS_the_last_command {
		printf '%s\n' 'before failure without after'
		false # emit an error to this function, as this returns a non-zero exit status
	}

	# ------

	function disable_err_which_outputs_before_and_after_failure {
		set +e # disable errors returning immediately, the default bash mode, desirable for the login shell
		_a_function_which_failure_IS_NOT_the_last_command
		# outputs:
		# before failure
		# after failure
	}

	# export -f disable_err_which_outputs_before_and_after_failure

	function enable_default_errs_to_return_immediately_before_failure {
		set -e # enable errors to return immediately, the default bash mode in dorothy enabled when we `source "$DOROTHY/sources/bash.bash"`, desirable for scripting
		_a_function_which_failure_IS_NOT_the_last_command
		# outputs:
		# before failure
	}
	function output_before_and_after_fail {
		set -e
		! _a_function_which_failure_IS_NOT_the_last_command
		printf '%s\n' 'failure'
		# outputs:
		# before failure
		# after failure
	}
	function output_both_and_success {
		set -e
		_a_function_which_failure_IS_NOT_the_last_command && printf '%s\n' 'success'
		# outputs:
		# before failure
		# after failure
		# success
	}
	function before_fail_and_after_fail {
		set -e
		_a_function_which_failure_IS_NOT_the_last_command || printf '%s\n' 'failure'
		# outputs:
		# before failure
		# after failure
	}
	function failure_in_conditional {
		set -e
		if _a_function_which_failure_IS_NOT_the_last_command; then
			printf '%s\n' 'success'
		else
			printf '%s\n' 'failure'
		fi
		# outputs:
		# before failure
		# after failure
		# success
	}
	function negated_conditional_success {
		set -e
		if ! _a_function_which_failure_IS_NOT_the_last_command; then
			printf '%s\n' 'failure'
		else
			printf '%s\n' 'success'
		fi
		# outputs:
		# before failure
		# after failure
		# success
	}

	# If the failure is the last command, then such works as expected, as the exit status of any function is always the exit status of the last executed command, regardless of errexit
	function before_failure_without_after {
		set -e
		_a_function_which_failure_IS_the_last_command && printf '%s\n' 'success' || printf '%s\n' 'failure'
		printf '%s\n' 'ok'
		# outputs:
		# before failure without after
		# failure
		# ok
	}

	# This behaviour also impacts how we fetch exit codes
	function status_check_without_errexit {
		# without errexit
		set +e
		_a_function_which_failure_IS_NOT_the_last_command
		printf '%s\n' "status=$?"
		# outputs:
		# before failure
		# after failure
		# status=0
		_a_function_which_failure_IS_the_last_command
		printf '%s\n' "status=$?"
		# outputs:
		# before failure without after
		# status=1
	}
	function status_check_with_errexit {
		# with errexit
		set -e
		status=0 && _a_function_which_failure_IS_NOT_the_last_command || status=$?
		printf '%s\n' "status=$status"
		# outputs:
		# before failure
		# after failure
		# status=0
		status=0 && _a_function_which_failure_IS_the_last_command || status=$?
		printf '%s\n' "status=$status"
		# outputs:
		# before failure without after
		# status=1
	}

	# ============================================
	# A. Build UI here in current command.

	# local this_path="${BASH_SOURCE[0]}"
	#
	# # Why is it that this returns a single string it seems?!
	# # local_function_ids="$(get-definitions "$this_path")"
	#
	# local local_function_ids=() func_names_final=() choose_data=()
	# mapfile -t local_function_ids < <(get-definitions "$this_path")
	#
	# # This should prolly go into a command called echo-filter
	# local remove_ids=(
	# 	"render_choose_data"
	# )
	# for id in "${local_function_ids[@]}"; do
	# 	local add='yes'
	# 	local rm_id
	# 	for rm_id in "${remove_ids[@]}"; do
	# 		if [[ "$id" == _* || "$rm_id" == "$id" ]]; then
	# 			add='no'
	# 		fi
	# 	done
	# 	if [[ "$add" == 'yes' ]]; then
	# 		func_names_final+=("$id")
	# 	fi
	# done
	#
	# function render_choose_data {
	# 	local id="$1" description body
	# 	description="${id//_/ }"
	# 	description="${description^}"
	# 	# Unfortunately, using negative numbers does not work with head on macos.
	# 	# body="$(echo-lines "$(declare -f "$id")" | tail -n +3 | head -n -1)"
	# 	body="$(echo-lines "$(declare -f "$id")" | sed '1,2d; $d')"
	# 	# prefix with an empty dim to disable the default dimming in results
	# 	# Why is the final linebreak trimmed when displaying the information??
	# 	echo-style --dim='' --bold+underline="$description" $'\n' --dim="$body" $'\n'
	# }
	# for id in "${func_names_final[@]}"; do
	# 	choose_data+=(
	# 		"$id"
	# 		"$(render_choose_data "$id")"
	# 	)
	# done
	#
	# local selection
	# selection="$(
	# 	choose --required --label \
	# 		--question='Which test do you want to run?' \
	# 		-- "${choose_data[@]}"
	# )"
	#
	# __print_lines "Selection: [$selection]"
	#
	# "$selection"

	# ============================================
	# B. Try build and run UI in external command.

	# FIX: GET DEFINITIONS
	# get-definitions needs to have an option that excludes certain definitions
	# eg. specifyc --exclude-prefix=_*
	# So that we dont get the prep funcs.
	# ---
	# Options:
	# 1. Use `declare -f $fn` which has to be run in this file.
	# 2.

	clear

	echo-style $'\n' --bold="-- TEST FILE --" $'\n'

	__print_lines "Current PID: $$ -> exec cmd/script: $(ps -o command= -p $$)"
	__print_lines "Parrent PID: $PPID -> exec cmd/script: $(ps -o command= -p $PPID)"
	__print_lines "PWD: $PWD"
	# __print_lines "parrent pid = $(ps -o command= -p $PPID)"

	# local this_file="${BASH_SOURCE[0]}" local_function_ids=()
	# mapfile -t local_function_ids < <(get-definitions -- "$this_file")
	# choose-bash-tester --path="$this_file" -- "${local_function_ids[@]}"

	choose-bash-tester

)

# Fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	bash_error_testing "$@"
fi
