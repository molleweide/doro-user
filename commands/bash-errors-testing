#!/usr/bin/env bash

# TODO: [ ] create the get-definitions command.
#       [ ] render data for choose menu
#       [ ] If possible, try to re run the choose menu after having run the
#       select function so that user can continuously select and run funcs
#       multiple times
#       [ ] bash.bash -> enable/disable dorothy opts

# NOTE: instruct user to reset shell opts for test-case functions.
# -> This should allow us to use dorothy to setup the test UX but also
# manually setup the environment for each test case and have best of both
# worlds. IE. reset shopts inside of each test case func.

# NOTE: [ ] custom choose-test-current-file
#           [ ] Use a custom flag that sets how many preview lines of each
#           function that we want to allow for output in the terminal.
#           Or maybe this could be done dynamically inside of the command
#           by reusing Ben's custom commands for getting terminal dimensions
#           etc.
#           --
#           Name ideas:
#           choose-function-runner, choose-fn-tester, choose-tester,
#           func-runner-ui
#           --
#           >> run this command in a command where you keep various func
#           test cases that you want to run by selecting them via choose.

function bash_error_testing() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# =======================================================
	# Test cases

	# Prepare

	# Our standard failure functions, these will be used by our examples
	function _a_function_which_failure_IS_NOT_the_last_command {
		printf '%s\n' 'before failure'
		false # emit an error to this function, as this returns a non-zero exit status
		printf '%s\n' 'after failure'
	}
	function _a_function_which_failure_IS_the_last_command {
		printf '%s\n' 'before failure without after'
		false # emit an error to this function, as this returns a non-zero exit status
	}

	function disable_err_which_outputs_before_and_after_failure {
		set +e # disable errors returning immediately, the default bash mode, desirable for the login shell
		_a_function_which_failure_IS_NOT_the_last_command
		# outputs:
		# before failure
		# after failure
	}
	function enable_default_errs_to_return_immediately_before_failure {
		set -e # enable errors to return immediately, the default bash mode in dorothy enabled when we `source "$DOROTHY/sources/bash.bash"`, desirable for scripting
		_a_function_which_failure_IS_NOT_the_last_command
		# outputs:
		# before failure
	}
	function output_before_and_after_fail {
		set -e
		! _a_function_which_failure_IS_NOT_the_last_command
		printf '%s\n' 'failure'
		# outputs:
		# before failure
		# after failure
	}
	# 	;;
	# 4)
	# 	set -e
	# 	_a_function_which_failure_IS_NOT_the_last_command && printf '%s\n' 'success'
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	# success
	# 	;;
	# 5)
	# 	set -e
	# 	_a_function_which_failure_IS_NOT_the_last_command || printf '%s\n' 'failure'
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	;;
	# 6)
	# 	set -e
	# 	if _a_function_which_failure_IS_NOT_the_last_command; then
	# 		printf '%s\n' 'success'
	# 	else
	# 		printf '%s\n' 'failure'
	# 	fi
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	# success
	# 	;;
	# 7)
	# 	set -e
	# 	if ! _a_function_which_failure_IS_NOT_the_last_command; then
	# 		printf '%s\n' 'failure'
	# 	else
	# 		printf '%s\n' 'success'
	# 	fi
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	# success
	# 	;;
	#
	# # if the failure is the last command, then such works as expected, as the exit status of any function is always the exit status of the last executed command, regardless of errexit
	# 8)
	# 	set -e
	# 	_a_function_which_failure_IS_the_last_command && printf '%s\n' 'success' || printf '%s\n' 'failure'
	# 	printf '%s\n' 'ok'
	# 	# outputs:
	# 	# before failure without after
	# 	# failure
	# 	# ok
	# 	;;
	#
	# # this behaviour also impacts how we fetch exit codes
	# 9)
	# 	# without errexit
	# 	set +e
	# 	_a_function_which_failure_IS_NOT_the_last_command
	# 	printf '%s\n' "status=$?"
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	# status=0
	# 	_a_function_which_failure_IS_the_last_command
	# 	printf '%s\n' "status=$?"
	# 	# outputs:
	# 	# before failure without after
	# 	# status=1
	# 	;;
	# 10)
	# 	# with errexit
	# 	set -e
	# 	status=0 && _a_function_which_failure_IS_NOT_the_last_command || status=$?
	# 	printf '%s\n' "status=$status"
	# 	# outputs:
	# 	# before failure
	# 	# after failure
	# 	# status=0
	# 	status=0 && _a_function_which_failure_IS_the_last_command || status=$?
	# 	printf '%s\n' "status=$status"
	# 	# outputs:
	# 	# before failure without after
	# 	# status=1
	# 	;;
	# esac

	# =======================================================
	# Act

	local this_path="${BASH_SOURCE[0]}"

	# Why is it that this returns a single string it seems?!
	# func_names_found="$(get-definitions "$this_path")"

	local func_names_found=() func_names_final=() choose_data=()
	mapfile -t func_names_found < <(get-definitions "$this_path")

	# This should prolly go into a command called echo-filter
	local remove_ids=(
		"render_choose_data"
	)
	for id in "${func_names_found[@]}"; do
		local add='yes'
		local rm_id
		for rm_id in "${remove_ids[@]}"; do
			if [[ "$id" == _* || "$rm_id" == "$id" ]]; then
				add='no'
			fi
		done
		if [[ "$add" == 'yes' ]]; then
			func_names_final+=("$id")
		fi
	done

	function render_choose_data {
		local id="$1" description body
		description="${id//_/ }"
		description="${description^}"
		# Unfortunately, using negative numbers does not work with head on macos.
		# body="$(echo-lines "$(declare -f "$id")" | tail -n +3 | head -n -1)"
		body="$(echo-lines "$(declare -f "$id")" | sed '1,2d; $d')"
		# prefix with an empty dim to disable the default dimming in results
		# Why is the final linebreak trimmed when displaying the information??
		echo-style --dim='' --bold+underline="$description" $'\n' --dim="$body" $'\n'
	}
	for id in "${func_names_final[@]}"; do
		choose_data+=(
			"$id"
			"$(render_choose_data "$id")"
		)
	done

	local selection
	selection="$(
		choose --required --label \
			--question='Which test do you want to run?' \
			-- "${choose_data[@]}"
	)"

	__print_lines "Selection: [$selection]"

	"$selection"

)

# Fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	bash_error_testing "$@"
fi
