#!/usr/bin/env bash

# https://github.com/koekeishiya/yabai
# https://dwm.suckless.org/

# ------------------------
# ---       TODO       ---
# ------------------------

# split into files?

##########################

echo "\$@: $@"

fn_args=$@

action="${1-}"
! test -z "${action}" || exit 1
arg1="${2-}"
arg2="${3-}"
arg3="${4-}"

call() {
    echo "$@"
    # ($1)
}

reload() {
    echo "reload"
    # if is-mac; then
    #     brew services restart yabai
    #     brew services restart skhd
    #     limelight # there is a wierd err msg but it works...
    # else
	#  echo 'reload linux wm...'
    # fi
}

# -------------------------------------
# ---       YABAI DEFINITIONS       ---
# -------------------------------------

# REGEX       := POSIX extended regular expression syntax <https://www.gnu.org/software/findutils/manual/html_node/find_html/posix_002dextended-regular-expression-syntax.html>
# LABEL       := arbitrary string/text used as an identifier
# LAYER       := below | normal | above
# BOOL_SEL    := on | off
# FLOAT_SEL   := 0 < <value> <= 1.0
# RULE_SEL    := <index> | LABEL
# SIGNAL_SEL  := <index> | LABEL
# DIR_SEL     := north | east | south | west
# STACK_SEL   := stack.prev | stack.next | stack.first | stack.last | stack.recent
# WINDOW_SEL  := prev | next | first | last | recent | mouse | largest | smallest | STACK_SEL | DIR_SEL | <window id>
# DISPLAY_SEL := prev | next | first | last | recent | mouse | DIR_SEL | <arrangement index (1-based)>
# SPACE_SEL   := prev | next | first | last | recent | mouse | <mission-control index (1-based)> | LABEL

# @param setting
# @param value
config_global() {
    ! test -z "${arg1-}" -a "${arg2-}" || exit 1
    local setting=$arg1
    local value=$arg2
    if is-mac; then
        local yabai_domain="yabai -m config"
        local yabai_setting
        case "$setting" in
            "debug")            $yabai_setting="debug_output";;               # [<BOOL_SEL>]
            "ext_bar" | "bar")  $yabai_setting="external_bar";;               # [<main|all|off>:<top_padding>:<bottom_padding>]
            "ms_flw_fc")        $yabai_setting="mouse_follows_focus";;        # [<BOOL_SEL>]
            "fc_flw_ms")        $yabai_setting="focus_follows_mouse";;        # [autofocus|autoraise|off]
            "win_place")        $yabai_setting="window_placement";;           # [first_child|second_child]
            "win_topm")         $yabai_setting="window_topmost";;             # [<BOOL_SEL>]
            "win_sh")           $yabai_setting="window_shadow";;              # [<BOOL_SEL>|float]
            "win_op")           $yabai_setting="window_opacity";;             # [<BOOL_SEL>]
            "win_op_dur")       $yabai_setting="window_opacity_duration";;    # [<floating point number>]
            "act_win_op")       $yabai_setting="active_window_opacity";;      # [<FLOAT_SEL>]
            "nrm_win_op")       $yabai_setting="normal_window_opacity";;      # [<FLOAT_SEL>]
            "win_b")            $yabai_setting="window_border";;              # [<BOOL_SEL>]
            "window_bw")        $yabai_setting="window_border_width";;        # [<even integer number>]
            "act_win_bc")       $yabai_setting="active_window_border_color";; # [0xAARRGGBB]
            "nrm_win_bc")       $yabai_setting="normal_window_border_color";; # [0xAARRGGBB]
            "ins_fdbkc")        $yabai_setting="insert_feedback_color" ;;     # [0xAARRGGBB]
            "split_r")          $yabai_setting="split_ratio" ;;               # [<FLOAT_SEL>]
            "auto_balance")     $yabai_setting="fff" ;;                       # [<BOOL_SEL>]
            "mouse_modifier")   $yabai_setting="fff" ;;                       # [cmd|alt|shift|ctrl|fn]
            "mouse_action1")    $yabai_setting="fff" ;;                       # [move|resize]
            "mouse_action2")    $yabai_setting="fff" ;;                       # [move|resize]
            "mouse_drop_action") $yabai_setting="fff" ;;                      # [swap|stack]
            *) echo "NO_MATCH";;
        esac
        call "$yabai_domain $yabai_setting $value"
    else
        echo "linux todo..."
    fi
}

# @param setting
# @param value
# @param space_selection
config_space() {
    ! test -z "${arg1-}" -a "${arg2-}" || exit 1
    local setting=$arg1
    local value=$arg2
    local sel=$arg3
    local space_sel
    ! test -z "${arg3}" && $space_sel="--space $sel"
    if is-mac; then
        local yabai_domain="yabai -m config --space"
        local yabai_setting
        case "$setting" in
            "layout" | "lt")    $yabai_setting="layout";;           # [bsp|stack|float]
            "pad_top" | "pt")   $yabai_setting="top_padding";;      # [<integer number>]
            "pad_btm" | "pb")   $yabai_setting="bottom_padding";;   # [<integer number>]
            "pad_left" | "pl")  $yabai_setting="left_padding";;     # [<integer number>]
            "pad_right" | "pr") $yabai_setting="right_padding";;    # [<integer number>]
            "win_gap" | "wg")   $yabai_setting="window_gap";;       # [<integer number>]
            *) echo "NO_MATCH";;
        esac
        call "$yabai_domain  $space_sel $yabai_setting $value"
    else
        echo "linux todo..."
    fi
}

# @param display_selection
monitor() {
    ! test -z "${arg1-}" || exit 1
    local display_sel=$arg1
    if is-mac; then
        local yabai_domain="yabai -m display --focus"
        call "$yabai_domain $display_sel"
    else
        echo "linux"
    fi
}

# @param command
# @param value
# @param space_selection
space() {
    ! test -z "${arg1-}" || exit 1
    local cmd=$arg1
    local value=$arg2 # if arg2 is empty that is not a problem
    local space_sel
    ! test -z "${arg3}" && $space_sel="--space $arg3"
    if is-mac; then
        local yabai_domain="yabai -m space"
        local yabai_cmd
        case "$cmd" in
            "focus" | "foc")    $yabai_cmd="--focus" ;; # <SPACE_SEL>
            "create" | "new")   $yabai_cmd="--create" ;;                                      # Create a new space on the display of the selected space.
            "destroy" | "del")  $yabai_cmd="--destroy" ;; # Remove the selected space.
            "move" | "mv")      $yabai_cmd="--move" ;; # <SPACE_SEL>                        Move position of the selected space to the position of the given space. The selected space and given space must both belong to the same display.
            "swap" | "sw")      $yabai_cmd="--swap" ;; # <SPACE_SEL>                        Swap the selected space with the given space. The selected space and given space must both belong to the same display.
            "display" | "dsp")  $yabai_cmd="--display" ;; # <DISPLAY_SEL>                           Send the selected space to the given display.
            "balance" | "bl")   $yabai_cmd="--balance" ;; # Adjust the split ratios of the selected space so that all windows occupy the same area.
            "mirror" | "mir")      $yabai_cmd="--mirror" ;; # x-axis|y-axis                            Flip the tree of the selected space.
            "rotate" | "rot")      $yabai_cmd="--rotate" ;; # 90|180|270                               Rotate the tree of the selected space.
            "padding" | "pad")  $yabai_cmd="--padding" ;; # abs|rel:<top>:<bottom>:<left>:<right>   Padding added at the sides of the selected space.
            "gap")              $yabai_cmd="--gap" ;; # abs|rel:<gap>                               Size of the gap that separates windows on the selected space.
            "toggle" | "tg")    $yabai_cmd="--toggle" ;; # padding|gap|mission-control|show-desktop Toggle space setting on or off for the selected space.
            "layout" | "lt")    $yabai_cmd="--layout" ;; # bsp|stack|float                          Set the layout of the selected space.
            "label" | "lb")     $yabai_cmd="--label" ;; # [<LABEL>]                                 Label the selected space, allowing that label to be used as an alias in commands that take a SPACE_SEL parameter. If the command is called without an argument it will try to remove a previously assigned label.
            *) echo "NO_MATCH";;
        esac
        call "$yabai_domain $space_sel $yabai_cmd $value"
    else
        echo "linux todo..."
    fi
}

# @param command
# @param [ value ]
# @param [ window_selection ]
window() {
    ! test -z "${arg1-}" || exit 1
    local cmd=$arg1
    local arg=$arg2
    local win_sel
    ! test -z "${arg3}" && $win_sel="--window $arg3"
    if is-mac; then
        local yabai_domain="yabai -m window"
        local yabai_cmd
        case "$cmd" in
            "focus" | "foc") yabai_cmd="focus" ;; # <WINDOW_SEL>
            "swap" | "sw") yabai_cmd="swap" ;; # <WINDOW_SEL>                   Swap position of the selected window and the given window.
            "warp" | "wrp") yabai_cmd="warp" ;; # <WINDOW_SEL>                   Re-insert the selected window, splitting the given window.
            "stack" | "stk") yabai_cmd="stack" ;; # <WINDOW_SEL>                   Stack the given window on top of the selected window. Any kind of warp operation performed on a stacked window will unstack it.
            "insert" | "zz") yabai_cmd="insert" ;; # <DIR_SEL>|stack                Set the splitting mode of the selected window. If the current splitting mode matches the selected mode, the action will be undone.
            "grid" | "zz") yabai_cmd="grid" ;; # <rows>:<cols>:<start-x>:<start-y>:<width>:<height>     Set the frame of the selected window based on a self-defined grid.
            "move" | "zz") yabai_cmd="move" ;; # abs|rel:<dx>:<dy>                                      If type is rel the selected window is moved by dx pixels horizontally and dy pixels vertically, otherwise dx and dy will become its new position.
            "resize" | "zz") yabai_cmd="resize" ;; # top|left|bottom|right|top_left|top_right|bottom_right|bottom_left|abs:<dx>:<dy>        Resize the selected window by moving the given handle dx pixels horizontally and dy pixels vertically. If handle is abs the new size will be dx width and dy height and cannot be used on managed windows.
            "ratio" | "zz") yabai_cmd="ratio" ;; # rel|abs:<dr>          If type is rel the split ratio of the selected window is changed by dr, otherwise dr will become the new split ratio. A positive/negative delta will increase/decrease the size of the left-child.
            "toggle" | "zz") yabai_cmd="toggle" ;; # float|sticky|topmost|pip|shadow|border|split|zoom-parent|zoom-fullscreen|native-fullscreen|expose Toggle the given property of the selected window.
            "layer" | "zz") yabai_cmd="layer" ;; # <LAYER>                       Set the stacking layer of the selected window.
            "opacity" | "zz") yabai_cmd="opacity" ;; # <floating point number>     Set the opacity of the selected window. The window will no longer be eligible for automatic change in opacity upon focus change. Specify the value 0.0 to reset back to full opacity OR have it be automatically managed through focus changes.
            "display" | "zz") yabai_cmd="display" ;; # <DISPLAY_SEL>               Send the selected window to the given display.
            "space" | "zz") yabai_cmd="space" ;; # <SPACE_SEL> | Send the selected window to the given space.
            "minimize" | "zz") yabai_cmd="minimize";; # Minimizes the selected window. Only works on windows that provide a minimize button in its titlebar.
            "deminimize" | "zz") yabai_cmd="deminimize";; # Restores the selected window, if it is minimized. The window will only get focus if the owning application has focus. Note that you can also --focus a minimized window to restore it as the focused window.
            "close" | "zz") yabai_cmd="close" ;; # Closes the selected window. Only works on windows that provide a close button in its titlebar.
            *) echo "NO_MATCH";;
        esac
        call "$yabai_domain $win_sel --$yabai_cmd $arg"
    else
        echo "linux todo..."
            fi
        }

# --------------------------------------------------
# ---       query | <COMMAND> [<ARGUMENT>]       ---
# --------------------------------------------------

# @param command
# @param argument

# create desktop, move window andK follow focus - uses jq for parsing json (brew install jq)
# shift + cmd - n : yabai -m space --create && \
#                   index="$(yabai -m query --spaces --display | jq 'map(select(."native-fullscreen" == 0))[-1].index')" && \
#                   yabai -m window --space "${index}" && \
#                   yabai -m space --focus "${index}"

# create desktop and follow focus - uses jq for parsing json (brew install jq)
# cmd + alt - n : yabai -m space --create && \
#                 index="$(yabai -m query --spaces --display | jq 'map(select(."native-fullscreen" == 0))[-1].index')" && \
#                 yabai -m space --focus "${index}"

# # Create space, moved focused app, and focus space (requires SIP disabled) - uses jq for parsing json (brew install jq)
# ctrl + shift - w : yabai -m space --create && \
#   index="$(yabai -m query --spaces --display | jq 'map(select(."native-fullscreen" == 0))[-1].index')" && \
#   yabai -m window --space "${index}" && \
#   yabai -m space --focus "${index}"

# # create desktop, move window and follow focus - uses jq for parsing json (brew install jq)
# shift + cmd - n : yabai -m space --create && \
#                   index="$(yabai -m query --spaces --display | jq 'map(select(."native-fullscreen" == 0))[-1].index')" && \
#                   yabai -m window --space "${index}" && \
#                   yabai -m space --focus "${index}"

# # create desktop and follow focus - uses jq for parsing json (brew install jq)
# cmd + ctrl - n : yabai -m space --create && \
#                 index="$(yabai -m query --spaces --display | jq 'map(select(."native-fullscreen" == 0))[-1].index')" && \
#                 yabai -m space --focus "${index}"

# # alt - t : yabai -m window --toggle float && /tmp/yabai-restore/$(yabai -m query --windows --window | jq -re '.id').restore 2>/dev/null || true

# ctrl + alt - s : yabai -m space --layout $(yabai -m query --spaces --space | jq -r 'if .type == "bsp" then "float" else "bsp" end')

query() {
    ! test -z "${arg1-}" || exit 1
    local cmd=$arg1
    local arg=$arg2
    if is-mac; then
        yabai -m query $cmd $arg
        local yabai_domain="yabai -m query"

        # COMMAND
        # --displays        Retrieve information about displays.
        # --spaces          Retrieve information about spaces.
        # --windows         Retrieve information about windows.
        local yabai_cmd=$cmd

        # ARGUMENT
        # --display [<DISPLAY_SEL>]     Constrain matches to the selected display.
        # --space [<SPACE_SEL>]         Constrain matches to the selected space.
        # --window [<WINDOW_SEL>]       Constrain matches to the selected window.
        local argument=$arg

        call "$yabai_domain $argument"
    else
        echo "linux todo..."
    fi
}

# -------------------------
# ---       RULE        ---
# -------------------------

# @param command
# @param [ add_arg1 | add_arg2 | ... | add_argN ] OR [ rm_rule ]

rule() {
    ! test -z "${arg1-}" || exit 1
    local cmd=$arg1
    if is-mac; then
        local yabai_domain="yabai -m rule"
        local yabai_cmd
        local rule_args=()
        if test "$cmd" = "add" -o "$cmd" = "a"; then
            yabai_cmd="add"
            for i in ${fn_args:3}; do # NOTE: why wrapping fn_args in string doesn't work?
                local rule_name=${i%=*}
                local rule_parm=${i#*=}
	            case "$rule_name" in
	                "label") rule_args+=("label=\"$rule_parm\"");; # Label used to identify the rule with a unique name
	                "app") rule_args+=("app=\"$rule_parm\"") ;; # app[!]=<REGEX>
	                "title") ;; # title[!]=<REGEX>
	                "display") ;; # display=[^]<DISPLAY_SEL>
	                "space") ;; # space=[^]<SPACE_SEL>
	                "manage") ;; # manage=<BOOL_SEL>
	                "sticky") ;; # sticky=<BOOL_SEL>
	                "mouse_follows_focus") ;; # mouse_follows_focus=<BOOL_SEL>
	                "layer") ;; # layer=<LAYER>
	                "opacity") ;; # opacity=<FLOAT_SEL>
	                "border") ;; # border=<BOOL_SEL>
	                "native-fullscreen") ;; # native-fullscreen=<BOOL_SEL>
	                "grid") ;; # grid=<rows>:<cols>:<start-x>:<start-y>:<width>:<height>
	                *) echo "NO_MATCH";;
	            esac
            done
	        call "$yabai_domain --$yabai_cmd ${rule_args[@]}"
	    elif test "$cmd" = 'remove' -o "$cmd" = 'rm'; then
            echo "rule remove" # TODO: rule selection | yabai -m rule --remove <RULE_SEL>       Remove an existing rule with the given index or label.
	    elif test "$cmd" = 'list' -o "$cmd" = 'ls'; then
            echo "rule list" # yabai -m rule --list                    Output list of registered rules.
	    fi
    else
        echo "linux todo..."
    fi
}

# @param command
# @param command
# yabai -m signal --add event=<EVENT> action=<ACTION> /// [label=<LABEL>] [app[!]=<REGEX>] [title[!]=<REGEX>]
# --add event=<EVENT> action=<ACTION> [label=<LABEL>] [app[!]=<REGEX>] [title[!]=<REGEX>]
#     Add an optionally labelled signal to execute an action after processing an event of the given type.
#     Some signals can be specified to trigger based on the application name and/or window title.
events() {
    ! test -z "${arg1-}" || exit 1
    local cmd=$arg1
    local evt=$arg2
    if is-mac; then
        local yabai_domain="yabai -m signal"
        local yabai_cmd
        # yabai -m signal
        #       --add   event=display_changed
        #               action="osascript -e 'tell application id \"tracesOf.Uebersicht\" to refresh widget id \"simple-bar-spaces-jsx\"'"
        if test "$cmd" = "add" -o "$cmd" = "a"; then
            $yabai_cmd="add"
            local ybie # yabai event name

            case "$evt" in
                "application_launched") ybie="application_launched";;
                "application_launched") ybie="application_launched";;
                "application_terminated") ybie="application_terminated";;
                "application_front_switched") ybie="application_front_switched";;
                "application_activated") ybie="application_activated";;
                "application_deactivated") ybie="application_deactivated";;
                "application_visible") ybie="application_visible";;
                "application_hidden") ybie="application_hidden";;
                "window_created") ybie="window_created";;
                "window_destroyed") ybie="window_destroyed";;
                "window_focused") ybie="window_focused";;
                "window_moved") ybie="window_moved";;
                "window_resized") ybie="window_resized";;
                "window_minimized") ybie="window_minimized";;
                "window_deminimized") ybie="window_deminimized";;
                "window_title_changed") ybie="window_title_changed";;
                "space_changed") ybie="space_changed";;
                "display_added") ybie="display_added";;
                "display_removed") ybie="display_removed";;
                "display_moved") ybie="display_moved";;
                "display_resized") ybie="display_resized";;
                "display_changed") ybie="display_changed";;
                "mouse_down") ybie="mouse_down";;
                "mouse_up") ybie="mouse_up";;
                "mouse_dragged") ybie="mouse_dragged";;
                "mouse_moved") ybie="mouse_moved";;
                "mission_control_enter") ybie="mission_control_enter";;
                "mission_control_check_for_exit") ybie="mission_control_check_for_exit";;
                "mission_control_exit") ybie="mission_control_exit";;
                "dock_did_restart") ybie="dock_did_restart";;
                "menu_opened") ybie="menu_opened";;
                "menu_bar_hidden_changed") ybie="menu_bar_hidden_changed";;
                "dock_did_change_pref") ybie="dock_did_change_pref";;
                "system_woke") ybie="system_woke";;
                "daemon_message") ybie="daemon_message";;
                *) echo "NO_MATCH";;
            esac
            echo "signal add"

	    elif test "$cmd" = 'remove' -o "$cmd" = 'rm'; then
            echo "signal remove" # yabai -m signal --remove <SIGNAL_SEL>
	    elif test "$cmd" = 'list' -o "$cmd" = 'ls'; then
            echo "signal list" # --list Output list of registered signals.
	    fi
        call "$yabai_domain $yabai_cmd $arg"
    else
        echo "linux todo..."
    fi
}

case "$action" in
    "reload" | "x") reload;;
    "config_global" | "cg") config_global;;
    "config_space" | "cs") config_space;;
    "space" | "s") space;;
    "window" | "w") window;;
    "monitor" | "d") monitor;;
    "query" | "q") query;;
    "rule" | "r") rule;;
    "events" | "e") events;;
    *) exit 1 # no options -> return err
        ;;
esac
