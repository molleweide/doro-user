#!/usr/bin/env bash

function command_aliases() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # short DCA = dorothy command aliases
  # migrate aliases to dorothy

  local USER_COMMAND_ALIASES_DIR="$DOROTHY/user/commands.aliases"

  local supported=(
    sh
    bash
    zsh
    fish
  )
  local supported_posix=(
    sh
    bash
    zsh
    fish
  )
  local supported_non_posix=(
    nu
    elvish
    xonsh
  )

  # =====================================
  # Arguments

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			      command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			       DCAs under "user/commands.aliases/*" (*)

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # local option_args=()
  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--')
      # 	option_args+=("$item" "$@")
      break
      ;;
      # *) option_args+=("$item") ;;
    *) help "An unrecognized argument was provided" ;;
    esac
  done

  # ( ) choose
  # ( ) fuzzy-helper
  # BINDINGS
  #   ( ) create new DCA from selection.
  function act_browse() {
    :
  }

  # Use `dorothy-new` command here later when it is finished.
  # ( ) check if name already exists. confirm...
  # ( ) if you specify a path then create sub dirs under (*)
  function act_create() {
    :
  }

  function act_migrate() {
    local test_file="$DOROTHY/user/sources/aliases.sh"
    local shebang_bash="#!/usr/bin/env bash"

    # TODO: THIS COMMAND
    #       ( ) Put all <name> <content> pairs into array.
    #       ( ) loop
    #           - check if DCA already exists
    #           - direct output into target location
    # TODO: CORE
    #       ( ) Update permissions on DCA dirs
    #           - recursively
    #       ( ) Handle environment
    #           ( ) SEC: Add DCA dirs to path
    #               - recursively get all sub dirs
    #               - add to path
    #               ?? Can we set permissions so all subdirs are executable??

    local output_test_string=''
    local output_name_body_mapping=()

    local interpreter=''

    interpreter="$(get-interpreter --name -- "$test_file")"
    if is-needle "$interpreter" -- "${supported[@]}"; then

      # =======================================================
      # HANDLE POSIX
      # =======================================================

      if is-needle "$interpreter" -- "${supported_posix[@]}"; then
        local aliases=() function_names=() function_bodies=()

        # ----
        # HANDLE POSIX ALIASES
        # ( ) handle comments above??

        output_test_string+=$'\n###############################'
        output_test_string+=$'\n# ALIASES'
        output_test_string+=$'\n###############################'

        local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
        mapfile -t aliases < <(grep -E "$alias_regex" "$test_file" | echo-trim-each-line)
        for line_alias in "${aliases[@]}"; do
          local name='' value='' trailing_comment=''
          # handle trim trailing comment
          if [[ "$line_alias" =~ ^([^\#]*)\s*#\s*(.*) ]]; then
            line_alias="${BASH_REMATCH[1]}"
            trailing_comment="${BASH_REMATCH[2]}"
          fi
          # handle split alias
          if [[ "$line_alias" =~ alias\ ([^=]+)=\"(.*)\" ]]; then
            name="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
          elif [[ "$line_alias" =~ alias\ ([^=]+)=\'(.*)\' ]]; then
            name="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
          fi
          output_test_string+=$'\n#------------------------------'
          output_test_string+=$'\n'"$shebang_bash"
          output_test_string+=$'\n'"# Name: $name"
          output_test_string+=$'\n'"# Desc: $trailing_comment"
          output_test_string+=$'\n'"$value"
        done

        # ----
        # HANDLE POSIX FUNCTIONS

        output_test_string+=$'\n###############################'
        output_test_string+=$'\n# FUNCTIONS'
        output_test_string+=$'\n###############################'
        mapfile -t function_names < <(bash -c 'source '"$test_file"'; declare -F | awk "{print \$3}"')
        local body=''
        for function_name in "${function_names[@]}"; do
          body="$(bash -c 'source '"$test_file"'; declare -f '"$function_name")"
          function_bodies+=("$body")
          output_test_string+=$'\n#------------------------------'
          output_test_string+=$'\n'"$shebang_bash"
          output_test_string+=$'\n'"# Name: $function_name"
          output_test_string+=$'\n'"# Desc: ..."
          output_test_string+=$'\n'"$(__print_lines "$body" | sed '1,2d; $d' | sed 's/^    //')"
        done

        # test print output_test_string.
        bat --style plain --color always --language bash --paging=never <<<"$output_test_string"

        # =======================================================
        # HANDLE OTHER SHELLS BELOW
        # =======================================================

      elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then

        if [[ "$interpreter" == "nu" ]]; then
          # HANDLE NUSHELL
          :
        elif [[ "$interpreter" == "elvish" ]]; then
          # HANDLE ELVISH
          :
        elif [[ "$interpreter" == "xonsh" ]]; then
          # HANDLE XONSH
          :
        fi
      else
        echo "Interpreter [$interpreter] not supported"
      fi
    fi

  }

  act_migrate

)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    command_aliases_test
  else
    command_aliases "$@"
  fi
fi
