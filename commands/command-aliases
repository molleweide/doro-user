#!/usr/bin/env bash

function command_aliases() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # short DCA = dorothy command aliases
  # migrate aliases to dorothy

  # =====================================
  # Arguments

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			      command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			       DCAs under "user/commands.aliases/*" (*)

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # local option_args=()
  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--')
      # 	option_args+=("$item" "$@")
      break
      ;;
      # *) option_args+=("$item") ;;
    *) help "An unrecognized argument was provided" ;;
    esac
  done

  # ( ) choose
  # ( ) fuzzy-helper
  # BINDINGS
  #   ( ) create new DCA from selection.
  function act_browse() {
    :
  }

  # Use `dorothy-new` command here later when it is finished.
  # ( ) check if name already exists. confirm...
  # ( ) if you specify a path then create sub dirs under (*)
  function act_create() {
    :
  }

  local supported=(
    sh
    bash
    zsh
    fish
  )
  local supported_posix=(
    sh
    bash
    zsh
    fish
  )
  local supported_non_posix=(
    nu
    elvish
    xonsh
  )

  function act_migrate() {
    local test_file="$DOROTHY/user/sources/aliases.sh"

    local interpreter=''

    # TODO: (*) parse supported
    #           (x) get fn names and bodies
    #           (x) get aliases
    #       ( )
    #
    interpreter="$(get-interpreter --name -- "$test_file")"
    if is-needle "$interpreter" -- "${supported[@]}"; then

      if is-needle "$interpreter" -- "${supported_posix[@]}"; then
        local aliases=() function_names=() function_bodies=()

        # =======================================================
        # HANDLE POSIX
        # =======================================================

        # ----
        # HANDLE POSIX ALIASES
        #
        # loop
        # ( ) split by [alias <name>=<body>]

        local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
        mapfile -t aliases < <(grep -E "$alias_regex" "$test_file")

        # ----
        # HANDLE POSIX FUNCTIONS
        #
        # loop
        # ( ) take <name> and <body_trimmed>

        mapfile -t function_names < <(bash -c 'source '"$test_file"'; declare -F | awk "{print \$3}"')
        local body=''
        for function_name in "${function_names[@]}"; do
          body="$(bash -c 'source '"$test_file"'; declare -f '"$function_name")"
          function_bodies+=("$body")
        done

      elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then
        # OTHER SHELLS #
        if [[ "$interpreter" == "nu" ]]; then
          # =======================================================
          # HANDLE NUSHELL
          # =======================================================
          :
        elif [[ "$interpreter" == "elvish" ]]; then
          # =======================================================
          # HANDLE ELVISH
          # =======================================================
          :
        elif [[ "$interpreter" == "xonsh" ]]; then
          # =======================================================
          # HANDLE XONSH
          # =======================================================
          :
        fi
      else
        echo "Interpreter [$interpreter] not supported"
      fi
    fi

    # TODO: ( ) Create new file for $item in (*)
    # TODO: ( ) Inject body into file.
    # TODO: ( ) Update permissions
    # TODO: ( ) Reload environment
  }

  act_migrate

)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    command_aliases_test
  else
    command_aliases "$@"
  fi
fi
