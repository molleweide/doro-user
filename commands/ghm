#!/usr/bin/env bash

# NAME: GIT HELP MOLLEWEIDE

# =====================================
# Arguments

# prepare
actions=(
    backup
	get
	new
	vim
)

# help
function help() {
	cat <<-EOF >/dev/stderr
	ABOUT:
	Copy everything from one location to another, features:
	- preserves attributes
	- progress updates
	- local and remote sources

	USAGE:
	cpr [...flags] -- <source> <destination>
	cpr [...flags] [--source=<source>] [--destination=<destination>]

	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines -- "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# process
action=''
args=()
# option_dry='no'
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	    'help' | '--help' | '-h') help ;;
	    # '--action='*) action="${item:9}" ;;
	    # '--action='*) action="${item:9}" ;;
	    # '--tool='*) tool="${item:7}" ;;
	    # '--source='*) option_source="${item:9}" ;;
	    # '--destination='*) option_destination="${item:14}" ;;
	    # '--owner='*) option_owner="${item:8}" ;;
	    # '--no-dry'* | '--dry'*)
    	# 	option_dry="$(get-flag-value dry --missing="$option_dry" -- "$item" | echo-affirmative)"
    	# 	;;
	    # '--no-sudo'* | '--sudo'*)
    	# 	option_sudo="$(get-flag-value sudo --missing="$option_sudo" -- "$item" | echo-affirmative)"
    	# 	;;
	    # '--no-checksum'* | '--checksum'*)
    	# 	option_checksum="$(get-flag-value checksum --missing="$option_checksum" -- "$item" | echo-affirmative)"
    	# 	;;
	    # '--no-remove'* | '--remove'*)
    	# 	option_remove="$(get-flag-value remove --missing="$option_remove" -- "$item" | echo-affirmative)"
    	# 	;;
	    # '--no-linux'* | '--linux'*)
    	# 	option_linux="$(get-flag-value linux --missing="$option_linux" -- "$item" | echo-affirmative)"
    	# 	;;
	    # '--slashes='*) option_slashes="${item:10}" ;;
	    # '--spaces='*) option_spaces="${item:9}" ;;
	    '--') ;;
	    '--'*) help "An unrecognised flag was provided: $item" ;;
	    *)
		    if test -z "$action"; then
			    action="$item"
		        # elif test -z "$args"; then
		    else
    			args+=("$item")
    		# elif test -z "$item"; then
    		# 	help "Empty path argument provided."
    		# else
    		# 	args+=("$item")
    		fi
    		;;
    esac
done

# # ensure valid
# action="$(
# 	choose-option --required \
# 		--question='What action to perform?' \
# 		--filter="$action" -- "${actions[@]}"
# )"
# tools=()
# if test "$action" = 'copy'; then
# 	tools=("${copy_tools[@]}")
# else
# 	tools=("${verify_tools[@]}")
# fi
# tool="$(
# 	choose-option --required \
# 		--question='Which tool to use?' \
# 		--filter="$tool" -- "${tools[@]}"
# )"
# if test -z "$option_source"; then
# 	option_source="$(
# 		ask --required \
# 			--question="Enter the source path."
# 	)"
# fi
# if test -z "$option_destination"; then
# 	option_destination="$(
# 		ask --required \
# 			--question="Enter the destination path."
# 	)"
# fi



# ---------------------------
# ---       gh help       ---
# ---------------------------

# -- flag private.

# USAGE
# gh repo create [<name>] [flags]

# FLAGS
# -c, --clone                 Clone the new repository to the current directory
# -d, --description string    Description of the repository
# --disable-issues        Disable issues in the new repository
# --disable-wiki          Disable wiki in the new repository
# -g, --gitignore string      Specify a gitignore template for the repository
# -h, --homepage URL          Repository home page URL
# --internal              Make the new repository internal
# -l, --license string        Specify an Open Source License for the repository
# --private               Make the new repository private
# --public                Make the new repository public
# --push                  Push local commits to the new repository
# -r, --remote string         Specify remote name for the new repository
# -s, --source string         Specify path to local repository to use as source
# -t, --team name             The name of the organization team to be granted access
# -p, --template repository   Make the new repository based on a template repository

# INHERITED FLAGS
# --help   Show help for command

# EXAMPLES
# # create a repository interactively
# gh repo create

# # create a new remote repository and clone it locally
# gh repo create my-project --public --clone

# # create a remote repository from the current directory
# gh repo create my-project --private --source=. --remote=upstream


# ---------------------------
# ---       HELPERS       ---
# ---------------------------

GHQ_GITHUB="/Users/hjalmarjakobsson/code/repos/github.com"

load_locate() {
  # https://egeek.me/2020/04/18/enabling-locate-on-osx/
  gupdatedb --localpaths=$HOME --prunepaths=/Volumes --output=$HOME/locatedb
}

# # input github ssh string -> return name, user
# get_repo_name_and_user() {
#   # trim ".git"
#   # get last name string after /
#   # strip /
#   # get user after the second last /
# }

# ---------------------------
# ---       ACTIONS       ---
# ---------------------------

# BACKUP ALL REPOS TO A FILE IN YOUR DOTFILES

backup() {
    ghq list > $DOROTHY/user/backups/ghq.bak
    locatedb-load
}

# CLONE A REPO

# @param repo url
clone() {
    ghq get -p $1
    backup
}

# NEW EMPTY REPO

new() {
    repo_name=$1
    github_user=$(git config github.user)
    ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"
    ghq create "$github_user/$repo_name" || exit 1
    backup

    # build
    pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
    >/dev/null 2>&1
    echo "# $1" > README.md
    git add --all && git commit -m 'first'
    gh repo create --source=. --private --push
    popd >/dev/null 2>&1
}

# FORK REPO

# @param repo url
#
fork() {
  repo_url=$1

  if [[ "$1" =~ ^git@.* ]]; then
    # ssh
    repo_url=$(echo $1 | cut -f2 -d":")
  fi

  repo_user=$(basename $(dirname $repo_url))
  repo_name_str=$( basename $repo_url )
  repo_name=${repo_name_str%.*}

  # echo $repo_user $repo_name

  ghq get -p $repo_url
  backup

  pushd "$GHQ_GITHUB/$repo_user/$repo_name" >/dev/null 2>&1

  echo $PWD
  gh repo fork

  # 2. create molleweide branch
  # 3. push

  popd >/dev/null 2>&1

}


# NEW NVIM PLUGIN

nvim() {
    repo_name="$1.nvim"
    github_user=$(git config github.user)
    ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"
    boilit -p "$ghq_gh_user_path" "$repo_name" || exit 1

    # boilit >> need to fix it so that it strips the `.nvim` string within the plugin/code

    pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
    git init
    git add --all && git commit -m 'first'
    gh repo create --source=. --private --push
    popd >/dev/null 2>&1
}

# # add remote and store it to my repos / db so that I can recall all remotes on
# # a new machine
# add_remote() {
# }

remove_repo() {
  echo "todo"
  # remove repo from ghq.
}

# capture_remotes() {
# }

# =====================================
# Act

# if test "$(type -t "act_$action")" = 'function'; then
# 	"act_$action"
# 	exit "$?"
# else
# 	echo-style --error="Action [$action] not yet implemented." >/dev/stderr
# 	exit 78 # Function not implemented
# fi

# echo "${args[@]}"

# echo ">>> $action ${args[@]}"
"$action" "${args[@]}"
exit "$?"
