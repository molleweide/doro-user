#!/usr/bin/env bash

# NAME: GIT HELP MOLLEWEIDE

# uses `ghm` and `gh` to manage repos smoothly

# =====================================
# Todo
#

# rename this command to `repos` so that it can be a more general purpose app manager that uses ghm to manage repos

# bootstrap apps for the user

# allow ssh strings in all commands


# =====================================
# Helpers

GHQ_GITHUB="/Users/hjalmarjakobsson/code/repos/github.com"

load_locate() {
	# https://egeek.me/2020/04/18/enabling-locate-on-osx/
	gupdatedb --localpaths=$HOME --prunepaths=/Volumes --output=$HOME/locatedb
}

# # input github ssh string -> return name, user
# get_repo_name_and_user() {
#   # trim ".git"
#   # get last name string after /
#   # strip /
#   # get user after the second last /
# }

# todo...
ghq_do() {

	ghq create "$github_user/$repo_name" || exit 1
	backup

}

jump_to_repo_and_do() {
  echo "todo.."
	# the idea is to pass an array of the commands necessary and then
	# jump to the dir and run them so that I don't have to repeart push/pop
	# in every function below.
}

# =====================================
# Actions

# BACKUP ALL REPOS TO A FILE IN YOUR DOTFILES

# TODO: needs to be passed the repo as arg instead so that we can append it to
# the backup file.

backup() {
	ghq list >$DOROTHY/user/backups/ghq.bak

	locatedb_load
}

# for each repo store the remotes as space separated entries on the same line
# ^<repo> <remote> <remote> <remote>
verify_all_remotes_are_backed_up() {
  echo "todo..."

  # loop over all repos
  # check that all remotes are listed in the backup file
  # for each repo

  # 1. for each host
  # 2. for each user
  # 3. for each repo
  # 4. find corresponding LINE in backup file
  # 5. get entries by space/tab
  # 6. check that list of remotes
}

# loop over repos and remove non-existing repos from user/backup
clean() {
  echo "clean"
}

# ======================

clone() {
  local repo=$1
	ghq get -p $repo
	backup
}

new() {
	repo_name=$1
	github_user=$(git config github.user)
	ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

	# put into function
	# don't exit. just if already exists. so that we can move on to the next stage
	ghq create "$github_user/$repo_name" || exit 1
	backup

	# build
	pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
	>/dev/null 2>&1
	echo "# $1" >README.md
	git add --all && git commit -m 'first'
	gh repo create --source=. --private --push
	popd >/dev/null 2>&1
}

fork() {
	repo_url=$1

	# TODO: refactor the user strings into function above `get_repo_name_and_user`

	# if url is an ssh string
	if [[ "$1" =~ ^git@.* ]]; then
		repo_url=$(echo $1 | cut -f2 -d":")
	fi

	# extract names
	repo_user=$(basename $(dirname $repo_url))
	repo_name_str=$(basename $repo_url)
	repo_name=${repo_name_str%.*}

	# ghq
	ghq get -p $repo_url
	backup

	# enter repo and perform actions
	pushd "$GHQ_GITHUB/$repo_user/$repo_name" >/dev/null 2>&1
	# echo $PWD
	# TODO: ADD FLAGS
	gh repo fork

	# TODO: molleweide branch; first push;

	popd >/dev/null 2>&1

}

nvim() {
  # create new nvim plugin w/ boilit

	if ! command-exists boilit; then
		echo "This command requires `boilit` package." >/dev/stderr
		return 1
	fi

	repo_name="$1.nvim"
	github_user=$(git config github.user)
	ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

	# SPAWN NEW PLUGIN
	# boilit >> need to fix it so that it strips the `.nvim` string within the plugin/code
	boilit -p "$ghq_gh_user_path" "$repo_name" || exit 1

	pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
	git init
	git add --all && git commit -m 'first'
	gh repo create --source=. --private --push
	popd >/dev/null 2>&1
}

# # add remote and store it to my repos / db so that I can recall all remotes on
# # a new machine
# add_remote() {
# }

remove_repo() {
	echo "todo"
	# remove repo from ghq.
	# 1. remove repo with ghq
	# 2. find repo in backup file and remove entry.
}

# capture_remotes() {
# }

# =====================================
# Act

actions=(
	backup
	get
	new
	vim
)

# help
function help() {
	cat <<-EOF >/dev/stderr
		ABOUT:
		Copy everything from one location to another, features:
		- preserves attributes
		- progress updates
		- local and remote sources

		USAGE:
		cpr [...flags] -- <source> <destination>
		cpr [...flags] [--source=<source>] [--destination=<destination>]

	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines -- "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# process
action=''
args=()
# option_dry='no'
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'help' | '--help' | '-h') help ;;
		# '--action='*) action="${item:9}" ;;
		# '--action='*) action="${item:9}" ;;
		# '--tool='*) tool="${item:7}" ;;
		# '--source='*) option_source="${item:9}" ;;
		# '--destination='*) option_destination="${item:14}" ;;
		# '--owner='*) option_owner="${item:8}" ;;
		# '--no-dry'* | '--dry'*)
		# 	option_dry="$(get-flag-value dry --missing="$option_dry" -- "$item" | echo-affirmative)"
		# 	;;
		# '--no-sudo'* | '--sudo'*)
		# 	option_sudo="$(get-flag-value sudo --missing="$option_sudo" -- "$item" | echo-affirmative)"
		# 	;;
		# '--no-checksum'* | '--checksum'*)
		# 	option_checksum="$(get-flag-value checksum --missing="$option_checksum" -- "$item" | echo-affirmative)"
		# 	;;
		# '--no-remove'* | '--remove'*)
		# 	option_remove="$(get-flag-value remove --missing="$option_remove" -- "$item" | echo-affirmative)"
		# 	;;
		# '--no-linux'* | '--linux'*)
		# 	option_linux="$(get-flag-value linux --missing="$option_linux" -- "$item" | echo-affirmative)"
		# 	;;
		# '--slashes='*) option_slashes="${item:10}" ;;
		# '--spaces='*) option_spaces="${item:9}" ;;
	'--') ;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*)
		# if is empty string
		if test -z "$action"; then
			action="$item"
			# elif test -z "$args"; then
		else
			args+=("$item")
		# elif test -z "$item"; then
		# 	help "Empty path argument provided."
		# else
		# 	args+=("$item")
		fi
		;;
	esac
done

# # ensure valid
# action="$(
# 	choose-option --required \
# 		--question='What action to perform?' \
# 		--filter="$action" -- "${actions[@]}"
# )"
# tools=()
# if test "$action" = 'copy'; then
# 	tools=("${copy_tools[@]}")
# else
# 	tools=("${verify_tools[@]}")
# fi
# tool="$(
# 	choose-option --required \
# 		--question='Which tool to use?' \
# 		--filter="$tool" -- "${tools[@]}"
# )"
# if test -z "$option_source"; then
# 	option_source="$(
# 		ask --required \
# 			--question="Enter the source path."
# 	)"
# fi
# if test -z "$option_destination"; then
# 	option_destination="$(
# 		ask --required \
# 			--question="Enter the destination path."
# 	)"
# fi

# ---------------------------
# ---       gh help       ---
# ---------------------------

# -- flag private.

# USAGE
# gh repo create [<name>] [flags]

# FLAGS
# -c, --clone                 Clone the new repository to the current directory
# -d, --description string    Description of the repository
# --disable-issues        Disable issues in the new repository
# --disable-wiki          Disable wiki in the new repository
# -g, --gitignore string      Specify a gitignore template for the repository
# -h, --homepage URL          Repository home page URL
# --internal              Make the new repository internal
# -l, --license string        Specify an Open Source License for the repository
# --private               Make the new repository private
# --public                Make the new repository public
# --push                  Push local commits to the new repository
# -r, --remote string         Specify remote name for the new repository
# -s, --source string         Specify path to local repository to use as source
# -t, --team name             The name of the organization team to be granted access
# -p, --template repository   Make the new repository based on a template repository

# INHERITED FLAGS
# --help   Show help for command

# EXAMPLES
# # create a repository interactively
# gh repo create

# # create a new remote repository and clone it locally
# gh repo create my-project --public --clone

# # create a remote repository from the current directory
# gh repo create my-project --private --source=. --remote=upstream

# if test "$(type -t "act_$action")" = 'function'; then
# 	"act_$action"
# 	exit "$?"
# else
# 	echo-style --error="Action [$action] not yet implemented." >/dev/stderr
# 	exit 78 # Function not implemented
# fi

# echo "${args[@]}"

# echo ">>> $action ${args[@]}"
"$action" "${args[@]}"
exit "$?"
