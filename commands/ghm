#!/usr/bin/env bash

# NAME: GIT HELP MOLLEWEIDE

# NOTE: CRUD wrapper around GHQ for Dorothy.
# It makes sure that information about what repos your are using are backed
# up properly to your dorothy user config.

# TODO: i need to create a function that returns the repo HOST, USER and REPO
# so the backing up repos isn't reliant on the GHQ list command.

function ghm() (
	GHQ_BACKUP_FILE="$DOROTHY/user/backups/ghq.bak"

	# =====================================
	# Act

	actions=(
		restore
		backup
		get
		new
		vim
	)

	# process
	action=''
	args=()
	# option_dry='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'help' | '--help' | '-h') help ;;
			# '--action='*) action="${item:9}" ;;
			# '--action='*) action="${item:9}" ;;
			# '--tool='*) tool="${item:7}" ;;
			# '--source='*) option_source="${item:9}" ;;
			# '--destination='*) option_destination="${item:14}" ;;
			# '--owner='*) option_owner="${item:8}" ;;
			# '--no-dry'* | '--dry'*)
			# 	option_dry="$(get-flag-value dry --missing="$option_dry" -- "$item" | echo-affirmative)"
			# 	;;
			# '--no-sudo'* | '--sudo'*)
			# 	option_sudo="$(get-flag-value sudo --missing="$option_sudo" -- "$item" | echo-affirmative)"
			# 	;;
			# '--no-checksum'* | '--checksum'*)
			# 	option_checksum="$(get-flag-value checksum --missing="$option_checksum" -- "$item" | echo-affirmative)"
			# 	;;
			# '--no-remove'* | '--remove'*)
			# 	option_remove="$(get-flag-value remove --missing="$option_remove" -- "$item" | echo-affirmative)"
			# 	;;
			# '--no-linux'* | '--linux'*)
			# 	option_linux="$(get-flag-value linux --missing="$option_linux" -- "$item" | echo-affirmative)"
			# 	;;
			# '--slashes='*) option_slashes="${item:10}" ;;
			# '--spaces='*) option_spaces="${item:9}" ;;
		'--') ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			# if is empty string
			if test -z "$action"; then
				action="$item"
				# elif test -z "$args"; then
			else
				args+=("$item")
			# elif test -z "$item"; then
			# 	help "Empty path argument provided."
			# else
			# 	args+=("$item")
			fi
			;;
		esac
	done

	# ---------------------------
	# ---       gh help       ---
	# ---------------------------

	# -- flag private.

	# USAGE
	# gh repo create [<name>] [flags]

	# FLAGS
	# -c, --clone                 Clone the new repository to the current directory
	# -d, --description string    Description of the repository
	# --disable-issues        Disable issues in the new repository
	# --disable-wiki          Disable wiki in the new repository
	# -g, --gitignore string      Specify a gitignore template for the repository
	# -h, --homepage URL          Repository home page URL
	# --internal              Make the new repository internal
	# -l, --license string        Specify an Open Source License for the repository
	# --private               Make the new repository private
	# --public                Make the new repository public
	# --push                  Push local commits to the new repository
	# -r, --remote string         Specify remote name for the new repository
	# -s, --source string         Specify path to local repository to use as source
	# -t, --team name             The name of the organization team to be granted access
	# -p, --template repository   Make the new repository based on a template repository

	# INHERITED FLAGS
	# --help   Show help for command

	# EXAMPLES
	# # create a repository interactively
	# gh repo create

	# # create a new remote repository and clone it locally
	# gh repo create my-project --public --clone

	# # create a remote repository from the current directory
	# gh repo create my-project --private --source=. --remote=upstream

	# if test "$(type -t "act_$action")" = 'function'; then
	# 	"act_$action"
	# 	exit "$?"
	# else
	# 	echo-style --error="Action [$action] not yet implemented." >/dev/stderr
	# 	exit 78 # Function not implemented
	# fi

	# echo "${args[@]}"

	# =====================================
	# Todo
	#

	# rename this command to `repos` so that it can be a more general purpose app manager that uses ghm to manage repos

	# bootstrap apps for the user

	# allow ssh strings in all commands

	# =====================================
	# Helpers

	# todo: replace with $HOME/
	GHQ_GITHUB="/Users/hjalmarjakobsson/code/repos/github.com"

	load_locate() {
		# https://egeek.me/2020/04/18/enabling-locate-on-osx/
		gupdatedb --localpaths=$HOME --prunepaths=/Volumes --output=$HOME/locatedb
	}

	# # input github ssh string -> return name, user
	# get_repo_name_and_user() {
	#   # trim ".git"
	#   # get last name string after /
	#   # strip /
	#   # get user after the second last /
	# }

	# todo...
	ghq_do() {

		ghq create "$github_user/$repo_name" || exit 1
		backup

	}

	jump_to_repo_and_do() {
		echo "todo.."
		# the idea is to pass an array of the commands necessary and then
		# jump to the dir and run them so that I don't have to repeart push/pop
		# in every function below.
	}

	# =====================================
	# Actions

	# BACKUP ALL REPOS TO A FILE IN YOUR DOTFILE

	# TODO: needs to be passed the repo as arg instead so that we can append it to
	# the backup file.
	#

	get_vcs_host() {
		:
	}
	get_vcs_user() {
		:
	}
	get_vcs_repo_name() {
		echo "xxxx"
		:
	}

	# TODO: I need to retrieve the HOST, USER, and REPO name for backup so that
	# I know that I store each part specifically as the first three whitespace
	# separated entries in the backup file
	backup() {
		if [ -z "$1" ]; then
			# FIX: remove this later when I know how to get the proper repo string
			# for each repo later so that I can just append each repo instead
			ghq list >$DOROTHY/user/backups/ghq.bak
		else
			$1 >>$DOROTHY/user/backups/ghq.bak
		fi

		# NOTE: what does this really do??
		locatedb_load
	}

	# remove repo from ghq tree and from backup file
	# @args host user repo
	remove_repo() {

		# TODO:
		# get host from $1
		# get user from $2
		# get repo from $3

		# Specify the GitHub repo URL you want to remove
		github_url="https:\/\/github\.com\/username\/repo"

		# Specify the input file
		input_file="input_file.txt"

		# Create a temporary file for storing modified content
		temp_file=$(mktemp)

		# Use grep to filter out lines that match the GitHub URL
		grep -v "$github_url" "$input_file" >"$temp_file"

		# Replace the original file with the modified content
		mv "$temp_file" "$input_file"

		echo "Lines with the GitHub URL removed."
	}

	# restore all repos from backup file
	# TODO: use dorothy tty to prompt user with the current ghq root so that
	# user can be sure that things are installed to the right location.
	restore_repos() {
		if command-exists "ghq"; then

			if [ ! -f "$GHQ_BACKUP_FILE" ]; then
				echo "user/backups/ghq.bak doesn't exist"
				exit 1
			fi

			while IFS= read -r line; do

				entries=($line)

				the_repo_url="${entries[0]}"
				echo "repo: $the_repo_url"

				# TODO: get repos
				ghq get -p $the_repo_url

				# for entry in "${entries[@]}"; do
				# 	# Process each entry here
				# 	echo "Entry: $entry"
				# done

			done <"$GHQ_BACKUP_FILE"

			:
		fi
	}

	# for each repo store the remotes as space separated entries on the same line
	# ^<repo> <remote> <remote> <remote>
	verify_all_remotes_are_backed_up() {
		echo "todo..."

		# loop over all repos
		# check that all remotes are listed in the backup file
		# for each repo

		# 1. for each host
		# 2. for each user
		# 3. for each repo
		# 4. find corresponding LINE in backup file
		# 5. get entries by space/tab
		# 6. check that list of remotes


		# NOTE: this is how I can find each repo line and add the additional string
		# at the end

		# Specify the string to add
		suffix="suffix"

		# Specify the target string within lines
		target="target"

		# Specify the input file
		input_file="input_file.txt"

		# Use sed to modify the lines
		sed -i "/$target/ s/$/ $suffix/" "$input_file"

		echo "Strings added to lines containing 'target'."

	}

	# loop over repos and remove non-existing repos from user/backup
	function clean() {
		echo "clean"
	}

	# ======================

	function clone() {
		local repo=$1
		ghq get -p $repo

		backup
	}

	function new() {
		repo_name=$1
		github_user=$(git config github.user)
		ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

		# put into function
		# don't exit. just if already exists. so that we can move on to the next stage
		ghq create "$github_user/$repo_name" || exit 1
		backup

		# build
		pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
		>/dev/null 2>&1
		echo "# $1" >README.md
		git add --all && git commit -m 'first'
		gh repo create --source=. --private --push

		# TODO: here I want to get the repo url from

		popd >/dev/null 2>&1
	}

	function fork() {
		repo_url=$1

		# TODO: refactor the user strings into function above `get_repo_name_and_user`

		# if url is an ssh string
		if [[ "$1" =~ ^git@.* ]]; then
			repo_url="$(echo "$1" | cut -f2 -d":")"
		fi

		# extract names
		repo_user=$(basename $(dirname $repo_url))
		repo_name_str=$(basename $repo_url)
		repo_name=${repo_name_str%.*}

		# ghq
		ghq get -p $repo_url
		backup

		# enter repo and perform actions
		pushd "$GHQ_GITHUB/$repo_user/$repo_name" >/dev/null 2>&1
		# echo $PWD
		# TODO: ADD FLAGS
		gh repo fork

		# TODO: molleweide branch; first push;

		popd >/dev/null 2>&1

	}

	function nvim() {
		# create new nvim plugin w/ boilit

		if ! command-exists boilit; then
			echo "This command requires $(boilit) package." >/dev/stderr
			return 1
		fi

		repo_name="$1.nvim"
		github_user=$(git config github.user)
		ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

		# SPAWN NEW PLUGIN
		# boilit >> need to fix it so that it strips the `.nvim` string within the plugin/code
		boilit -p "$ghq_gh_user_path" "$repo_name" || exit 1

		pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
		git init
		git add --all && git commit -m 'first'
		gh repo create --source=. --private --push
		popd >/dev/null 2>&1
	}

	# echo ">>> $action ${args[@]}"

	# =====================================
	# Act

	if test "$action" = "restore_repos"; then
		restore_repos
	elif test "$action" = 'remove_repo'; then
		remove_repo "${args[@]}"
	elif test "$action" = 'nvim'; then
		nvim "${args[@]}"
	fi

	# "$action" "${args[@]}"
	exit "$?"

	# if test "$action" = 'install'; then
	# 	setup-util-1password-cli --upgrade
	# elif test "$action" = 'login'; then
	# 	secret_signout --quiet >/dev/stderr
	# 	# trunk-ignore(shellcheck/SC2119)
	# 	secret_signin
	# elif test "$action" = 'logout'; then
	# 	secret_signout
	# elif test "$action" = 'map'; then
	# 	secret_map "${args[@]}"
	# elif test "$action" = 'env'; then
	# 	secret_env "${args[@]}"
	# elif test "$action" = 'get'; then
	# 	if test -n "${args[*]}"; then
	# 		secret_get "${args[@]}"
	# 	else
	# 		help "get action requires <name> argument"
	# 	fi
	# elif test "$action" = 'invalidate'; then
	# 	if test -n "${args[*]}"; then
	# 		cache_delete "${args[@]}"
	# 	else
	# 		cache_clear
	# 	fi
	# elif test "$action" = 'unmap'; then
	# 	secret_unmap "${args[@]}"
	# elif test "$action" = 'fetch'; then
	# 	secret_fetch "${args[@]}"
	# elif test "$action" = 'https'; then
	# 	secret_https "${args[@]}"
	# elif test "$action" = 'help'; then
	# 	help
	# else
	# 	help 'Invalid <action>'
	# fi

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	ghm "$@"
fi
