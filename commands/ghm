#!/usr/bin/env bash

# NAME: GIT HELP MOLLEWEIDE

# NOTE: CRUD wrapper around GHQ for Dorothy.
# It makes sure that information about what repos your are using are backed
# up properly to your dorothy user config.

function ghm() (
	GHQ_BACKUP_FILE="$DOROTHY/user/backups/ghq.bak"

	# =====================================
	# ??

	actions=(
		restore
		backup
		get
		new
		vim
	)

	# process
	action=''
	args=()
	# option_dry='no'
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'help' | '--help' | '-h') help ;;
		'--') ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			# if is empty string
			if test -z "$action"; then
				action="$item"
				# elif test -z "$args"; then
			else
				args+=("$item")
			# elif test -z "$item"; then
			# 	help "Empty path argument provided."
			# else
			# 	args+=("$item")
			fi
			;;
		esac
	done

	# =====================================
	# Helpers

	# TODO: replace with $HOME/
	GHQ_GITHUB="/Users/hjalmarjakobsson/code/repos/github.com"

	# this has been moved to its own command?
	load_locate() {
		# https://egeek.me/2020/04/18/enabling-locate-on-osx/
		gupdatedb --localpaths=$HOME --prunepaths=/Volumes --output=$HOME/locatedb
	}

	# # input github ssh string -> return name, user
	# get_repo_name_and_user() {
	#   # trim ".git"
	#   # get last name string after /
	#   # strip /
	#   # get user after the second last /
	# }

	# todo...
	ghq_do() {

		ghq create "$github_user/$repo_name" || exit 1
		backup

	}

	jump_to_repo_and_do() {
		echo "todo.."
		# the idea is to pass an array of the commands necessary and then
		# jump to the dir and run them so that I don't have to repeart push/pop
		# in every function below.
	}

	# =====================================
	# Actions

	# BACKUP ALL REPOS TO A FILE IN YOUR DOTFILE

	# get host, user, and repo from a repo url.
	# This function is a bit hacky.
	function get_parts() {
		url="$1"

		git_trimmed=${url%.git}
		REPO_NAME="${git_trimmed##*/}"

		repo_trimmed="${git_trimmed%/*}"
		USER_NAME=$(echo "$repo_trimmed" | sed -E 's/.*[:\/]([^\/]*)$/\1/')

		left="${repo_trimmed%?$USER_NAME}"
		HOST_NAME="${left##*[\/@]}"

		# echo "$REPO_NAME, $repo_trimmed  >> $USER_NAME >>>>> $left"
		echo "$HOST_NAME" "$USER_NAME" "$REPO_NAME"
	}

	function testing() {
		result_array=($(get_parts "$1"))
		echo "${result_array[0]}/${result_array[1]}/${result_array[2]}"
	}

	function backup() {
		local repo_url=$1
		local already_prepared=$2

		if [ -z "$repo_url" ]; then
			echo "No repo was provided to [ghm backup]"
		else

			if test "$already_prepared" = "true"; then

				"$repo_url" >>"$DOROTHY/user/backups/ghq.bak"
			else
				local result_array=($(get_parts "$repo_url"))

				"${result_array[0]}/${result_array[1]}/${result_array[2]}" >>"$DOROTHY/user/backups/ghq.bak"
			fi

			# NOTE: what does this really do??
			locatedb_load
		fi

	}

	# remove repo from ghq tree and from backup file
	# @args host user repo
	remove_repo() {

		# TODO:
		# get host from $1
		# get user from $2
		# get repo from $3

		# Specify the GitHub repo URL you want to remove
		github_url="https:\/\/github\.com\/username\/repo"

		# Specify the input file
		input_file="input_file.txt"

		# Create a temporary file for storing modified content
		temp_file=$(mktemp)

		# Use grep to filter out lines that match the GitHub URL
		grep -v "$github_url" "$input_file" >"$temp_file"

		# Replace the original file with the modified content
		mv "$temp_file" "$input_file"

		echo "Lines with the GitHub URL removed."
	}

	# restore all repos from backup file
	# TODO: use dorothy tty to prompt user with the current ghq root so that
	# user can be sure that things are installed to the right location.
	restore_repos() {

		# install ghq
		if ! command-exists ghq; then
			if is-mac; then
				brew install ghq
			else
				go install github.com/x-motemen/ghq@latest
			fi
		fi

		# still if installing didn't work exit
		if ! command-exists ghq; then
			exit
		fi

		ghq_root_string=$(ghq root)
		pattern="code/repos"
		if [[ ! "$ghq_root_string" == *"$pattern"* ]]; then
			echo "ghq root/config hasn't been setup to [ code/repos ]. Exiting..."
			exit
		fi

		if [ ! -f "$GHQ_BACKUP_FILE" ]; then
			echo "user/backups/ghq.bak doesn't exist"
			exit 1
		fi

		while IFS= read -r line; do
			entries=("$line")
			the_repo_url="${entries[0]}"
      # test: use silent here, since we are downloading many repos.
			ghq get -p -s "$the_repo_url"

			# for entry in "${entries[@]}"; do
			# 	# Process each entry here
			# 	echo "Entry: $entry"
			# done
		done <"$GHQ_BACKUP_FILE"
	}

	# for each repo store the remotes as space separated entries on the same line
	# ^<repo> <remote> <remote> <remote>
	verify_all_remotes_are_backed_up() {
		echo "todo..."

		# loop over all repos
		# check that all remotes are listed in the backup file
		# for each repo

		# 1. for each host
		# 2. for each user
		# 3. for each repo
		# 4. find corresponding LINE in backup file
		# 5. get entries by space/tab
		# 6. check that list of remotes

		# NOTE: this is how I can find each repo line and add the additional string
		# at the end

		# Specify the string to add
		suffix="suffix"

		# Specify the target string within lines
		target="target"

		# Specify the input file
		input_file="input_file.txt"

		# Use sed to modify the lines
		sed -i "/$target/ s/$/ $suffix/" "$input_file"

		echo "Strings added to lines containing 'target'."

	}

	# loop over repos and remove non-existing repos from user/backup
	function clean() {
		echo "clean"
	}

	function inti_github_remote() {
		pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
		>/dev/null 2>&1
		echo "# $1" >README.md
		git add --all && git commit -m 'first'
		gh repo create --source=. --private --push
		popd >/dev/null 2>&1
	}

	# ======================

	function clone() {
		local repo=$1
		ghq get -p $repo

		backup $repo
	}

	function new() {
		repo_name=$1

		# FIX: move these to the top of the `ghm` function, so I don't have to keep
		# redoing these.

		github_user=$(git config github.user)
		ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

		# put into function
		# don't exit. just if already exists. so that we can move on to the next stage
		ghq create "$github_user/$repo_name" || exit 1

		backup "github.com/$github_user/$repo_name" true

		# build
		# FIX: replace this with `inti_github_remote`
		pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
		>/dev/null 2>&1
		echo "# $1" >README.md
		git add --all && git commit -m 'first'
		gh repo create --source=. --private --push
		popd >/dev/null 2>&1
	}

	function fork() {
		repo_url=$1

		# TODO: refactor the user strings into function above `get_repo_name_and_user`

		# if url is an ssh string
		if [[ "$1" =~ ^git@.* ]]; then
			repo_url="$(echo "$1" | cut -f2 -d":")"
		fi

		# extract names
		repo_user=$(basename $(dirname "$repo_url"))
		repo_name_str=$(basename "$repo_url")
		repo_name=${repo_name_str%.*}

		# ghq
		ghq get -p "$repo_url"
		backup "$repo_url"

		# enter repo and perform actions
		pushd "$GHQ_GITHUB/$repo_user/$repo_name" >/dev/null 2>&1
		# echo $PWD
		# TODO: ADD FLAGS
		gh repo fork

		# TODO: molleweide branch; first push;

		popd >/dev/null 2>&1
	}

	# create new nvim plugin w/ boilit
	# TODO: needs backup
	function nvim() {
		if ! command-exists boilit; then
			echo "This command requires $(boilit) package." >/dev/stderr
			return 1
		fi

		repo_name="$1.nvim"
		github_user=$(git config github.user)
		ghq_gh_user_path="/Users/hjalmarjakobsson/code/repos/github.com/$github_user/"

		# SPAWN NEW PLUGIN
		# boilit >> need to fix it so that it strips the `.nvim` string within the plugin/code
		boilit -p "$ghq_gh_user_path" "$repo_name" || exit 1

		pushd $ghq_gh_user_path/$repo_name >/dev/null 2>&1
		git init
		git add --all && git commit -m 'first'
		gh repo create --source=. --private --push
		popd >/dev/null 2>&1

		backup "github.com/$github_user/$repo_name" true
	}

	# =====================================
	# Act

	# echo ">>> $action ${args[@]}"

	if test "$action" = "test"; then
		testing "${args[@]}"
	elif test "$action" = "restore_repos"; then
		restore_repos
	elif test "$action" = 'remove_repo'; then
		remove_repo "${args[@]}"
	elif test "$action" = 'nvim'; then
		nvim "${args[@]}"
	elif test "$action" = 'gp'; then
		get_parts "${args[@]}"
	elif test "$action" = 'new'; then
		new "${args[@]}"
	elif test "$action" = 'clone'; then
		clone "${args[@]}"
	elif test "$action" = 'fork'; then
		fork "${args[@]}"
	fi

	exit "$?"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	ghm "$@"
fi
