#!/usr/bin/env bash

# # --alias | --fn
# function get_comment_block_above() {
# 	# This is a sample script from ChatGPT.
#
# 	# # Function to greet someone
# 	# # Usage: greet <name>
# 	# greet() {
# 	# 	local name="$1"
# 	# 	echo "Hello, $name!"
# 	# }
#
# 	# Extract comment block above a function definition
# 	extract_comment() {
# 		local function_name="$1"
# 		awk -v func="$function_name" '
# 	  /^#/ { comments = comments "\n" $0; next }
# 	  $0 ~ "^" func "\\(" { print comments; exit }
# 	  { comments = "" }
# 	  ' "$0"
# 	}
#
# 	# Example usage:
# 	comment_block=$(extract_comment "greet")
# 	echo "$comment_block"
# }

# TODO: Move comment block extractor into its own file.
# Example usage
# extract_comments_for_all_functions "your_script.sh"
function echo_bash_comment_blocks() (

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  function extract_comments_for_all_functions() {
    awk '
	    /^#/ { comments = comments "\n" $0; next }  # Collect comment lines
	    /^[a-zA-Z_][a-zA-Z0-9_]*\(\) *{/ {          # Match function definitions
	        func_name = $1;                         # Capture function name
	        sub(/\(\)$/, "", func_name);            # Remove () from name
	        print "Function: " func_name;           # Print function name
	        print comments "\n";                    # Print associated comment block
	        comments = "";                          # Reset comments
	    }
	    { comments = "" }  # Reset comments if a non-comment, non-function line is encountered
	    ' "$1"
  }

)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		echo_bash_comment_blocks_test
	else
		echo_bash_comment_blocks "$@"
	fi
fi
