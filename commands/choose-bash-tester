#!/usr/bin/env bash

# TODO: [x] obtain executed command path
# [*] move filtering mechanism into `get-definitions`
# [ ] get-definitions from path by using `env -i`

# FIX: [ ] Now that this naturally is running as a subshell, we need to figure
# out a way to access the functions in the parent process.
# https://unix.stackexchange.com/questions/214340/using-a-function-defined-in-a-parent-script
# https://askubuntu.com/questions/1494982/problem-regarding-passing-a-function-to-child-process-in-linux-shell
# https://stackoverflow.com/questions/2199455/bash-how-to-call-a-function-declared-in-a-parent-shell
# https://stackoverflow.com/questions/3412318/calling-bash-functions-from-sub-process?noredirect=1&lq=1
# TEST: [ ] Try re-sourcing the target command with `test cases` in the
# `choose-bash-testet` command.

# TEST: [ ] Use `bat` to get colorful output of each test case fn.
# Can this be displayed properly in choose?

# TEST: [ ] It should be possible to get the path of the command that
# called the bash tester, eg with $PWD.
# https://unix.stackexchange.com/questions/52916/get-directory-from-which-script-was-called-from
# https://unix.stackexchange.com/questions/118040/where-is-a-shell-script-run-from?rq=1
# (linux only)
# echo "Parent script (caller) path: $(tr '\0' ' ' < /proc/$PPID/cmdline)"
# (cross platform)
# echo "Parent script (caller) path: $(ps -o command= -p $PPID)"
# ----
# PPID   The process ID of the shell's parent.  This variable is readonly.
# PWD    The current working directory as set by the cd command.
# -----
# get pid of curr proc
# https://stackoverflow.com/questions/41787234/how-to-know-the-process-id-of-current-bash-session
# -----
# why is current $$ returning same as parent pid
# https://stackoverflow.com/questions/21063765/why-is-returning-the-same-id-as-the-parent-process?noredirect=1&lq=1
# --
# https://stackoverflow.com/questions/5615570/in-a-script-vs-in-a-subshell?rq=3
#
#

# =======================================================
# ChatGPT solution to accessing the funcs in parent shell.
#
# NOTE: I need to export all func names in a loop.

# In Bash, `declare -f` lists functions **in the current shell**. However, if you want to access functions **from a parent shell**, things get tricky because child processes **cannot access** the parent shell's environment directly.
#
# ### âœ… **Solution: Export the Function (`export -f`)**
# Bash allows exporting functions so that they are available to subprocesses.
#
# #### **Step 1: Export the Function in the Parent Shell**
# ```bash
# my_function() {
#     echo "Hello from parent shell!"
# }
# export -f my_function
# ```
#
# #### **Step 2: Run `declare -f` in the Child Process**
# Now you can run:
# ```bash
# bash -c 'declare -f my_function'
# ```
#
# ### ðŸ” **Explanation**
# - `export -f my_function` â†’ Exports `my_function` so that it's available in subshells.
# - `bash -c 'declare -f my_function'` â†’ Runs a new Bash instance and lists the function.
#
# ---
#
# ### âš ï¸ **Alternative: Source the Parent Shell's Environment**
# If you didn't `export -f`, you **cannot access functions from the parent shell**. But you can:
# 1. **Save functions to a file** in the parent shell:
#    ```bash
#    declare -f > /tmp/functions.sh
#    ```
# 2. **Source them in the child process**:
#    ```bash
#    bash -c 'source /tmp/functions.sh; declare -f'
#    ```
#
# ---
#
# ### ðŸ”¥ **Key Takeaways**
# | Approach | Can Access Parent's Functions? | Notes |
# |----------|--------------------------|-------|
# | `export -f` | âœ… Yes | Best method if you know the function name |
# | `declare -f > file && source file` | âœ… Yes | Useful if you have multiple functions |
# | `bash -c 'declare -f'` | âŒ No | Doesn't work unless functions are exported |

# =======================================================

function choose_bash_tester() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	echo-style $'\n' --bold="-- CHOOSE BASH TESTER --" $'\n'

	__print_lines "CURRENT PID: $$ -> exec cmd/script: $(ps -o command= -p $$)"
	__print_lines "PARRENT PID: $PPID -> exec cmd/script: $(ps -o command= -p $PPID)"
	__print_lines "PWD: $PWD"

	#  # The pid is the same as outer closure. Is this due to some shopt??
	# test_pid() (
	# 	__print_lines "test_pid: Current PID: $$ -> exec cmd/script: $(ps -o command= -p $$)"
	# 	__print_lines "test_pid: Parrent PID: $PPID -> exec cmd/script: $(ps -o command= -p $PPID)"
	# )
	# test_pid

	# =====================================
	# Arguments

	# TODO: [ ] fix this
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper UI for running test examples when researching bash/shell features.

			USAGE:
			choose-bash-testet [...options forwarded to choose] -- ...<path>s
		EOF
		return 22 # EINVAL 22 Invalid argument
	}

	# process
	local item option_paths=() options=()
	local func_names_found=()
	local func_names_final=() choose_data=()

	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		# '--paths='*) option_paths+=("${item#*=}") ;;
		'--')
			option_paths+=("$@")
			shift "$#"
			break
			;;
		*) options+=("$item") ;;
		esac
	done

	# ensure we have a target path
	if [[ ${#option_paths[@]} -eq 0 ]]; then
		# get the executed command path

		local caller_command

		# caller_command=$(ps -o command= -p "$PPID" | echo-split ' ')

		# this is safe because ps always lists `shell <path>`
		caller_command=$(ps -o command= -p "$PPID" | echo-split ' ' | tail -n 1)

		# local arr=()
		# mapfile -t arr < <(ps -o command= -p $PPID | echo-split ' ')
		# caller_command="${arr[1]}"

		# echo "EXECUTED PATH: $caller_command"

		option_paths+=("$caller_command")
	fi

	# if [[ ${#func_names_found[@]} -eq 0 ]]; then
	# 	help 'No <function_ids>s provided.'
	# fi

	# __print_lines "option_paths:"
	# __print_lines "${option_paths[@]}"

	# --------------------------------------------
	# get target path

	# NOTE: currently only supports one single target path!


	# "$1" # "${BASH_SOURCE[0]}"
	local this_path="${option_paths[0]}"

	echo-style --bold "Target this path: [$this_path]"
	# echo-lines "${func_names_found[@]}"

	#  # [x] Test resource the target file. Does not work.
	#  set -x
	# source "$this_path"
	# _a_function_which_failure_IS_NOT_the_last_command
	# set  +x

	# =====================================
	# Action

	# # adjust args to paths and basenames
	# local values=()
	# mapfile -t values < <(echo-paths-and-basenames -- "${option_paths[@]}")
	#
	# # ask with label
	# choose --label "${options[@]}" -- "${values[@]}"

	# Why is it that this returns a single string it seems?!
	# func_names_found="$(get-definitions "$this_path")"

	# # [*] Test move this into the test case file.
	# local func_names_found=()
	mapfile -t func_names_found < <(get-definitions -- "$this_path")

	__print_lines "${func_names_found[@]}"

	exit

	# --------------------------------------------
	# filter unwanted ids

	# NOTE: Since this is now running in an isolated command, this block might
	# be unnecessary.
	# However, we might always want to exclude definitis in certain commands,
	# such as this one??

	# FIX: [ ] Move this filter into the `get-definitions` command

	# This should prolly go into a command called echo-filter
	local remove_ids=(
		"render_choose_data"
	)
	for id in "${func_names_found[@]}"; do
		local add='yes'
		local rm_id
		for rm_id in "${remove_ids[@]}"; do
			if [[ "$id" == _* || "$rm_id" == "$id" ]]; then
				add='no'
			fi
		done
		if [[ "$add" == 'yes' ]]; then
			func_names_final+=("$id")
		fi
	done

	# ---------

	function render_choose_data {
		local id="$1" description body body_formatted
		description="${id//_/ }"
		description="${description^}"

		# FIX: Now when this command is running in a subshell, it means that it needs
		# a workaround to be able to access the functions defined in the parent process.

		set -x
		body="$(declare -f "$id")"
		set +x
		# Unfortunately, using negative numbers does not work with head on macos.
		# body_formatted="$(echo-lines "$(declare -f "$id")" | tail -n +3 | head -n -1)"
		body_formatted="$(echo-lines "$body" | sed '1,2d; $d')"
		# prefix with an empty dim to disable the default dimming in results
		# Why is the final linebreak trimmed when displaying the information??
		echo-style --dim='' --bold+underline="$description" $'\n' --dim="$body_formatted" $'\n'
	}
	for id in "${func_names_final[@]}"; do
		choose_data+=(
			"$id"
			"$(render_choose_data "$id")"
		)
	done

	local selection
	selection="$(
		choose --required --label \
			--question='Which test do you want to run?' \
			-- "${choose_data[@]}"
	)"

	# =================================
	# Run selection

	__print_lines "Selection: [$selection]"

	"$selection"

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	choose_bash_tester "$@"
fi
