#!/usr/bin/env bash

# # --alias | --fn
# function get_comment_block_above() {
# 	# This is a sample script from ChatGPT.
#
# 	# # Function to greet someone
# 	# # Usage: greet <name>
# 	# greet() {
# 	# 	local name="$1"
# 	# 	echo "Hello, $name!"
# 	# }
#
# 	# Extract comment block above a function definition
# 	extract_comment() {
# 		local function_name="$1"
# 		awk -v func="$function_name" '
# 	  /^#/ { comments = comments "\n" $0; next }
# 	  $0 ~ "^" func "\\(" { print comments; exit }
# 	  { comments = "" }
# 	  ' "$0"
# 	}
#
# 	# Example usage:
# 	comment_block=$(extract_comment "greet")
# 	echo "$comment_block"
# }

# NOTE: Name suggestions
# echo-preceeding-comment-blocks

function echo_comment_blocks() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_COMMENT_REGEX='/^#/'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_FUNCTION_DEFINITIONS_REGEX='/^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/'
  # local zsh
  # local fish
  # local nu

  # =======================================================
  # Help

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			Defaults to spitting out all findings.

			You can specify which type of definition name above which you want
			to extract the comment.

			This helper helps in capturing preceeding comment blocks to varios

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

			OPTIONS:

			--alias=<name>

			--function=<name>

			--output-multiline
			    Output each comment block as a multiline string.

			--lang=<lang>
			    Defaults to bash

			--delim=<char>
			    When outputting multiple comments, end each block with delim.

			--map
			    Output the symbol name befor each comment, ie. [<symbol> <comment>]...

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # =======================================================
  # Args

  local option_args=() \
  option_name='' \
  option_alias='' \
  option_func='' \
  option_map='no' \
  option_debug='no'

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--function='*) option_alias="${item#*=}" ;;
    '--alias='*) option_func="${item#*=}" ;;
    '--map') option_map="yes" ;;
    '--debug') option_debug='yes';;
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # =======================================================
  # =======================================================
  # =======================================================
  #
  # TODO: print each comment block as a multiline string
  # This post explains the most stable way ending strings with null delim in awl
  # https://stackoverflow.com/questions/9133315/how-can-i-output-null-terminated-strings-in-awk
  # See awk-null-test

  # local CAPTURE_COMMENT_LINES_ACTION='{ comments = comments "\n" $0; next }'
  # local CAPTURE_COMMENT_MULTILINE_ACTION=' { comments = comments "\n" substr($0, 3); next }' # Collect comment lines, remove "# "
  local CAPTURE_COMMENT_MULTILINE_ACTION=' { comments = comments "\n" $0; next }' # Collect comment lines, remove "# "

  # local CAPTURE_COMMENT_LINES_PATTERN="$LANG_BASH_COMMENT_REGEX $CAPTURE_COMMENT_LINES_ACTION"
  local CAPTURE_COMMENT_LINES_PATTERN="$LANG_BASH_COMMENT_REGEX $CAPTURE_COMMENT_MULTILINE_ACTION"

  local EXTRACT_FUNCTION_NAME='
        func_name = $0;                                             # Extract function name
        sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part
        '

  local func_def_action="$LANG_BASH_FUNCTION_DEFINITIONS_REGEX"' {
        '"$EXTRACT_FUNCTION_NAME"'

        # print "---------------------------------";
        # print "Function: [" func_name "]";
        # print comments "\n";


        if (comments) {
            printf( "%s%c", comments, 0) # print string with custom delimiter
        } else {
            printf( "%s%c", "NO COMMENT", 0)
        }

        comments = "";                              # Reset comment block

    }
    { comments = "" }                       # Reset comments if a non-comment, non-function line is encountered
    '

  get_awk_string() {
    local awk_string='' # BEGIN { ORS = "\0" } ;'

    # notice that we add a whitespace at the end to avoid issues when adding to same line
    function add_line() {
      awk_string+=$'\n'"$1"' '
    }

    function add_same_line() {
      awk_string+="$1"
    }

    add_line "$CAPTURE_COMMENT_LINES_PATTERN"

    add_line "$func_def_action"

    # add_line "END"

    # awk "$awk_string" "$1"
    __print_lines "$awk_string"
  }

  if [[ "$option_debug" == 'yes' ]] ; then

    __print_lines "$(get_awk_string)"

  elif [[ -z "$option_alias" && -z "$option_func" ]]; then
    echo "before"
    # output all findings
    local comments=()

    # comments+=("$(extract_comments_for_all_functions "${option_args[0]}")")
    # mapfile -t comments < <(extract_comments_for_all_functions "${option_args[0]}")

    # IFS= read -ra comments < <(extract_comments_for_all_functions "${option_args[0]}")
    local str="$(get_awk_string)"

    mapfile -t -d '' comments < <(awk "$str" "${option_args[0]}")

    # while IFS= read -d '' -r input; do
    #   echo "[$input]"
    #   comments+=("$input")
    # done < <(extract_comments_for_all_functions "${option_args[0]}")
    echo "after"

    for com in "${comments[@]}"; do
      __print_lines "======================================================="
      __print_lines "$com"
    done

  else

    echo "else"

    if [[ -n "$option_alias" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    elif [[ -n "$option_func" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    fi

  fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
