#!/usr/bin/env bash

# TODO: print each comment block as a multiline string
# This post explains the most stable way ending strings with null delim in awl
# https://stackoverflow.com/questions/9133315/how-can-i-output-null-terminated-strings-in-awk
# See awk-null-test

# NOTE: Name suggestions
# echo-preceeding-comment-blocks

# TODO:
# - (x) add null delimiter
# - test with single names passed
# -- alias
# -- function
# - when func name is found, trim the last \n from the comments var
# - wrap output strings in single quotes, to create "multi line" output strings
#     for each comment block?

function echo_comment_blocks() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_FS_COMMENT_REGEX='/^#/'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH__FS_FUNC_DEF='/^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/'
  # local zsh
  # local fish
  # local nu

  # =======================================================
  # Help

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			Defaults to spitting out all findings.

			You can specify which type of definition name above which you want
			to extract the comment.

			This helper helps in capturing preceeding comment blocks to varios

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

			OPTIONS:

			--alias=<name>

			--function=<name>

			--output-multiline
			    Output each comment block as a multiline string.

			--lang=<lang>
			    Defaults to bash

			--delim=<char>
			    When outputting multiple comments, end each block with delim.

			--map
			    Output the symbol name befor each comment, ie. [<symbol> <comment>]...

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # =======================================================
  # Args

  local option_args=() \
  option_name='' \
  option_alias='' \
  option_func='' \
  option_map='no' \
  option_debug='no'

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--function='*) option_func="${item#*=}" ;;
    '--alias='*) option_alias="${item#*=}" ;;
    '--map') option_map="yes" ;;
    '--debug') option_debug='yes' ;;
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # =======================================================
  # build comments pattern-statement

  local CAPTURE_COMMENT_LINES_PATTERN_ACTION="$LANG_BASH_FS_COMMENT_REGEX"' { comments = comments "\n" $0; next };'

  # =======================================================
  # build function pattern-statement

  local LANG_BASH__CHUNK_EXTRACT_FUNC_NAME='
        func_name = $0;                                             # Extract function name
        sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part
        '

  local ACTION_COMMENTS_RESET='{ comments = ""};'

  # ---------------------------------
  # print all comment blocks above aliases

  # ---------------------------------
  # print all comment blocks above aliases by name [capture_alias]

  # ---------------------------------
  # print all func defs

  local ACTION_FUNC_DEFS_ALL="$LANG_BASH__FS_FUNC_DEF"' {
      '"$LANG_BASH__CHUNK_EXTRACT_FUNC_NAME"'
      if (comments) {
          printf( "%s%c", comments, 0)      # print string with custom delimiter
      } else {
          printf( "%s%c", "NO COMMENT", 0)
      }
      comments = "";                        # Reset comment block
  };'

  # ---------------------------------
  # print only comment block of func def in variable [capture_func]

  local ACTION_FUNC_DEF_BY_NAME="$LANG_BASH__FS_FUNC_DEF"' {
      '"$LANG_BASH__CHUNK_EXTRACT_FUNC_NAME"'
      if (comments && func_name == capture_func) {
          printf( "%s%c", comments, 0)
      };
      comments = "";                        # Reset comment block
  };'

  local awk_args=()
  local awk_string='' # BEGIN { ORS = "\0" } ;'

  function add_line() {
    awk_string+=$'\n'"$1"' '
  }

  if [[ -z "$option_alias" && -z "$option_func" ]]; then
    # all func comments
    add_line "$CAPTURE_COMMENT_LINES_PATTERN_ACTION"
    add_line "$ACTION_FUNC_DEFS_ALL"
  else
    if [[ -n "$option_func" ]]; then
      # only one func by name
      add_line "$CAPTURE_COMMENT_LINES_PATTERN_ACTION"
      add_line "$ACTION_FUNC_DEF_BY_NAME"
      awk_args+=(-v capture_func="$option_func")

    elif [[ -n "$option_alias" ]]; then
      add_line "$CAPTURE_COMMENT_LINES_PATTERN_ACTION"
      add_line "$ACTION_ALIAS_DEF_BY_NAME"
      awk_args+=(-v capture_func="$option_alias")
    fi
  fi
  add_line "$ACTION_COMMENTS_RESET"


  if [[ "$option_debug" == 'yes' ]]; then

    __print_lines "$(build_awk_string)"

  else
    local comments=()

    # split output on null delim
    mapfile -t -d '' comments < <(awk "${awk_args[@]}" "$awk_string" "${option_args[0]}")

    for com in "${comments[@]}"; do
      __print_lines "$com"
    done
  fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
