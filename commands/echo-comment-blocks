#!/usr/bin/env bash

# # --alias | --fn
# function get_comment_block_above() {
# 	# This is a sample script from ChatGPT.
#
# 	# # Function to greet someone
# 	# # Usage: greet <name>
# 	# greet() {
# 	# 	local name="$1"
# 	# 	echo "Hello, $name!"
# 	# }
#
# 	# Extract comment block above a function definition
# 	extract_comment() {
# 		local function_name="$1"
# 		awk -v func="$function_name" '
# 	  /^#/ { comments = comments "\n" $0; next }
# 	  $0 ~ "^" func "\\(" { print comments; exit }
# 	  { comments = "" }
# 	  ' "$0"
# 	}
#
# 	# Example usage:
# 	comment_block=$(extract_comment "greet")
# 	echo "$comment_block"
# }

# NOTE: Name suggestions
# echo-preceeding-comment-blocks

function echo_comment_blocks() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_COMMENT_REGEX='/^#/'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_FUNCTION_DEFINITIONS_REGEX='/^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/'
  # local zsh
  # local fish
  # local nu

  # =======================================================
  # Help

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			Defaults to spitting out all findings.

			You can specify which type of definition name above which you want
			to extract the comment.

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

			OPTIONS:

			--alias=<name>

			--function=<name>

			--output-multiline
			    Output each comment block as a multiline string.

			--lang=<lang>
			    Defaults to bash

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # =======================================================
  # Args

  local option_args=() option_name='' option_alias='' option_func=''

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--function='*) option_alias="${item#*=}" ;;
    '--alias='*) option_func="${item#*=}" ;;
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # =======================================================
  # =======================================================
  # =======================================================
  #
  # TODO: print each comment block as a multiline string
  # This post explains the most stable way ending strings with null delim in awl
  # https://stackoverflow.com/questions/9133315/how-can-i-output-null-terminated-strings-in-awk
  # See awk-null-test

  # local CAPTURE_COMMENT_LINES_ACTION='{ comments = comments "\n" $0; next }'
  # local CAPTURE_COMMENT_MULTILINE_ACTION=' { comments = comments "\n" substr($0, 3); next }' # Collect comment lines, remove "# "
  local CAPTURE_COMMENT_MULTILINE_ACTION=' { comments = comments "\n" $0; next }' # Collect comment lines, remove "# "

  # local capture_comment_lines_pattern="$LANG_BASH_COMMENT_REGEX $CAPTURE_COMMENT_LINES_ACTION"
  local capture_comment_lines_pattern="$LANG_BASH_COMMENT_REGEX $CAPTURE_COMMENT_MULTILINE_ACTION"

  local func_def_action="$LANG_BASH_FUNCTION_DEFINITIONS_REGEX"' {
        func_name = $0;                                             # Extract function name
        sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part

        # print "---------------------------------";
        # print "Function: [" func_name "]";
        # print comments "\n";

        # OFS="\0" # will use null as the field separator when printing

        if (comments) {
            print "============================================"
            print comments "\n";
            # print $0
            # printf "\0"

            # print "$'\''\0'\''"

            # print "" comments "\"\0";  # Print as a single multiline string

            # print  comments "\n$'\''\0" ;# "\n"

        } else {
            print "NO COMMENT\n";
        }

        comments = "";                              # Reset comment block

    }
    { comments = "" }                       # Reset comments if a non-comment, non-function line is encountered
    '

  extract_comments_for_all_functions() {
    local awk_string='BEGIN { ORS = "\0" } ;'

    # notice that we add a whitespace at the end to avoid issues when adding to same line
    function add_line() {
      awk_string+=$'\n'"$1"' '
    }

    function add_same_line() {
      awk_string+="$1"
    }

    add_line "$capture_comment_lines_pattern"

    add_line "$func_def_action"

    # add_line "END"

    awk "$awk_string" "$1"
  }

  if [[ -z "$option_alias" && -z "$option_func" ]]; then
    echo "before"
    # output all findings
    local comments=()

    # comments+=("$(extract_comments_for_all_functions "${option_args[0]}")")
    # mapfile -t comments < <(extract_comments_for_all_functions "${option_args[0]}")

    # IFS= read -ra comments < <(extract_comments_for_all_functions "${option_args[0]}")

    mapfile -t -d '' comments < <(extract_comments_for_all_functions "${option_args[0]}")

    # while IFS= read -d '' -r input; do
    #   echo "[$input]"
    #   comments+=("$input")
    # done < <(extract_comments_for_all_functions "${option_args[0]}")

    echo "after"

    for com in "${comments[@]}"; do
      __print_lines ">>>>"
      __print_lines "$com"
      __print_lines "<<<<"
    done

  else

    echo "else"

    if [[ -n "$option_alias" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    elif [[ -n "$option_func" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    fi

  fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
