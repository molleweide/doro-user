#!/usr/bin/env bash

# # --alias | --fn
# function get_comment_block_above() {
# 	# This is a sample script from ChatGPT.
#
# 	# # Function to greet someone
# 	# # Usage: greet <name>
# 	# greet() {
# 	# 	local name="$1"
# 	# 	echo "Hello, $name!"
# 	# }
#
# 	# Extract comment block above a function definition
# 	extract_comment() {
# 		local function_name="$1"
# 		awk -v func="$function_name" '
# 	  /^#/ { comments = comments "\n" $0; next }
# 	  $0 ~ "^" func "\\(" { print comments; exit }
# 	  { comments = "" }
# 	  ' "$0"
# 	}
#
# 	# Example usage:
# 	comment_block=$(extract_comment "greet")
# 	echo "$comment_block"
# }

function echo_comment_blocks() (

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  local option_args=()

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # # Example usage
  # # extract_comments_for_all_functions "your_script.sh"
  # # TODO: match the three types of func defs
  # # - <name>() {
  # # - function <name>() {
  # # - function <name> {
  # function extract_comments_for_all_functions() {
  #   awk '
  #    /^#/ { comments = comments "\n" $0; next }  # Collect comment lines
  #    /^[a-zA-Z_][a-zA-Z0-9_]*\(\) *{/ {          # Match function definitions
  #        func_name = $1;                         # Capture function name
  #        sub(/\(\)$/, "", func_name);            # Remove () from name
  #        print "Function: " func_name;           # Print function name
  #        print comments "\n";                    # Print associated comment block
  #        comments = "";                          # Reset comments
  #    }
  #    { comments = "" }  # Reset comments if a non-comment, non-function line is encountered
  #    ' "$1"
  # }


  # TODO: split this up into smaller variables and name them appropriately
  # so that I learn how awk work.
  # And can modify this to work with other shells than bash.

  extract_comments_for_all_functions() {
    awk '
    /^#/ { comments = comments "\n" $0; next }  # Collect comment lines
    /^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/ {
        # Extract function name
        func_name = $0;
        sub(/^function[ \t]+/, "", func_name);  # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);  # Remove () and { part
        print "Function: " func_name;
        print comments "\n";
        comments = "";  # Reset comment block
    }
    { comments = "" }  # Reset comments if a non-comment, non-function line is encountered
    ' "$1"
  }

  extract_comments_for_all_functions "${option_args[0]}"
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
