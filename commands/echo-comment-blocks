#!/usr/bin/env bash

# TODO: print each comment block as a multiline string
# This post explains the most stable way ending strings with null delim in awl
# https://stackoverflow.com/questions/9133315/how-can-i-output-null-terminated-strings-in-awk
# See awk-null-test

# NOTE: Name suggestions
# echo-preceeding-comment-blocks

# TODO:
# - (x) add null delimiter
# - test with single names passed
# -- alias
# -- function
# - when func name is found, trim the last \n from the comments var
# - wrap output strings in single quotes, to create "multi line" output strings
#     for each comment block?

function echo_comment_blocks() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH_FS_COMMENT_REGEX='/^#/'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local LANG_BASH__FS_FUNC_DEF='/^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/'
  # local zsh
  # local fish
  # local nu

  # =======================================================
  # Help

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			Defaults to spitting out all findings.

			You can specify which type of definition name above which you want
			to extract the comment.

			This helper helps in capturing preceeding comment blocks to varios

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

			OPTIONS:

			--alias=<name>

			--function=<name>

			--output-multiline
			    Output each comment block as a multiline string.

			--lang=<lang>
			    Defaults to bash

			--delim=<char>
			    When outputting multiple comments, end each block with delim.

			--map
			    Output the symbol name befor each comment, ie. [<symbol> <comment>]...

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # =======================================================
  # Args

  local option_args=() \
  option_name='' \
  option_alias='' \
  option_func='' \
  option_map='no' \
  option_debug='no'

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--function='*) option_func="${item#*=}" ;;
    '--alias='*) option_alias="${item#*=}" ;;
    '--map') option_map="yes" ;;
    '--debug') option_debug='yes' ;;
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # =======================================================
  # build comments pattern-statement

  local CAPTURE_COMMENT_LINES_PATTERN_ACTION="$LANG_BASH_FS_COMMENT_REGEX"' { comments = comments "\n" $0; next };'

  # =======================================================
  # build function pattern-statement

  local EXTRACT_FUNCTION_NAME='
        func_name = $0;                                             # Extract function name
        sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part
        '

  local ACTION_COMMENTS_RESET='{ comments = ""};'

  # ---------------------------------
  # print all comment blocks above aliases

  # ---------------------------------
  # print all comment blocks above aliases by name [capture_alias]

  # ---------------------------------
  # print all func defs

  local ACTION_FUNC_DEFS_ALL="$LANG_BASH__FS_FUNC_DEF"' {
      '"$EXTRACT_FUNCTION_NAME"'
      if (comments) {
          printf( "%s%c", comments, 0)      # print string with custom delimiter
      } else {
          printf( "%s%c", "NO COMMENT", 0)
      }
      comments = "";                        # Reset comment block
  };'"$ACTION_COMMENTS_RESET"

  # ---------------------------------
  # print only comment block of func def in variable [capture_func]

  local ACTION_FUNC_DEF_BY_NAME="$LANG_BASH__FS_FUNC_DEF"' {
      '"$EXTRACT_FUNCTION_NAME"'
      if (comments && func_name == capture_func) {
          print "(comments &&)"
          printf( "%s%c", comments, 0)
      };
      comments = "";                        # Reset comment block
  };'"$ACTION_COMMENTS_RESET"




  build_awk_string() {
    local awk_string='' # BEGIN { ORS = "\0" } ;'

    # notice that we add a whitespace at the end to avoid issues when adding to same line
    function add_line() {
      awk_string+=$'\n'"$1"' '
    }

    function add_same_line() {
      awk_string+="$1"
    }

    function add_wrap() {
      awk_string+="$1"
    }

    # initial capture comments
    add_line "$CAPTURE_COMMENT_LINES_PATTERN_ACTION"

    add_line "$ACTION_FUNC_DEFS_ALL"

    __print_lines "$awk_string"
  }

  if [[ "$option_debug" == 'yes' ]]; then

    __print_lines "$(build_awk_string)"

  elif [[ -z "$option_alias" && -z "$option_func" ]]; then
    local comments=()

    # split output on null delim
    mapfile -t -d '' comments < <(awk -v capture_func=freem "$(build_awk_string)" "${option_args[0]}")

    for com in "${comments[@]}"; do
      __print_lines "======================================================="
      __print_lines "$com"
    done

  else

    echo "else"

    if [[ -n "$option_alias" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    elif [[ -n "$option_func" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    fi

  fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
