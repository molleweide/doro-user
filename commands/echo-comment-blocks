#!/usr/bin/env bash

# # --alias | --fn
# function get_comment_block_above() {
# 	# This is a sample script from ChatGPT.
#
# 	# # Function to greet someone
# 	# # Usage: greet <name>
# 	# greet() {
# 	# 	local name="$1"
# 	# 	echo "Hello, $name!"
# 	# }
#
# 	# Extract comment block above a function definition
# 	extract_comment() {
# 		local function_name="$1"
# 		awk -v func="$function_name" '
# 	  /^#/ { comments = comments "\n" $0; next }
# 	  $0 ~ "^" func "\\(" { print comments; exit }
# 	  { comments = "" }
# 	  ' "$0"
# 	}
#
# 	# Example usage:
# 	comment_block=$(extract_comment "greet")
# 	echo "$comment_block"
# }

# NOTE: Name suggestions
# echo-preceeding-comment-blocks

function echo_comment_blocks() (

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:

			Input file or stdin and parse out comment blocks above a function.

			Defaults to spitting out all findings.

			You can specify which type of definition name above which you want
			to extract the comment.

			USAGE:
			echo-bash-comment-blocks -- <file>
			echo-bash-comment-blocks --func-name=<name> -- <file>

			OPTIONS:

			--alias=<name>

			--function=<name>

			--output-multiline
			    Output each comment block as a multiline string.

		EOF
    if [[ $# -ne 0 ]]; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  local option_args=() option_name='' option_alias='' option_func=''

  while [[ $# -ne 0 ]]; do
    item="$1"
    shift
    case "$item" in
    '--function='*) option_alias="${item#*=}" ;;
    '--alias='*) option_func="${item#*=}" ;;
    '--')
      option_args+=("$@")
      shift $#
      break
      ;;
    *)
      help "Unknown argument was provided"
      ;;
    esac
  done

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local BASH_COMMENT_REGEX='/^#/'

  # =======================================================
  # FUNCTION DEFINITIONS BY LANG
  # =======================================================

  local BASH_FUNCTION_DEFINITIONS_REGEX='/^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/'
  # local zsh
  # local fish
  # local nu

  # =======================================================
  # =======================================================
  # =======================================================
  #
  # TODO: print each comment block as a multiline string

  local CAPTURE_COMMENT_LINES_ACTION='{ comments = comments "\n" $0; next }'
  local CAPTURE_COMMENT_MULTILINE_ACTION=' { comments = comments "\n" substr($0, 3); next }' # Collect comment lines, remove "# "

  # local capture_comment_lines_pattern="$BASH_COMMENT_REGEX $CAPTURE_COMMENT_LINES_ACTION"
  local capture_comment_lines_pattern="$BASH_COMMENT_REGEX $CAPTURE_COMMENT_MULTILINE_ACTION"

  local func_def_action="$BASH_FUNCTION_DEFINITIONS_REGEX"' {
        func_name = $0;                                             # Extract function name
        sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
        sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part

        print "---------------------------------";
        print "Function: [" func_name "]";

        # print comments "\n";
        if (comments) {
            print comments "\n";
        } else {
            print "NO COMMENT\n";
        }

        comments = "";                              # Reset comment block

    }
    { comments = "" }                       # Reset comments if a non-comment, non-function line is encountered
    '

  extract_comments_for_all_functions() {
    local awk_string=''

    # notice that we add a whitespace at the end to avoid issues when adding to same line
    function add_line() {
      awk_string+=$'\n'"$1"' '
    }

    function add_same_line() {
      awk_string+="$1"
    }

    add_line "$capture_comment_lines_pattern"

    add_line "$func_def_action"

    # rest='
    # /^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/ {
    #     func_name = $0;                                             # Extract function name
    #
    #     sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
    #
    #     sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part
    #
    #     print "---------------------------------";
    #     print "Function: [" func_name "]";
    #
    #     # print comments "\n";
    #     if (comments) {
    #         print comments "\n";
    #     } else {
    #         print "NO COMMENT\n";
    #     }
    #
    #     comments = "";                              # Reset comment block
    #
    # }
    # { comments = "" }                       # Reset comments if a non-comment, non-function line is encountered
    # '

    # awk_string+="$rest"

    # awk '
    #
    # /^#/ { comments = comments "\n" $0; next }                      # Collect comment lines
    #
    # /^(function[ \t]+)?[a-zA-Z_][a-zA-Z0-9_]*[ \t]*\(\)?[ \t]*{/ {
    #     func_name = $0;                                             # Extract function name
    #
    #     sub(/^function[ \t]+/, "", func_name);                      # Remove "function" keyword if present
    #
    #     sub(/[ \t]*\(\)?[ \t]*\{.*/, "", func_name);                # Remove () and { part
    #
    #     print "Function: [" func_name "]";
    #
    #     print comments "\n";
    #
    #     comments = "";                              # Reset comment block
    #
    # }
    # { comments = "" }                       # Reset comments if a non-comment, non-function line is encountered
    # ' "$1"

    awk "$awk_string" "$1"
  }

  if [[ -z "$option_alias" && -z "$option_func" ]]; then
    # output all findings
    extract_comments_for_all_functions "${option_args[0]}"

  else

    if [[ -n "$option_alias" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    elif [[ -n "$option_func" ]]; then
      extract_comments_for_all_functions "${option_args[0]}"
    fi

  fi
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
  if [[ $* == '--test' ]]; then
    echo_comment_blocks_test
  else
    echo_comment_blocks "$@"
  fi
fi
