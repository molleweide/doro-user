#!/usr/bin/env bash

#
# DOROTHY COMMAND ALIAS (DCA) HELPER
#

# WARN: Only handle name collisions for the parser. DO NOT GO OVER BOARD!!!

# TODO: ( ) split validation and creation ??
#           try_create_alias_files should be split up again into two.
#           So that we can dry run it and collect failure info.
# TODO: ( ) use NEW_ALIAS_SUB_DIR and concatenate paths in try_create_alias_files
# TODO: (*) PARSER: handle failures in interactive loop.
# TODO: ( ) Use fabric
# TODO: ( ) Analyze existing DCAs and check which could be improved with `exec`

# FIX: ( ) Apply correct return/exit statuses wherever something returns
#
# MOVE TO CORE
# - ( ) aliases
# - ( ) get-interpreter
# - ( ) command-aliases
# - ( ) is-valid-path

# NOTE: Whenever running some such as nvim or ranger, then do
# `exec ...` so that the command takes over the process, and prevent
# superfluous shell processes from spawning.
# >>> test how this will work

# TEST: how functions turned into aliases will work in context of eg.
# handling tmux stuff etc.

# TODO_: (overkill maybe)
# - Capture the args and rename them to better names and inject this as a line
#   before the function contents. And also rename the args in the function bodies.

function command_aliases_test() (
	# Test that aliases are migrated and parsed correctly. Handle:
	# - surrounding comments properly.
	# - collect arguments order and naming?
	# - ensure uniqueness
	:
)

function command_aliases() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# short DCA = dorothy command aliases
	# migrate aliases to dorothy

	local USER_COMMAND_ALIASES_DIR="$DOROTHY/user/commands.aliases"
	local SHEBANG_BASH="#!/usr/bin/env bash"
	local BAT_CMD=(bat --style numbers --color always --language bash --paging=never)

	local ALLOW_MAX_SUB_DIRS=2

	# these are added in the try_create_alias_files so that subsequent aliases
	# will always be able to check against the totality of all aliases when
	# checking for uniqueness
	local ALL_EXISTING_ALIAS_PATHS=() # currently unused
	local ALL_EXISTING_ALIAS_BASENAMES=()

	# Use indices to get these back
	local NEW_ALIAS_NAMES=()
	local NEW_ALIAS_SUB_DIR=() # these would only be used for fixing/editing after parsing
	local NEW_ALIAS_VALUES=()
	local NEW_ALIAS_DESCS=()
	local NEW_ALIAS_ARGS=()
	local NEW_ALIAS_PATHS=()
	local NEW_ALIAS_CONTENTS=()

	# most of this could be reduced if we just keep track of all the indices
	# that failed, and then remove the indices from the array. and only create
	# aliases as long as the failed indices #array == 0.
	local FAILING_ALIAS_NAMES=()
	local FAILING_ALIAS_SUB_DIR=()
	local FAILING_ALIAS_VALUES=()
	local FAILING_ALIAS_DESCS=()
	local FAILING_ALIAS_ARGS=()
	local FAILING_ALIAS_PATHS=()
	local FAILING_ALIAS_CONTENTS=()

	local FAILING_ALIAS_KEY=() # Use so we can more easilly check which part failed.
	local FAILING_ALIAS_REASON=()
	local FAILING_ALIAS_PARTS_REDO_FUNCS=() # Only used in `act_create`

	local GO_LIVE='yes'

	local supported=(
		sh
		bash
		zsh
		fish
	)
	local supported_posix=(
		sh
		bash
		zsh
		fish
	)
	local supported_non_posix=(
		nu
		elvish
		xonsh
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [...<options] [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			    DCAs under "user/commands.aliases/*". Migrate can take multiple files
			    at once.

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

			OPTIONS:

			--to=<path>
			    If you are migrating a aliases of a specific type, eg. git aliases,
			    then you can specify path == "git/log", and then aliases will be
			    migrated into [commands.aliases/git/log*], so that all your logging
			    aliases are nicely put in a semantic location.

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# local option_args=()
	local option_action='' option_migrate_to_subdir='' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--to='*) option_migrate_to_subdir="${item#*=}" ;;
		'browse') option_action="browse" ;;
		'new' | 'create') option_action="create" ;;
		'migrate') option_action="migrate" ;;
			# '--')
			#   # 	option_args+=("$item" "$@")
			#   break
			#   ;;
			#   # *) option_args+=("$item") ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		*)
			help "Unknown argument was provided"
			;;
		esac
	done

	# =======================================================
	# HELPER

	function log_contents() {
		bat --style numbers --color always --language bash --paging=never <<<"$1"
	}

	function reset_failure_arrays() {
		FAILING_ALIAS_NAMES=()
		FAILING_ALIAS_PATHS=()
		FAILING_ALIAS_CONTENTS=()
		FAILING_ALIAS_REASON=()
	}

	function short_name_from_path() {
		# ${path#*"commands.aliases"} does not work for trimming everything before
		# the match pattern. That is why the string looks a bit weird below.
		echo "commands${1#*"commands"}"
	}

	# Ensure the path contains only valid characters
	# ( ) make standalone w/[--subpath --absolute --relative]
	function is_valid_path() {
		local input=$1
		local initial_slash="/?"
		local trailing_slash="/?"
		local special_chars_last="._-"
		# local char_classes="A-Za-z0-9"
		local char_classes="[:alpha:][:digit:]"
		local valid_chars="([$char_classes/]+)"
		local start='^'
		local end='$'
		# local regex='^(/)?([^/\0]+(/)?)+$'
		# local regex='^/?([A-Za-z0-9._-]+/?)*$'
		local regex="$start$valid_chars$end"
		if [[ ! "$input" =~ $regex ]]; then
			# echo "invalid path" >/dev/tty
			return 1
		# else
		# 	echo "valid path" >/dev/tty
		fi
	}

	function is_valid_subdir_depth() {
		local check_str="$1" parts=()
		IFS='/' read -ra parts <<<"$check_str"
		if [[ "${#parts[@]}" -gt $ALLOW_MAX_SUB_DIRS ]]; then
			return 1
		fi
	}

	# get paths of existing aliases
	function get_all_command_aliases() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		find "$USER_COMMAND_ALIASES_DIR" -type f | grep -Ev "$regex_rm_paths_with_files_extension"
	}

	function collect_existing_alias_info() {
		ALL_EXISTING_ALIAS_BASENAMES=()
		ALL_EXISTING_ALIAS_PATHS=()
		while read -r line; do
			ALL_EXISTING_ALIAS_PATHS+=("$line")
			ALL_EXISTING_ALIAS_BASENAMES+=("$(basename "$line")")
		done < <(echo-lines -- "$(get_all_command_aliases)" | echo-trim-empty-lines --stdin)
	}

	function add_command_aliases_dirs_to_path() {
		local path='' alias_dirs=()
		mapfile -t alias_dirs < <(find "$USER_COMMAND_ALIASES_DIR" -type d)
		# __print_lines "${alias_dirs[@]}"
		local path=''
		for p in "${alias_dirs[@]}"; do
			path+="$p:"
		done
		echo "$path$PATH"
		# export PATH
	}

	function make_destination() {
		if [[ -n "$option_migrate_to_subdir" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$option_migrate_to_subdir"
		elif [[ -n "${1-}" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$1"
		else
			echo "$USER_COMMAND_ALIASES_DIR"
		fi

	}

	# if no args, then correct permissions for all alias paths
	# else, correct permissions for input <path>s
	function correct_permissions() {
		return
		if [[ $# -eq 0 ]]; then
			local alias_paths=()
			mapfile -t alias_paths < <(get_all_command_aliases)
			fs-own --x -- "${alias_paths[@]}"
		else
			fs-own --x -- "$@" # correct permissions for inpus only
		fi
	}

	function is_unique_alias() {
		local alias=$1

		# TODO: Remove `is-needle`, only use `which`

		if is-needle "$alias" -- "${ALL_EXISTING_ALIAS_BASENAMES[@]}" && ! which "$alias"; then
			return 1
		fi
		#
		#     >> [is-needle --all ...] can be used to process multiple needles.
		#     >>>>>>> use this when migrating files
		#       if is-needle --all "$@" -- "${ALL_EXISTING_ALIAS_BASENAMES[@]}"; then
		#       	return 1
		#       fi
		#     >>> but this is not good because it makes all aliases fail
	}

	function try_create_alias_file() {
		local content=$1 path=$2 status=0
		__mkdirp "$(dirname "$path")"
		echo "$content" >"$path" || status=$?
		return "$status"
	}

	function create_alias_files() {
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			# TODO: fix var names here.
			local content=$1 path=$2 status=0
			__mkdirp "$(dirname "$path")"
			echo "${NEW_ALIAS_CONTENTS[i]}" >"${NEW_ALIAS_PATHS[i]}" || status=$?
			# return "$status"
		done

		# # bulk correct permissions
		# # do we have to capture failers with permission as well?
		# if [[ "${#successful_paths[@]}" -gt 0 ]]; then
		#   correct_permissions "${successful_paths[@]}"
		# fi

	}

	# TODO: Rename to "validate_and_capture_failures"

	function try_create_alias_files() {
		local dry_run='yes' arg=${1-}

		# if [[ "$arg" == "create" ]] ; then
		#   dry_run
		# fi

		# SINGLE
		#   create
		#   fix perms
		#     return status
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			local failure='no' reason='' successful_paths=()
			local name="${NEW_ALIAS_NAMES[i]}"
			local path="${NEW_ALIAS_PATHS[i]}"
			local content="${NEW_ALIAS_CONTENTS[i]}"
			local failure_part_redo_func=''

			if ! is_unique_alias "$name"; then
				failure='yes'
				failure_part_redo_func='edit_name'
				reason="Alias with name [$name] already exists"
				echo-style --error "$reason"
			elif ! try_create_alias_file "$content" "$path"; then
				failure='yes'
				failure_part_redo_func='none'
				reason="Failure creating alias [$(short_name_from_path "$path")]!"
				successful_paths+=("$path")
				echo-style --error "$reason"
			else
				echo-style --success "Successfully created alias [$(short_name_from_path "$path")]"
				# add to existing here so the unique checks will work correctly in the
				# act_create loop for multiple creation loops.
				ALL_EXISTING_ALIAS_BASENAMES+=("$name")
				ALL_EXISTING_ALIAS_PATHS+=("$path")
			fi

			# echo "new args: [${NEW_ALIAS_ARGS[i]}] ???"

			if [[ "$failure" == 'yes' ]]; then
				FAILING_ALIAS_NAMES+=("$name")
				FAILING_ALIAS_VALUES+=("${NEW_ALIAS_VALUES[i]}")
				FAILING_ALIAS_DESCS+=("${NEW_ALIAS_DESCS[i]}")
				FAILING_ALIAS_ARGS+=("${NEW_ALIAS_ARGS[i]}")
				FAILING_ALIAS_PATHS+=("$path")
				FAILING_ALIAS_CONTENTS+=("$content")
				FAILING_ALIAS_REASON+=("$reason")
				FAILING_ALIAS_PARTS_REDO_FUNCS+=("$failure_part_redo_func")
			fi
		done

		# bulk correct permissions
		# do we have to capture failers with permission as well?
		if [[ "${#successful_paths[@]}" -gt 0 ]]; then
			correct_permissions "${successful_paths[@]}"
		fi

		local complete_failure='yes'
		if [[ "${#successful_paths[@]}" == "${#NEW_ALIAS_NAMES[@]}" ]]; then
			complete_failure='no'
		fi

		# 1 complete failure
		# 2 partial failure. some paths succeeded
		if [[ "$failure" == 'no' ]]; then
			return 0
		else
			if [[ "$complete_failure" == 'yes' ]]; then
				return 1
			else
				return 2
			fi
		fi

	}

	# =======================================================
	# ACTIONS

	# ( ) choose
	# ( ) fuzzy-helper
	# BINDINGS
	#   ( ) create new DCA from selection.
	function act_browse() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		local alias_paths=()
		local alias_names=()
		local alias_labels=()

		# -maxdepth 1
		mapfile -t alias_paths < <(get_all_command_aliases)
		for path in "${alias_paths[@]}"; do
			local header contents
			# ${path#*"commands.aliases"} does not work for trimming everything before
			# the match pattern. That is why the string looks a bit weird below.
			header="commands${path#*"commands"}"
			contents="$("${BAT_CMD[@]}" "$path")"
			alias_names+=("$header")
			alias_labels+=("$header"$'\n'"$contents")
		done

		__print_lines "${alias_labels[@]}"

		local index=0 choose_title="Aliases | Browser"
		while :; do
			index="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${alias_labels[@]}")"
			if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${alias_labels[index]}"$'\n'"Prompt again?"; then
				break
			fi
		done

	}

	# Use `dorothy-new` command here later when it is finished.
	# ( ) check if name already exists. confirm...
	# ( ) if you specify a path then create sub dirs under (*)
	function act_create() {
		reset_failure_arrays
		local new_alias_name='' new_alias_path='' value=''desc='' sub_path='' confirm_proceed_and_create='' new_alias_content=''

		new_alias_name="$(ask --linger 'Aliases create | What will the NAME be?')"
		value="$(ask --linger 'Aliases create | What will the VALUE be?')"
		desc="$(ask --linger 'Aliases create | What will the DESC be?')"

		# handle sub dir group
		if confirm --ppid=$$ --negative -- 'Aliases create | Put it in sub path, eg. [commands.aliases/<my>/<dir>]?'; then
			sub_path="$(ask --linger 'Aliases create | What will the SUB PATH be?')"
			while :; do
				# path valid
				if ! is_valid_path "$sub_path"; then
					echo "Enter invalid"
					sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
					# path maxth depth
				elif ! is_valid_subdir_depth "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
					# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
					# # this is handled by the redo choose menu
					# 	sub_path="$(ask --linger "Input subpath again:")"
				else
					break
				fi
			done
		fi

		# TODO: fix these and call after the re-edit choose menu upon request.
		function edit_name() {
			new_alias_name="$(ask --linger 'Edit new alias name:')"
			build_alias_content
		}
		function edit_value() {
			value="$(ask --linger 'Edit new alias value:')"
			build_alias_content
		}
		function edit_desc() {
			desc="$(ask --linger 'Edit new alias description:')"
			build_alias_content
		}
		function edit_sub_path() {
			while :; do
				sub_path="$(ask --linger 'Edit sub path:')"
				# path valid
				if ! is_valid_path "$sub_path"; then
					echo "Enter invalid"
					sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
					# path maxth depth
				elif ! is_valid_subdir_depth "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
					# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
					# # this is handled by the redo choose menu
					# 	sub_path="$(ask --linger "Input subpath again:")"
				else
					break
				fi
			done
			build_alias_content
		}

		function set_NEW_ALIAS_arrays_to_new_single() {
			NEW_ALIAS_NAMES=()
			NEW_ALIAS_PATHS=()
			NEW_ALIAS_CONTENTS=()
			NEW_ALIAS_VALUES=()
			NEW_ALIAS_DESCS=()
			NEW_ALIAS_ARGS=()

			NEW_ALIAS_NAMES+=("$new_alias_name")
			NEW_ALIAS_PATHS+=("$new_alias_path")
			NEW_ALIAS_CONTENTS+=("$new_alias_content")
			NEW_ALIAS_VALUES+=("")
			NEW_ALIAS_DESCS+=("")
			NEW_ALIAS_ARGS+=("")
		}
		function build_alias_content() {
			# compile data
			new_alias_content=''
			new_alias_path="$(make_destination "$sub_path")/$new_alias_name"
			new_alias_content+="$SHEBANG_BASH"
			new_alias_content+=$'\n'"# Name: $new_alias_name"
			new_alias_content+=$'\n'"# Desc: $desc"
			new_alias_content+=$'\n'"$value"
			new_alias_content+=' "$@"'
		}
		build_alias_content

		# confirm current state of alias
		while :; do
			confirm_proceed_and_create="Go ahead create alias at [$(short_name_from_path "$new_alias_path")] OR edit alias?"$'\n'
			confirm_proceed_and_create+="$(bat --style numbers --color always --language bash --paging=never <<<"$new_alias_content")"

			if ! confirm --ppid=$$ --positive -- "$confirm_proceed_and_create"; then
				local sel redo_options=() title="Select which part to edit:"
				echo-style --bold "Redo !!!"
				redo_options+=(edit_name "Name ($new_alias_name)")
				redo_options+=(edit_value "Value ($value)")
				redo_options+=(edit_sub_path "Sub group name ($sub_path)")
				redo_options+=(edit_desc "Description ($desc)")

				sel="$(choose "$title" --label -- "${redo_options[@]}")"
				"$sel"

				# if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${alias_labels[index]}"$'\n'"Prompt again?"; then
				# 	break
				# fi
			else
				break
			fi

		done

		set_NEW_ALIAS_arrays_to_new_single
		# if confirm --ppid=$$ --positive -- "$confirm_proceed_and_create"; then

		while :; do

			# NOTE: I need to check the err tests to understand why this exists
			# without eval_capture

			# TODO: call the final validator func here instead.
			local status
			eval_capture --statusvar=status -- try_create_alias_files

			if [[ "$status" -ne 0 ]]; then
				local label

				# TODO: change to "The alias name already exists. Do you want to re-edit the failing part?"

				label="[$status] Creating alias [$(short_name_from_path "$new_alias_path")] failed with reason:"
				label+=$'\n'"REASON: ${FAILING_ALIAS_REASON[0]}"
				label+=$'\n'"Do you want to re-edit failing part?"

				if confirm --ppid=$$ --positive -- "$label"; then

					local failure_redo_func="${FAILING_ALIAS_PARTS_REDO_FUNCS[0]}"

					# If failure func does not exist. Should never be an issue really..
					if [[ -n "$failure_redo_func" && "$failure_redo_func" == "none" ]]; then
						echo-style --error "CREATE | Could not create alias [$(short_name_from_path "$new_alias_path")]. No re-edit func exists for failure. (todo: ignore/discard?)"
					fi

					"$failure_redo_func"
					reset_failure_arrays
					set_NEW_ALIAS_arrays_to_new_single

				fi
			else
				# TODO: Move the actual creation down to here, and break out for next alias. <<<
				break
			fi
		done

		if confirm --ppid=$$ --positive -- "Add nother alias?"; then
			act_create
		fi
	}

	function act_migrate() {
		local destination_sub_dir

		if [[ -n "$option_migrate_to_subdir" ]] && ! is_valid_path "$option_migrate_to_subdir"; then
			echo-style --error "Supplied invalid sub path: [$option_migrate_to_subdir]"
			exit 1
		fi

		destination_sub_dir="$(make_destination)"

		function migrate_single_file() {
			local input_file=$1

			local output_test_string=''
			local output_name_body_mapping=()

			local interpreter=''

			interpreter="$(get-interpreter --name -- "$input_file")"
			if is-needle "$interpreter" -- "${supported[@]}"; then

				# =======================================================
				# HANDLE POSIX
				# =======================================================

				function parse_new_alias_from_posix_alias() {
					:
				}

				function parse_new_alias_from_posix_function() {
					:
				}

				if is-needle "$interpreter" -- "${supported_posix[@]}"; then
					local aliases=() function_names=() function_bodies=()

					# ----
					# HANDLE POSIX ALIASES

					output_test_string+=$'\n###############################'
					output_test_string+=$'\n# ALIASES'
					output_test_string+=$'\n###############################'

					local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
					mapfile -t aliases < <(grep -E "$alias_regex" "$input_file" | echo-trim-each-line)
					for line_alias in "${aliases[@]}"; do
						local new_alias_name='' new_alias_desc='' value='' trailing_comment='' new_alias_path new_alias_content=''
						# handle trim trailing comment
						if [[ "$line_alias" =~ ^([^\#]*)\s*#\s*(.*) ]]; then
							line_alias="${BASH_REMATCH[1]}"
							new_alias_desc="${BASH_REMATCH[2]}"
						fi
						# handle split alias
						if [[ "$line_alias" =~ alias\ ([^=]+)=\"(.*)\" ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						elif [[ "$line_alias" =~ alias\ ([^=]+)=\'(.*)\' ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						fi

						# echo "$new_alias_name | $value"

						output_name_body_mapping+=("$new_alias_name")
						new_alias_content+="$SHEBANG_BASH"
						new_alias_content+=$'\n'"# Name: $new_alias_name"
						new_alias_content+=$'\n'"# Desc: $new_alias_desc"
						new_alias_content+=$'\n'"$value "'"$@"'
						output_name_body_mapping+=("$new_alias_content")

						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_VALUES+=("$value")
						NEW_ALIAS_DESCS+=("$new_alias_desc")
						NEW_ALIAS_ARGS+=("")
						NEW_ALIAS_PATHS+=("$destination_sub_dir/$new_alias_name")
						NEW_ALIAS_CONTENTS+=("$new_alias_content")
					done

					# ----
					# HANDLE POSIX FUNCTIONS

					output_test_string+=$'\n###############################'
					output_test_string+=$'\n# FUNCTIONS'
					output_test_string+=$'\n###############################'
					mapfile -t function_names < <(bash -c 'source '"$input_file"'; declare -F | awk "{print \$3}"')
					for new_alias_name in "${function_names[@]}"; do
						local final='' descriptiven='' body body_trimmed new_alias_name new_alias_path new_alias_content
						body="$(bash -c 'source '"$input_file"'; declare -f '"$new_alias_name")"
						body_trimmed="$(__print_lines "$body" | sed '1,2d; $d' | sed 's/^    //')"
						# Capture how many arguments each func snippets takes
						# This is not perfect but at least it gives some indication.
						local arguments=()
						local count=0
						while read -r line; do
							local line="$line"
							while [[ "$line" =~ (\$[0-9]+) ]]; do
								local match="${BASH_REMATCH[0]}"
								if ! is-needle "$match" -- "${arguments[@]}"; then
									arguments+=("$match")
								fi
								line="${line/"$match"/}" # Remove the matched part from the line
								# echo "trim: [$line]"
								if [[ "$count" == 10 ]]; then
									break
								fi
							done
						done <<<"$body_trimmed"
						description="..."
						output_name_body_mapping+=("$new_alias_name")
						final+="$SHEBANG_BASH"
						final+=$'\n'"# Name: $new_alias_name"
						final+=$'\n'"# Desc: $description"
						final+=$'\n'"# Args: ${arguments[*]}"
						final+=$'\n'"$body_trimmed"
						output_name_body_mapping+=("$final")

						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_VALUES+=("$body_trimmed")
						NEW_ALIAS_DESCS+=("")
						NEW_ALIAS_ARGS+=("'${arguments[@]}'")
						NEW_ALIAS_PATHS+=("$destination_sub_dir/$new_alias_name")
						NEW_ALIAS_CONTENTS+=("$new_alias_content")
					done

					for i in "${NEW_ALIAS_CONTENTS[@]}"; do
						log_contents "$i"
					done

					# TODO: Before creating, choose menu browse confirm all and hit
					# enter on a specific snippet to edit it.
					#
					# choose menu, put failures first, and then sucesses.
					# enter -> fix.
					#
					# - (x) collect failures
					# - ( ) collect successes.
					# - ( )
					#
					# -----
					# >> CHOOSE: 7 of 100 aliases had naming collisions. Select how to proceed:
					# ? Create 93 aliases and discard collision?
					# ? Fix naming collisions and try again?
					# ? Abort completely ?
					# ? Edit name/path of all aliases both successful AND failures ?
					# -----
					# TODO: ASSUME WE WANT TO FIX FAILURES
					# choose failures
					#   select single and edit
					#     if valid remove from failures
					#       update indices in NEW_ALIAS_*
					#         if failures == 0 break
					# confirm create N numbe of aliases

					# local alias_paths=()
					# local failure_name=()
					# local failure_labels=()
					# for ((i=0; i < "${#FAILING_ALIAS_NAMES[@]}"; i++)); do
					# 	local header contents
					# 	# ${path#*"commands.aliases"} does not work for trimming everything before
					# 	# the match pattern. That is why the string looks a bit weird below.
					# 	#
					# 	# header="commands${path#*"commands"}"
					# 	# contents="$("${BAT_CMD[@]}" "$path")"
					# 	# alias_names+=("$header")
					# 	alias_labels+=("$header"$'\n'"$contents")
					# done

					# __print_lines "${alias_labels[@]}"

					# TODO: How do I now handle dry running?
					#

					# # local status
					# eval_capture --statusvar=status -- try_create_alias_files

					local index=0 choose_title="Fix aliases"
					while :; do
						index="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${FAILING_ALIAS_PATHS[@]}")"
						if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${FAILING_ALIAS_PATHS[index]}"$'\n'"Prompt again?"; then
							break
						fi
					done

					# local status
					# eval_capture --statusvar=status -- try_create_alias_files
					#
					# # Fix errors loop
					# if [[ "$status" -ne 0 ]]; then
					#   echo-style --bold "ALIASES MIGRATE | Fix parser errors begin"
					#   for ((i = 0; i < "${#FAILING_ALIAS_NAMES[@]}"; i++)); do
					#     __print_lines "--------------------------------------------" \
					#       "NAME: ${FAILING_ALIAS_NAMES[i]}" \
					#       "DESC: ${FAILING_ALIAS_DESCS[i]}" \
					#       "ARGS: ${FAILING_ALIAS_ARGS[i]}" \
					#       "CONTENTS:" \
					#       "${FAILING_ALIAS_CONTENTS[i]}"
					#   done
					#
					#   # TODO: Create UI to fix each failed alias
					#   #
					#   #
					# fi

					# =======================================================
					# HANDLE OTHER SHELLS BELOW
					# =======================================================

				elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then
					if [[ "$interpreter" == "nu" ]]; then
						# HANDLE NUSHELL
						:
					elif [[ "$interpreter" == "elvish" ]]; then
						# HANDLE ELVISH
						:
					elif [[ "$interpreter" == "xonsh" ]]; then
						# HANDLE XONSH
						:
					fi
				else
					echo "Interpreter [$interpreter] not supported"
				fi
			fi
		}

		# remove this to make the <action> go live.
		# option_args=("$DOROTHY/user/sources/aliases.sh")
		for migrate_file in "${option_args[@]}"; do
			migrate_single_file "$migrate_file"
		done
	}

	# =======================================================
	# PREPARE

	if [[ -z "$option_action" ]]; then
		# help "No action provided"
		option_action="browse"
	fi

	if [[ -n "$option_migrate_to_subdir" ]]; then
		if ! is_valid_subdir_depth "$option_migrate_to_subdir"; then
			echo-style --error "Maximum sub dir depth allowed is [$ALLOW_MAX_SUB_DIRS]"
			exit
		fi
	fi

	# Because we collect things here, I can clean up some redundancy below.
	collect_existing_alias_info

	# =======================================================
	# Act

	# This is a better one liner but my linter complains too much about
	# funcs being unreachable so for now i go with the switch case.
	# "act_$option_action"

	case "$option_action" in
	browse) act_browse ;;
	create) act_create ;;
	migrate) act_migrate ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		command_aliases_test
	else
		command_aliases "$@"
	fi
fi
