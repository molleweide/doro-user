#!/usr/bin/env bash

#
# DOROTHY COMMAND ALIAS (DCA) HELPER
#
# This command is compatible with [Bash version 4.0 or later]
#

# -----------------------------------------------------------------------------
# URGENT
#
#
# TODO: act_migrate: --fix-iterate (*)
#         - instead of using choose, loop `ask` and fix each failure one by one.
#             (default is choose menu.)
#
# TODO: act_migrate: choose improve choices (**)
#         - select: update entry (if failure then trim and reload)
#         - esc: cancel to create only successful parsed DCAs
#         - ^C: to abort completely
#
# TODO: act_migrate: --include-successful (pertains to both * and **)
#         - include successful ones so that you can update successful parses
#           as well
#
# TODO: if added new sub dir -> call `environment.s` reload
#
# TODO: fix naming conventions.
#           - ( ) replace terms
#               > alias -> dca
#               >
#
# TEST: test run/source newly created aliases to see if there are any missing
# parts that would cause error.
#
# TEST: --test parse target files into `commands.aliases/test`
#         and if you provide subdirs then put them in `commands.aliases/test/<subdir>/*`
#
# -----------------------------------------------------------------------------
# NEXT
#
# ( ) Use fabric
# ( ) Analyze existing DCAs and check which could be improved with `exec`
#
# -----------------------------------------------------------------------------
#
# LATER
#
# - OPTIMIZATONS
#   - improve structure. eg. what takes the most time during parsing.
#   - use other available programs to increase speed.
#
# -----------------------------------------------------------------------------

# FIX: ( ) Apply correct return/exit statuses wherever something returns
#
# MOVE TO CORE
# - ( ) aliases
# - ( ) get-interpreter
# - ( ) command-aliases
# - ( ) is-valid-path

# NOTE: Whenever running some such as nvim or ranger, then do
# `exec ...` so that the command takes over the process, and prevent
# superfluous shell processes from spawning.
# >>> test how this will work

# TEST: how functions turned into aliases will work in context of eg.
# handling tmux stuff etc.

# TODO_: (overkill maybe)
# - Capture the args and rename them to better names and inject this as a line
#   before the function contents. And also rename the args in the function bodies.

function command_aliases_test() (
	# Test that aliases are migrated and parsed correctly. Handle:
	# - surrounding comments properly.
	# - collect arguments order and naming?
	# - ensure uniqueness
	:
)

function command_aliases() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# set -o errtrace  # Ensures ERR traps are inherited by functions
	# set -o functrace # Ensures DEBUG traps are inherited by functions
	# # set -E           # Same as `errtrace`

	# short DCA = dorothy command aliases
	# migrate aliases to dorothy

	local USER_COMMAND_ALIASES_DIR="$DOROTHY/user/commands.aliases"
	local SHEBANG_BASH="#!/usr/bin/env bash"
	local BAT_CMD=(bat --style numbers --color always --language bash --paging=never)

	local ALLOW_MAX_SUB_DIRS=2

	# these are added in the validate_aliases_and_capture_failures so that subsequent aliases
	# will always be able to check against the totality of all aliases when
	# checking for uniqueness
	# NOTE: If using `which <name>` in checking for uniqueness, then these two become
	# redundant.
	local ALL_EXISTING_ALIAS_PATHS=() # currently unused
	local ALL_EXISTING_ALIAS_BASENAMES=()

	# Use indices to get these back
	local NEW_ALIAS_NAMES=()
	local NEW_ALIAS_SUB_DIRS=()
	local NEW_ALIAS_VALUES=()
	local NEW_ALIAS_DESCS=()
	local NEW_ALIAS_ARGS=()
	local NEW_ALIAS_PATHS=() # remove this, and always concat the path..
	local NEW_ALIAS_CONTENTS=()
	local NEW_ALIAS_IS_FUNC=()

	local FAILING_ALIAS_REASON=()
	local FAILING_ALIAS_CORRECTION_FUNCS=() # Only used in `act_create`
	local SUCCESS_POSITIONS=() FAILING_POSITIONS=()

	local GO_LIVE='yes'

	local supported=(
		sh
		bash
		zsh
		fish
	)
	local supported_posix=(
		sh
		bash
		zsh
		fish
	)
	local supported_non_posix=(
		nu
		elvish
		xonsh
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [...<options] [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			    DCAs under "user/commands.aliases/*". Migrate can take multiple files
			    at once.

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

			OPTIONS:

			--to=<path>
			    If you are migrating a aliases of a specific type, eg. git aliases,
			    then you can specify path == "git/log", and then aliases will be
			    migrated into [commands.aliases/git/log*], so that all your logging
			    aliases are nicely put in a semantic location.

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# local option_args=()
	local option_action='' option_migrate_to_subdir='' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--to='*) option_migrate_to_subdir="${item#*=}" ;;
		'browse') option_action="browse" ;;
		'new' | 'create') option_action="create" ;;
		'migrate') option_action="migrate" ;;
			# '--')
			#   # 	option_args+=("$item" "$@")
			#   break
			#   ;;
			#   # *) option_args+=("$item") ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		*)
			help "Unknown argument was provided"
			;;
		esac
	done

	###

	function debug_against_failures() {

		echo "-------"
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			echo "NEW_ALIAS_NAMES: $i -> ${NEW_ALIAS_NAMES[i]}"
		done
		echo "-------"
		for i in "${FAILING_POSITIONS[@]}"; do
			echo "FPOS: $i -> ALL: ${NEW_ALIAS_NAMES[i]}"
		done
		echo "-------"

	}
	###

	function log_failure_and_success_positions() {
		echo "--- failure positions ---"
		echo "${FAILING_POSITIONS[@]}"
		echo "--- success positions ---"
		echo "${SUCCESS_POSITIONS[@]}"
		echo "-------"
	}

	# =======================================================
	# HELPER

	function log_single_content() {
		local index="${1-0}"
		bat --style numbers --color always --language bash --paging=never <<<"${NEW_ALIAS_CONTENTS[$index]}"
	}

	function log_all_contents() {
		for c in "${NEW_ALIAS_CONTENTS[@]}"; do
			bat --style numbers --color always --language bash --paging=never <<<"$c"
		done
	}

	function reset_new_alias_arrays() {
		NEW_ALIAS_NAMES=()
		NEW_ALIAS_SUB_DIRS=()
		NEW_ALIAS_PATHS=()
		NEW_ALIAS_CONTENTS=()
		NEW_ALIAS_VALUES=()
		NEW_ALIAS_DESCS=()
		NEW_ALIAS_ARGS=()
		NEW_ALIAS_IS_FUNC=()
	}

	function reset_status_arrays() {
		SUCCESS_POSITIONS=() FAILING_POSITIONS=()

		# FAILING_ALIAS_NAMES=()
		# FAILING_ALIAS_PATHS=()
		# FAILING_ALIAS_CONTENTS=()
		FAILING_ALIAS_REASON=()
	}

	# local char_classes="A-Za-z0-9"
	# local regex='^(/)?([^/\0]+(/)?)+$'
	# local regex='^/?([A-Za-z0-9._-]+/?)*$'
	function is_valid_path() {
		local input=$1
		local initial_slash="/?"
		local trailing_slash="/?"
		local special_chars_last="._-"
		local char_classes="[:alpha:][:digit:]"
		local valid_chars="([$char_classes/]+)"
		local start='^'
		local end='$'
		local regex="$start$valid_chars$end"
		if [[ ! "$input" =~ $regex ]]; then
			return 1
		fi
	}

	function is_valid_subdir_depth() {
		local check_str="$1" parts=()
		IFS='/' read -ra parts <<<"$check_str"
		if [[ "${#parts[@]}" -gt $ALLOW_MAX_SUB_DIRS ]]; then
			return 1
		fi
	}

	# get paths of existing aliases
	function get_all_command_aliases() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		find "$USER_COMMAND_ALIASES_DIR" -type f | grep -Ev "$regex_rm_paths_with_files_extension"
	}

	# # NOTE: Becomes redundant when checking w/`which`
	# function collect_existing_alias_info() {
	# 	ALL_EXISTING_ALIAS_BASENAMES=()
	# 	ALL_EXISTING_ALIAS_PATHS=()
	# 	while read -r line; do
	# 		ALL_EXISTING_ALIAS_PATHS+=("$line")
	# 		ALL_EXISTING_ALIAS_BASENAMES+=("$(basename "$line")")
	# 	done < <(echo-lines -- "$(get_all_command_aliases)" | echo-trim-empty-lines --stdin)
	# }

	function get_dca_sub_dir_target() {
		local input="${1-}"
		if [[ -n "$option_migrate_to_subdir" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$option_migrate_to_subdir"
		elif [[ -n "$input" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$input"
		else
			echo "$USER_COMMAND_ALIASES_DIR"
		fi

	}

	function get_dca_path() {
		local index="${1-0}"
		echo "$(get_dca_sub_dir_target "${NEW_ALIAS_SUB_DIRS[$index]}")/${NEW_ALIAS_NAMES[$index]}"
	}

	# ${path#*"commands.aliases"} does not work for trimming everything before
	# the match pattern. That is why the string looks a bit weird below.
	function short_name_from_path() {
		local index="${1-0}" path
		path="$(get_dca_path "$index")"
		echo "commands${path#*"commands"}"
	}

	# if no args, then correct permissions for all alias paths
	# else, correct permissions for input <path>s
	function correct_permissions() {
		echo "perms # == $#"
		if [[ $# -eq 0 ]]; then
			local alias_paths=()
			mapfile -t alias_paths < <(get_all_command_aliases)
			fs-own --x -- "${alias_paths[@]}"
		else
			fs-own --x --no-quiet -- "$@" # correct permissions for inpus only
		fi
	}

	# Function to remove an index N from an array
	function remove_array_index() {
		local array_name="$1" # Array name passed as the first argument
		local index="$2"      # Index to be removed

		# # # echo
		# # # echo
		# # echo "remove index $index from array $array_name -> ${!array_name[5]}"
		# echo "${!array_name[@]}"
		#
		# # Indirect reference to the array (using single quotes to prevent expansion)
		# eval 'local arr=("${!'"$array_name"'[@]}")'
		#
		# # Rebuild the array excluding the element at the specified index
		# eval "$array_name"'=("${arr[@]:0:'"$index"'}" "${arr[@]:$(('"$index + 1"'))}")'

		# Print the current state of the array
		# eval 'echo "Before removal: ${'"$array_name"'[@]}"'

		# Create a local array copy
		eval "local arr=(\"\${$array_name[@]}\")"

		# Rebuild the array excluding the element at index N
		eval "$array_name=(\"\${arr[@]:0:$index}\" \"\${arr[@]:$((index + 1))}\")"

		# # Print the modified array
		# eval 'echo "After removal: ${'"$array_name"'[@]}"'
	}

	# =======================================================
	# VALIDATORS

	function name_has_uppercase() {
		local index="${1-0}"
		# echo "${NEW_ALIAS_NAMES[$index]} =~ [A-Z]"
		if [[ "${NEW_ALIAS_NAMES[$index]}" =~ [A-Z] ]]; then
			return 0
		fi
		return 1
	}

	function name_has_valid_chars() {
		local index="${1-0}"
		local valid_chars="[a-zA-Z0-9._-]"
		# echo "${NEW_ALIAS_NAMES[$index]} =~ $valid_chars"
		if [[ "${NEW_ALIAS_NAMES[$index]}" =~ $valid_chars ]]; then
			return 0
		fi
		return 1
	}

	# make check case insensitive; macos filesystem is case insensitive.
	function name_is_unique() {
		local index="${1-0}"
		# echo "which -s ${NEW_ALIAS_NAMES[$index],,}"
		if which -s "${NEW_ALIAS_NAMES[$index],,}"; then
			return 1
		fi
	}

	# =======================================================

	function create_new_alias_files() {
		local target_path target_dir='' target_name prev_dir='' target_new_paths=()
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			if [[ -z "$prev_dir" || "$target_dir" == "$prev_dir" ]]; then
				target_dir="$(get_dca_sub_dir_target "${NEW_ALIAS_SUB_DIRS[$i]}")"
				__mkdirp "$target_dir"
			fi
			target_name="${NEW_ALIAS_NAMES[$i]}"
			target_path="$target_dir/$target_name"
			echo-style --success "[DEBUG] CREATE: $(short_name_from_path "$i")"
			echo "${NEW_ALIAS_CONTENTS[$i]}" >"$target_path"
			target_new_paths+=("$target_path")
		done
		correct_permissions "${target_new_paths[@]}" # bulk correct permissions
	}

	function validate_aliases_and_capture_failures() {
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			local failure='no' reason='' name="${NEW_ALIAS_NAMES[$i]}"
			local failure_part_redo_func=''
			if name_has_uppercase "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				# failure_validate_func=''
				reason="Alias can only be lower case. Your input was [$name]."
				echo-style --error "$reason"

			elif ! name_has_valid_chars "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				reason="New alias name contains invalid characters. Your input was [$name]. These are valid chars (a-z0-9._-)"
				echo-style --error "$reason"

			elif ! name_is_unique "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				reason="Alias with name [$name] already exists"
				echo-style --error "$reason"

			else
				SUCCESS_POSITIONS+=("$i")
				echo-style --success "Successfully validated alias [$(short_name_from_path "$i")]"
			fi
			if [[ "$failure" == 'yes' ]]; then
				FAILING_ALIAS_REASON+=("$reason")
				FAILING_ALIAS_CORRECTION_FUNCS+=("$failure_part_redo_func")
			fi
		done

		local complete_failure='yes'
		if [[ "${#SUCCESS_POSITIONS[@]}" == "${#NEW_ALIAS_NAMES[@]}" ]]; then
			complete_failure='no'
		fi

		if [[ "$failure" == 'no' ]]; then
			return 0
		else
			if [[ "$complete_failure" == 'yes' ]]; then
				return 1 # 1 complete failure
			else
				return 2 # 2 partial failure. some aliases were validated succeeded
			fi
		fi
	}

	function trim_failure_arrays() {
		local index="${1-0}"
		remove_array_index "FAILING_POSITIONS" "$index"
		remove_array_index "FAILING_ALIAS_REASON" "$index"
		remove_array_index "FAILING_ALIAS_CORRECTION_FUNCS" "$index"
	}
	# Defaults to index zero.
	function build_contents() {
		local index=${1-0} c=''

		NEW_ALIAS_PATHS[$index]="$(get_dca_sub_dir_target "${NEW_ALIAS_SUB_DIRS[$index]}")/${NEW_ALIAS_NAMES[$index]}"

		c+="$SHEBANG_BASH"
		c+=$'\n'"# Name: ${NEW_ALIAS_NAMES[$index]}"
		c+=$'\n'"# Desc: ${NEW_ALIAS_DESCS[$index]}"

		if [[ "${NEW_ALIAS_IS_FUNC[$index]}" == 'yes' ]]; then
			c+=$'\n'"# Args: ${NEW_ALIAS_ARGS[$index]}"
			c+=$'\n'"${NEW_ALIAS_VALUES[$index]}"
		else
			c+=$'\n'"${NEW_ALIAS_VALUES[$index]}"
			c+=' "$@"'
		fi
		NEW_ALIAS_CONTENTS[index]="$c"
	}

	# =======================================================
	# EDIT FUNCS
	#
	# - ( ) Add ability to create more informative labels by passing, eg. failure reason.

	function edit_name() {
		local index=${1-0}
		NEW_ALIAS_NAMES[index]="$(ask --linger "Edit name (old: ${NEW_ALIAS_NAMES[index]}) for index ($index):")"
		build_contents
	}

	function edit_value() {
		local index=${1-0}
		NEW_ALIAS_VALUES[index]="$(ask --linger "Edit command value (index: $index):")"
		build_contents
	}

	function edit_desc() {
		local index=${1-0}
		NEW_ALIAS_DESCS[index]="$(ask --linger "Edit new alias description (index: $index):")"
		build_contents
	}

	function edit_sub_path() {
		local index=${1-0}
		local sub_path
		while :; do
			sub_path="$(ask --linger 'Redo sub path:')"
			# path valid | validation is already done in the final validator func.
			# maybe it can be removed from here...
			if ! is_valid_path "$sub_path"; then
				sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
				# This could also go into the validator?
			elif ! is_valid_subdir_depth "$sub_path"; then
				sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
				# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
				# # this is handled by the redo choose menu
				# 	sub_path="$(ask --linger "Input subpath again:")"
			else
				break
			fi
		done
		NEW_ALIAS_SUB_DIRS[index]="$sub_path"
		build_contents
	}
	# =======================================================
	# ACTIONS

	# ( ) choose
	# ( ) fuzzy-helper
	# BINDINGS
	#   ( ) create new DCA from selection.
	function act_browse() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		local alias_paths=()
		local alias_names=()
		local alias_labels=()

		# -maxdepth 1
		mapfile -t alias_paths < <(get_all_command_aliases)
		for path in "${alias_paths[@]}"; do
			local header contents
			# ${path#*"commands.aliases"} does not work for trimming everything before
			# the match pattern. That is why the string looks a bit weird below.
			header="commands${path#*"commands"}"
			contents="$("${BAT_CMD[@]}" "$path")"
			alias_names+=("$header")
			alias_labels+=("$header"$'\n'"$contents")
		done

		__print_lines "${alias_labels[@]}"

		local index=0 choose_title="Aliases | Browser"
		while :; do
			index="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${alias_labels[@]}")"
			if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${alias_labels[index]}"$'\n'"Prompt again?"; then
				break
			fi
		done

	}

	# Use `dorothy-new` command here later when it is finished.
	# ( ) check if name already exists. confirm...
	# ( ) if you specify a path then create sub dirs under (*)
	function act_create() {
		local ask_prefix="ALIAS CREATE"
		reset_new_alias_arrays
		reset_status_arrays
		local new_alias_name='' new_alias_path='' \
			value=''desc='' sub_path='' confirm_proceed_and_create='' # new_alias_content=''

		# this is just to make it not complain. not used in this func...
		NEW_ALIAS_ARGS+=("")

		NEW_ALIAS_IS_FUNC+=('no')
		NEW_ALIAS_NAMES+=("$(ask --linger "$ask_prefix | What will the NAME be?")")
		NEW_ALIAS_VALUES+=("$(ask --linger "$ask_prefix | What will the VALUE be?")")
		NEW_ALIAS_DESCS+=("$(ask --linger "$ask_prefix | What will the DESC be?")")

		# handle sub dir group
		if confirm --ppid=$$ --negative -- "$ask_prefix | Put it in sub path, eg. [commands.aliases/<my>/<dir>]?"; then
			sub_path="$(ask --linger "$ask_prefix | What will the SUB PATH be?")"
			while :; do
				# path valid
				if ! is_valid_path "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
					# path maxth depth
				elif ! is_valid_subdir_depth "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
					# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
					# # this is handled by the redo choose menu
					# 	sub_path="$(ask --linger "Input subpath again:")"
				else
					NEW_ALIAS_SUB_DIRS+=("$sub_path")
					break
				fi
			done
		else
			NEW_ALIAS_SUB_DIRS+=("")
		fi

		# function reset_new_alias_arrays_single() {
		#   NEW_ALIAS_NAMES=()
		#   NEW_ALIAS_SUB_DIRS=()
		#   NEW_ALIAS_PATHS=()
		#   NEW_ALIAS_CONTENTS=()
		#   NEW_ALIAS_VALUES=()
		#   NEW_ALIAS_DESCS=()
		#   NEW_ALIAS_ARGS=()
		#
		#   NEW_ALIAS_NAMES+=("$new_alias_name")
		#   NEW_ALIAS_SUB_DIRS+=("$sub_path")
		#   NEW_ALIAS_PATHS+=("$new_alias_path")
		#   NEW_ALIAS_CONTENTS+=("$new_alias_content")
		#   NEW_ALIAS_VALUES+=("")
		#   NEW_ALIAS_DESCS+=("")
		#   NEW_ALIAS_ARGS+=("")
		# }

		build_contents

		# confirm current state of alias
		while :; do
			confirm_proceed_and_create="Go ahead create alias at "
			confirm_proceed_and_create+="[$(short_name_from_path)] OR edit alias?"$'\n'
			confirm_proceed_and_create+="$(bat --style numbers --color always --language bash --paging=never <<<"${NEW_ALIAS_CONTENTS[0]}")"}

			# create or update current alias
			if ! confirm --ppid=$$ --positive -- "$confirm_proceed_and_create"; then
				local redo_func redo_options=() title="Select which part to edit:"
				redo_options+=(edit_name "Name (${NEW_ALIAS_NAMES[0]})")
				redo_options+=(edit_value "Value (${NEW_ALIAS_VALUES[0]})")
				redo_options+=(edit_sub_path "Sub group name (${NEW_ALIAS_SUB_DIRS[0]})")
				redo_options+=(edit_desc "Description (${NEW_ALIAS_DESCS[0]})")
				redo_func="$(choose "$title" --label -- "${redo_options[@]}")"
				"$redo_func"
			else
				break
			fi

		done

		# reset_new_alias_arrays_single

		# loop
		#   is valid
		#     > fix failures
		#     > break
		# create
		while :; do

			# NOTE: I need to check the err tests to understand why this exists
			# without eval_capture

			# TODO: call the final validator func here instead.
			local status
			eval_capture --statusvar=status -- validate_aliases_and_capture_failures

			if [[ "$status" -ne 0 ]]; then
				local label

				# Since we only deal with one DCA at once here, it means we can just use
				# index 0 to access the data in FAILING_* arrays

				label="[$status] Creating alias [$(short_name_from_path)] failed with reason:"
				label+=$'\n'"REASON: ${FAILING_ALIAS_REASON[0]}"
				label+=$'\n'"Do you want to re-edit failing part?"

				if confirm --ppid=$$ --positive -- "$label"; then

					local failure_redo_func="${FAILING_ALIAS_CORRECTION_FUNCS[0]}"

					# Should never enter here
					if [[ -n "$failure_redo_func" && "$failure_redo_func" == "none" ]]; then
						local msg=''
						msg="CREATE | Could not create alias "
						msg+="[$(short_name_from_path)]. "
						msg+="No re-edit func exists for failure. (todo: ignore/discard?)"
						echo-style --error "$msg"
					fi

					# pass failure index
					"$failure_redo_func"

					# reset for next validation loop
					reset_status_arrays

					# reset_new_alias_arrays_single

				fi
			else
				create_new_alias_files # single
				break
			fi
		done

		if confirm --ppid=$$ --positive -- "Add nother alias?"; then
			act_create
		fi
	}

	function act_migrate() {
		local destination_sub_dir

		# On initial parse, then the <sub_path> for all parsed DCAs will be the same.
		# They will only deviate if user decides to modify DCAs before writing them.
		if [[ -n "$option_migrate_to_subdir" ]] && ! is_valid_path "$option_migrate_to_subdir"; then
			echo-style --error "Supplied invalid sub path: [$option_migrate_to_subdir]"
			exit 1
		fi

		destination_sub_dir="$(get_dca_sub_dir_target)"

		function migrate_single_file() {
			local input_file=$1 interpreter=''

			# local output_test_string=''
			# local output_name_body_mapping=()

			interpreter="$(get-interpreter --name -- "$input_file")"
			if is-needle "$interpreter" -- "${supported[@]}"; then

				# =======================================================
				# HANDLE POSIX
				# =======================================================

				if is-needle "$interpreter" -- "${supported_posix[@]}"; then
					local aliases=() function_names=()

					# ----
					# HANDLE POSIX ALIASES

					local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
					mapfile -t aliases < <(grep -E "$alias_regex" "$input_file" | echo-trim-each-line)
					for line_alias in "${aliases[@]}"; do
						local new_alias_name='' new_alias_desc='' value='' trailing_comment='' new_alias_path new_alias_content=''
						# handle trim trailing comment
						if [[ "$line_alias" =~ ^([^\#]*)\s*#\s*(.*) ]]; then
							line_alias="${BASH_REMATCH[1]}"
							new_alias_desc="${BASH_REMATCH[2]}"
						fi
						# handle split alias
						if [[ "$line_alias" =~ alias\ ([^=]+)=\"(.*)\" ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						elif [[ "$line_alias" =~ alias\ ([^=]+)=\'(.*)\' ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						fi

						NEW_ALIAS_IS_FUNC+=('no')
						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_SUB_DIRS+=("$option_migrate_to_subdir")
						NEW_ALIAS_VALUES+=("$value")
						NEW_ALIAS_DESCS+=("$new_alias_desc")
						NEW_ALIAS_ARGS+=("")
						NEW_ALIAS_PATHS+=("$destination_sub_dir/$new_alias_name")
						build_contents $(("${#NEW_ALIAS_NAMES[@]}" - 1))
					done

					# ----
					# HANDLE POSIX FUNCTIONS

					mapfile -t function_names < <(bash -c 'source '"$input_file"'; declare -F | awk "{print \$3}"')
					for new_alias_name in "${function_names[@]}"; do
						local final='' descriptiven='' body body_trimmed new_alias_name new_alias_path new_alias_content
						body="$(bash -c 'source '"$input_file"'; declare -f '"$new_alias_name")"
						body_trimmed="$(__print_lines "$body" | sed '1,2d; $d' | sed 's/^    //')"
						# Capture how many arguments each func snippets takes
						# This is not perfect but at least it gives some indication.
						local arguments=()
						local count=0
						while read -r line; do
							local line="$line"
							while [[ "$line" =~ (\$[0-9]+) ]]; do
								local match="${BASH_REMATCH[0]}"
								if ! is-needle "$match" -- "${arguments[@]}"; then
									arguments+=("$match")
								fi
								line="${line/"$match"/}" # Remove the matched part from the line
								# echo "trim: [$line]"
								if [[ "$count" == 10 ]]; then
									break
								fi
							done
						done <<<"$body_trimmed"
						NEW_ALIAS_IS_FUNC+=('yes')
						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_SUB_DIRS+=("$option_migrate_to_subdir")
						NEW_ALIAS_VALUES+=("$body_trimmed")
						NEW_ALIAS_DESCS+=("")
						NEW_ALIAS_ARGS+=("'${arguments[@]}'")
						NEW_ALIAS_PATHS+=("$destination_sub_dir/$new_alias_name")
						build_contents $(("${#NEW_ALIAS_NAMES[@]}" - 1))
					done

					#	log_all_contents

					# validate parsed aliases and funcs
					eval_capture --statusvar=status -- validate_aliases_and_capture_failures

					log_failure_and_success_positions

					while [[ "${#FAILING_POSITIONS[@]}" -gt 0 ]]; do
						local index=0 choose_title="${#FAILING_POSITIONS[@]} bad / ${#SUCCESS_POSITIONS[@]} good / ${#NEW_ALIAS_NAMES[@]} total | Select below to fix failing issue."
						local labels_failures=() sel_fail_idx_pos sel_fail_idx_val
						for ((i = 0; i < "${#FAILING_POSITIONS[@]}"; i++)); do
							local label='' failing_idx="${FAILING_POSITIONS[i]}"
							label+="$(echo-style --error+bold "#$i: [$(short_name_from_path "$failing_idx")] REASON: ${FAILING_ALIAS_REASON[$i]}")"
							label+=$'\n'"$(log_single_content "$failing_idx")"
							labels_failures+=("$label")
						done

						sel_fail_idx_pos="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${labels_failures[@]}")"
						sel_fail_idx_val="${FAILING_POSITIONS[$sel_fail_idx_pos]}"

						# debug_against_failures

						# TODO: handle cancellation
						if [[ -z "$sel_fail_idx_pos" ]]; then
							:
						fi

						local fixed='no'
						while [[ "$fixed" == "no" ]]; do
							edit_name "$sel_fail_idx_val"
							if ! name_has_uppercase "$sel_fail_idx_val" && name_has_valid_chars "$sel_fail_idx_val" && name_is_unique "$sel_fail_idx_val"; then
								fixed='yes'
								trim_failure_arrays "$sel_fail_idx_pos"
								SUCCESS_POSITIONS+=("$sel_fail_idx_val")
								SUCCESS_POSITIONS=($(printf "%s\n" "${array[@]}" | sort -n))
							fi
						done

						# if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${FAILING_ALIAS_PATHS[index]}"$'\n'"Prompt again?"; then
						# 	break
						# fi

					done

					create_new_alias_files

					# =======================================================
					# HANDLE OTHER SHELLS BELOW
					# =======================================================

				elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then
					if [[ "$interpreter" == "nu" ]]; then
						# HANDLE NUSHELL
						:
					elif [[ "$interpreter" == "elvish" ]]; then
						# HANDLE ELVISH
						:
					elif [[ "$interpreter" == "xonsh" ]]; then
						# HANDLE XONSH
						:
					fi
				else
					echo "Interpreter [$interpreter] not supported"
				fi
			fi
		}

		# remove this to make the <action> go live.
		# option_args=("$DOROTHY/user/sources/aliases.sh")
		for migrate_file in "${option_args[@]}"; do
			migrate_single_file "$migrate_file"
		done
	}

	# =======================================================
	# PREPARE

	if [[ -z "$option_action" ]]; then
		# help "No action provided"
		option_action="browse"
	fi

	# Check before running migration..
	if [[ -n "$option_migrate_to_subdir" ]]; then
		if ! is_valid_subdir_depth "$option_migrate_to_subdir"; then
			echo-style --error "Maximum sub dir depth allowed is [$ALLOW_MAX_SUB_DIRS]"
			exit
		fi
	fi

	# # NOTE: This becomes redundant when checking with `which <dca>`
	# # Because we collect things here, I can clean up some redundancy below.
	# collect_existing_alias_info

	# =======================================================
	# Act

	# This is a better one liner but my linter complains too much about
	# funcs being unreachable so for now i go with the switch case.
	# "act_$option_action"

	case "$option_action" in
	browse) act_browse ;;
	create) act_create ;;
	migrate) act_migrate ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		command_aliases_test
	else
		command_aliases "$@"
	fi
fi
