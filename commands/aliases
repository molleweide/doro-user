#!/usr/bin/env bash

#
# DOROTHY COMMAND ALIAS (DCA) HELPER
#
# This command is compatible with [Bash version 4.0 or later]
#

# -----------------------------------------------------------------------------
# URGENT
#
#
# TODO: (*) act_migrate: --fix-iterate (*)
#           - each edit func needs to return a status value, so that i can
#             handle abort
#           - in each edit func, put the index at the beginnig so it is clearer
#             what happens.
#           - Also, list the failure reason inside the edit func.
#           - (*) in the edit funcs, show the contents in the label, so that you get context.
#
# TODO: (*) act_migrate: --include-successful (pertains to both * and **)
#         - include successful ones so that you can update successful parses
#           as well
#
# TODO: ( ) act_migrate: --pause
#           even if all parsed successfuly, always throw up choose so that you
#           can review before proceeding to create the files
#
# TODO: ( ) use action_ui_prefix for all UI prompts
#
# TODO: if added new sub dir -> call `environment.sh` reload
#
# TODO: fix naming conventions.
#           - ( ) replace terms
#               > alias -> dca
#               >
#
# TODO: add custom keybind mappings to choose??
#
# TEST: test run/source newly created aliases to see if there are any missing
# parts that would cause error.
#
# TEST: --test parse target files into `commands.aliases/test`
#         and if you provide subdirs then put them in `commands.aliases/test/<subdir>/*`
#
# -----------------------------------------------------------------------------
# NEXT
#
# ( ) Use fabric
# ( ) Analyze existing DCAs and check which could be improved with `exec`
#
# -----------------------------------------------------------------------------
#
# LATER
#
# - OPTIMIZATONS
#   - improve structure. eg. what takes the most time during parsing.
#   - use other available programs to increase speed.
#
# -----------------------------------------------------------------------------

# FIX: ( ) Apply correct return/exit statuses wherever something returns
#
# MOVE TO CORE
# - ( ) aliases
# - ( ) get-interpreter
# - ( ) command-aliases
# - ( ) is-valid-path

# NOTE: Whenever running some such as nvim or ranger, then do
# `exec ...` so that the command takes over the process, and prevent
# superfluous shell processes from spawning.
# >>> test how this will work

# TEST: how functions turned into aliases will work in context of eg.
# handling tmux stuff etc.

# TODO_: (overkill maybe)
# - Capture the args and rename them to better names and inject this as a line
#   before the function contents. And also rename the args in the function bodies.

function command_aliases_test() (
	# Test that aliases are migrated and parsed correctly. Handle:
	# - surrounding comments properly.
	# - collect arguments order and naming?
	# - ensure uniqueness
	:
)

function command_aliases() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	local USER_COMMAND_ALIASES_DIR="$DOROTHY/user/commands.aliases"
	local SHEBANG_BASH="#!/usr/bin/env bash"
	local BAT_CMD=(bat --style numbers --color always --language bash --paging=never)
	local ALLOW_MAX_SUB_DIRS=2
	# Use indices to get these back
	local action_ui_prefix=''
	local NEW_ALIAS_NAMES=()
	local NEW_ALIAS_SUB_DIRS=()
	local NEW_ALIAS_VALUES=()
	local NEW_ALIAS_DESCS=()
	local NEW_ALIAS_ARGS=()
	local NEW_ALIAS_CONTENTS=()
	local NEW_ALIAS_IS_FUNC=()
	local FAILING_ALIAS_REASON=()
	local FAILING_ALIAS_CORRECTION_FUNCS=() # Only used in `act_create`
	local SUCCESS_POSITIONS=() FAILING_POSITIONS=()
	local regex_rm_paths_with_files_extension='\.[^/]+$'
	local supported=(
		sh
		bash
		zsh
		fish
	)
	local supported_posix=(
		sh
		bash
		zsh
		fish
	)
	local supported_non_posix=(
		nu
		elvish
		xonsh
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [...<options] [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			    DCAs under "user/commands.aliases/*". Migrate can take multiple files
			    at once.

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

			OPTIONS:

			--to=<path>
			    If you are migrating a aliases of a specific type, eg. git aliases,
			    then you can specify path == "git/log", and then aliases will be
			    migrated into [commands.aliases/git/log*], so that all your logging
			    aliases are nicely put in a semantic location.

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# local option_args=()
	local option_action='' option_quiet='no' option_pause='no' option_migrate_to_subdir='' option_args=() option_fix_iterate='no' option_include_successful='no'
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--no-quiet'* | '--quiet'*)
			option_quiet="$(get-flag-value --affirmative --fallback="$option_quiet" -- "$item")"
			;;
		'--to='*) option_migrate_to_subdir="${item#*=}" ;;
		'--fix-iterate') option_fix_iterate='yes' ;;               # todo
		'--include-successful') option_include_successful='yes' ;; # todo
		'--pause') option_pause='yes' ;;                           # todo; this kinda implies --include-successful
		'browse') option_action="browse" ;;
		'new' | 'create') option_action="create" ;;
		'migrate') option_action="migrate" ;;
			# '--')
			#   # 	option_args+=("$item" "$@")
			#   break
			#   ;;
			#   # *) option_args+=("$item") ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		*)
			help "Unknown argument was provided"
			;;
		esac
	done

	# =======================================================
	# LOG AND DEBUG HELPERS

	function debug_against_failures() {

		echo "-------"
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			echo "NEW_ALIAS_NAMES: $i -> ${NEW_ALIAS_NAMES[i]}"
		done
		echo "-------"
		for i in "${FAILING_POSITIONS[@]}"; do
			echo "FPOS: $i -> ALL: ${NEW_ALIAS_NAMES[i]}"
		done
		echo "-------"

	}
	###

	function log_failure_and_success_positions() {
		echo "--- failure positions ---"
		echo "${FAILING_POSITIONS[@]}"
		echo "--- success positions ---"
		echo "${SUCCESS_POSITIONS[@]}"
		echo "-------"
	}


	function log_single_content() {
		local index="${1-0}"
		bat --style numbers --color always --language bash --paging=never <<<"${NEW_ALIAS_CONTENTS[$index]}"
	}

	function log_all_contents() {
		for c in "${NEW_ALIAS_CONTENTS[@]}"; do
			bat --style numbers --color always --language bash --paging=never <<<"$c"
		done
	}

	# =======================================================
	# ARRAY HELPERS

	function reset_new_alias_arrays() {
		NEW_ALIAS_NAMES=()
		NEW_ALIAS_SUB_DIRS=()
		NEW_ALIAS_CONTENTS=()
		NEW_ALIAS_VALUES=()
		NEW_ALIAS_DESCS=()
		NEW_ALIAS_ARGS=()
		NEW_ALIAS_IS_FUNC=()
	}

	function reset_status_arrays() {
		SUCCESS_POSITIONS=() FAILING_POSITIONS=() FAILING_ALIAS_REASON=()
	}

	function reset_all() {
		reset_new_alias_arrays
		reset_status_arrays
	}

	function success_pos_add() {
		SUCCESS_POSITIONS+=("$1")
		SUCCESS_POSITIONS=($(printf "%s\n" "${SUCCESS_POSITIONS[@]}" | sort -n))
	}

	# Function to remove an index N from an array
	function remove_array_index() {
		local array_name="$1" index="$2"
		eval "local arr=(\"\${$array_name[@]}\")"
		eval "$array_name=(\"\${arr[@]:0:$index}\" \"\${arr[@]:$((index + 1))}\")"
	}

	function trim_failure_arrays() {
		local index="${1-0}"
		remove_array_index "FAILING_POSITIONS" "$index"
		remove_array_index "FAILING_ALIAS_REASON" "$index"
		remove_array_index "FAILING_ALIAS_CORRECTION_FUNCS" "$index"
	}

	# =======================================================
	# GETTERS

	# get paths of existing aliases
	function get_all_existing_dcas() {
		find "$USER_COMMAND_ALIASES_DIR" -type f | grep -Ev "$regex_rm_paths_with_files_extension"
	}

	function get_dca_sub_dir_target() {
		local input="${1-}"
		if [[ -n "$option_migrate_to_subdir" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$option_migrate_to_subdir"
		elif [[ -n "$input" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$input"
		else
			echo "$USER_COMMAND_ALIASES_DIR"
		fi
	}

	function get_dca_path() {
		local index="${1-0}"
		echo "$(get_dca_sub_dir_target "${NEW_ALIAS_SUB_DIRS[$index]}")/${NEW_ALIAS_NAMES[$index]}"
	}

	# ${path#*"commands.aliases"} does not work for trimming everything before
	# the match pattern. That is why the string looks a bit weird below.
	function get_dca_short_path() {
		local index="${1-0}" path
		path="$(get_dca_path "$index")"
		echo "commands${path#*"commands"}"
	}

	# =======================================================
	# VALIDATORS

	# local char_classes="A-Za-z0-9"
	# local regex='^(/)?([^/\0]+(/)?)+$'
	# local regex='^/?([A-Za-z0-9._-]+/?)*$'
	function is_valid_path() {
		local input=$1
		local char_classes="[:alpha:][:digit:]"
		local valid_chars="([$char_classes/]+)"
		local start='^'
		local end='$'
		local regex="$start$valid_chars$end"
		if [[ ! "$input" =~ $regex ]]; then
			return 1
		fi
	}

	function is_valid_subdir_depth() {
		local check_str="$1" parts=()
		IFS='/' read -ra parts <<<"$check_str"
		if [[ "${#parts[@]}" -gt $ALLOW_MAX_SUB_DIRS ]]; then
			return 1
		fi
	}
	function name_has_uppercase() {
		local index="${1-0}"
		if [[ "${NEW_ALIAS_NAMES[$index]}" =~ [A-Z] ]]; then
			return 0
		fi
		return 1
	}

	function name_has_valid_chars() {
		local index="${1-0}"
		local valid_chars="[a-zA-Z0-9._-]"
		if [[ "${NEW_ALIAS_NAMES[$index]}" =~ $valid_chars ]]; then
			return 0
		fi
		return 1
	}

	# make check case insensitive; macos filesystem is case insensitive.
	function name_is_unique() {
		local index="${1-0}"
		if which -s "${NEW_ALIAS_NAMES[$index],,}"; then
			return 1
		fi
	}

	function validate_single_simple() {
		if ! name_has_uppercase "$1" && name_has_valid_chars "$1" && name_is_unique "$1"; then
			return 0
		fi
		return 1
	}

	function validate_aliases_and_capture_failures() {
		for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
			local failure='no' reason='' name="${NEW_ALIAS_NAMES[$i]}"
			local failure_part_redo_func=''
			if name_has_uppercase "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				# failure_validate_func=''
				reason="Alias can only be lower case. Your input was [$name]."
				echo-style --error "$reason"

			elif ! name_has_valid_chars "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				reason="New alias name contains invalid characters. Your input was [$name]. These are valid chars (a-z0-9._-)"
				echo-style --error "$reason"

			elif ! name_is_unique "$i"; then
				FAILING_POSITIONS+=("$i")
				failure='yes'
				failure_part_redo_func='edit_name'
				reason="Alias with name [$name] already exists"
				echo-style --error "$reason"

			else
				SUCCESS_POSITIONS+=("$i")
				echo-style --success "Successfully validated alias [$(get_dca_short_path "$i")]"
			fi
			if [[ "$failure" == 'yes' ]]; then
				FAILING_ALIAS_REASON+=("$reason")
				FAILING_ALIAS_CORRECTION_FUNCS+=("$failure_part_redo_func")
			fi
		done

		local complete_failure='yes'
		if [[ "${#SUCCESS_POSITIONS[@]}" == "${#NEW_ALIAS_NAMES[@]}" ]]; then
			complete_failure='no'
		fi

		if [[ "$failure" == 'no' ]]; then
			return 0
		else
			if [[ "$complete_failure" == 'yes' ]]; then
				return 1 # 1 complete failure
			else
				return 2 # 2 partial failure. some aliases were validated succeeded
			fi
		fi
	}

	# =======================================================
	# FILE SYSTEM

	function correct_permissions() {
		if [[ $# -eq 0 ]]; then
			local alias_paths=()
			mapfile -t alias_paths < <(get_all_existing_dcas)
			fs-own --x -- "${alias_paths[@]}"
		else
			fs-own --x --no-quiet -- "$@" # correct permissions for inpus only
		fi
	}

	function create_new_alias_files() {
		local i target_path target_dir='' target_name prev_dir='' target_new_paths=()

		function apply() {
			if [[ -z "$prev_dir" || "$target_dir" == "$prev_dir" ]]; then
				target_dir="$(get_dca_sub_dir_target "${NEW_ALIAS_SUB_DIRS[$i]}")"
				__mkdirp "$target_dir" >/dev/null
			fi
			target_name="${NEW_ALIAS_NAMES[$i]}"
			target_path="$target_dir/$target_name"
			__print_lines "${NEW_ALIAS_CONTENTS[$i]}" >"$target_path"
			target_new_paths+=("$target_path")
		}

		if [[ "${1-}" == "--successful" ]]; then
			for i in "${SUCCESS_POSITIONS[@]}"; do
				apply
				# echo-style --success "[DEBUG] CREATE: $(get_dca_short_path "$i")"
				# __print_lines "${NEW_ALIAS_CONTENTS[$i]}" >"$target_path"
				# target_new_paths+=("$target_path")
			done
		else
			for ((i = 0; i < "${#NEW_ALIAS_NAMES[@]}"; i++)); do
				apply
				# target_name="${NEW_ALIAS_NAMES[$i]}"
				# target_path="$target_dir/$target_name"
				# echo-style --success "[DEBUG] CREATE: $(get_dca_short_path "$i")"
				# __print_lines "${NEW_ALIAS_CONTENTS[$i]}" >"$target_path"
				# target_new_paths+=("$target_path")
			done
		fi
		correct_permissions "${target_new_paths[@]}" # bulk correct permissions
	}

	# =======================================================
	#

	function build_contents() {
		local index=${1-0} c=''
		c+="$SHEBANG_BASH"
		c+=$'\n'"# Name: ${NEW_ALIAS_NAMES[$index]}"
		c+=$'\n'"# Desc: ${NEW_ALIAS_DESCS[$index]}"
		if [[ "${NEW_ALIAS_IS_FUNC[$index]}" == 'yes' ]]; then
			c+=$'\n'"# Args: ${NEW_ALIAS_ARGS[$index]}"
			c+=$'\n'"${NEW_ALIAS_VALUES[$index]}"
		else
			c+=$'\n'"${NEW_ALIAS_VALUES[$index]}"
			c+=' "$@"'
		fi
		NEW_ALIAS_CONTENTS[index]="$c"
	}

	# =======================================================
	# EDIT FUNCS
	#
	# - ( ) Add ability to create more informative labels by passing, eg. failure reason.
	#
	# TODO: these functions should return status on abort, so that i can use that
	# to break out of editing pipeline in act_migrate

	function edit_name() {
		local index=${1-0}
		NEW_ALIAS_NAMES[index]="$(ask --linger "Edit name (old: ${NEW_ALIAS_NAMES[index]}) for index ($index):")"
		build_contents
	}

	function edit_value() {
		local index=${1-0}
		NEW_ALIAS_VALUES[index]="$(ask --linger "Edit command value (index: $index):")"
		build_contents
	}

	function edit_desc() {
		local index=${1-0}
		NEW_ALIAS_DESCS[index]="$(ask --linger "Edit new alias description (index: $index):")"
		build_contents
	}

	function edit_sub_path() {
		local index=${1-0}
		local sub_path
		while :; do
			sub_path="$(ask --linger 'Redo sub path:')"
			# path valid | validation is already done in the final validator func.
			# maybe it can be removed from here...
			if ! is_valid_path "$sub_path"; then
				sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
				# This could also go into the validator?
			elif ! is_valid_subdir_depth "$sub_path"; then
				sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
				# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
				# # this is handled by the redo choose menu
				# 	sub_path="$(ask --linger "Input subpath again:")"
			else
				break
			fi
		done
		NEW_ALIAS_SUB_DIRS[index]="$sub_path"
		build_contents
	}

	# =======================================================
	# =======================================================
	# =======================================================
	# ACTIONS

	# =======================================================
	# BROWSE

	# ( ) choose
	# ( ) fuzzy-helper
	# ( ) keybind create new DCA from selection.
	function act_browse() {
		local alias_paths=() alias_names=() alias_labels=()
		mapfile -t alias_paths < <(get_all_existing_dcas)
		for path in "${alias_paths[@]}"; do
			local header contents
			# ${path#*"commands.aliases"} does not work for trimming everything before
			# the match pattern. That is why the string looks a bit weird below.
			header="commands${path#*"commands"}"
			contents="$("${BAT_CMD[@]}" "$path")"
			alias_names+=("$header")
			alias_labels+=("$header"$'\n'"$contents")
		done
		# __print_lines "${alias_labels[@]}"
		local index=0 choose_title="Aliases | Browser"
		while :; do
			index="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${alias_labels[@]}")"
			if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${alias_labels[index]}"$'\n'"Prompt again?"; then
				break
			fi
		done
	}

	# =======================================================
	# CREATE

	function act_create() {
		local sub_path='' ask_prefix="ALIASES CREATE"
		reset_all
		NEW_ALIAS_IS_FUNC+=('no')
		NEW_ALIAS_NAMES+=("$(ask --linger --required "$ask_prefix | What will the NAME be?")")
		NEW_ALIAS_VALUES+=("$(ask --linger --required "$ask_prefix | What will the VALUE be?")")
		NEW_ALIAS_DESCS+=("$(ask --linger "$ask_prefix | What will the DESC be?")")
		if confirm --ppid=$$ --negative -- "$ask_prefix | Put it in sub path, eg. [commands.aliases/<my>/<dir>]?"; then
			sub_path="$(ask --linger "$ask_prefix | What will the SUB PATH be?")"
			while :; do
				# path valid
				if ! is_valid_path "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
					# path maxth depth
				elif ! is_valid_subdir_depth "$sub_path"; then
					sub_path="$(ask --linger "[$sub_path] exceeds max subd dir depth [$ALLOW_MAX_SUB_DIRS] | Input sub path again:")"
					# elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
					# # this is handled by the redo choose menu
					# 	sub_path="$(ask --linger "Input subpath again:")"
				else
					NEW_ALIAS_SUB_DIRS+=("$sub_path")
					break
				fi
			done
		else
			NEW_ALIAS_SUB_DIRS+=("")
		fi
		build_contents
		local confirm_or_edit
		while :; do
			confirm_or_edit="Go ahead create alias at [$(get_dca_short_path)] OR edit alias?"$'\n'"$(log_single_content)"
			if ! confirm --ppid=$$ --positive -- "$confirm_or_edit"; then
				local redo_func redo_options=() title="Select which part to edit:"
				redo_options+=(edit_name "Name (${NEW_ALIAS_NAMES[0]})")
				redo_options+=(edit_value "Value (${NEW_ALIAS_VALUES[0]})")
				redo_options+=(edit_sub_path "Sub group name (${NEW_ALIAS_SUB_DIRS[0]})")
				redo_options+=(edit_desc "Description (${NEW_ALIAS_DESCS[0]})")
				redo_func="$(choose "$title" --label -- "${redo_options[@]}")"
				"$redo_func"
			else
				break
			fi
		done

		local failure_redo_func status
		while :; do
			eval_capture --statusvar=status -- validate_aliases_and_capture_failures
			if [[ "$status" -ne 0 ]]; then
				local label
				label="[$status] Creating alias [$(get_dca_short_path)] failed with reason:"
				label+=$'\n'"REASON: ${FAILING_ALIAS_REASON[0]}"
				label+=$'\n'"Do you want to re-edit failing part?"
				if confirm --ppid=$$ --positive -- "$label"; then
					failure_redo_func="${FAILING_ALIAS_CORRECTION_FUNCS[0]}"
					if [[ -n "$failure_redo_func" && "$failure_redo_func" == "none" ]]; then
						echo-style --error "CREATE | Could not create alias [$(get_dca_short_path)]. No re-edit func exists for failure. (todo: ignore/discard?)"
					fi
					"$failure_redo_func"
					reset_status_arrays
				fi
			else
				create_new_alias_files # single
				break
			fi
		done

		if confirm --ppid=$$ --positive -- "Add nother alias?"; then
			act_create
		fi
	}

	# =======================================================
	# MIGRATE

	function act_migrate() {
		local destination_sub_dir interpreter='' input_file migrate_prefix="ALIASES MIGRATE | "
		if [[ -n "$option_migrate_to_subdir" ]] && ! is_valid_path "$option_migrate_to_subdir"; then
			echo-style --error "Supplied invalid sub path: [$option_migrate_to_subdir]"
			exit 1
		fi
		destination_sub_dir="$(get_dca_sub_dir_target)"

		function migrate_single_file() {
			input_file=$1 interpreter="$(get-interpreter --name -- "$input_file")"
			if is-needle "$interpreter" -- "${supported[@]}"; then

				# =======================================================
				# HANDLE POSIX
				# =======================================================

				if is-needle "$interpreter" -- "${supported_posix[@]}"; then
					local aliases=() function_names=()

					# ----
					# HANDLE POSIX ALIASES

					local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
					mapfile -t aliases < <(grep -E "$alias_regex" "$input_file" | echo-trim-each-line)
					for line_alias in "${aliases[@]}"; do
						local new_alias_name='' new_alias_desc='' value='' trailing_comment='' new_alias_path new_alias_content=''
						# handle trim trailing comment
						if [[ "$line_alias" =~ ^([^\#]*)\s*#\s*(.*) ]]; then
							line_alias="${BASH_REMATCH[1]}"
							new_alias_desc="${BASH_REMATCH[2]}"
						fi
						# handle split alias
						if [[ "$line_alias" =~ alias\ ([^=]+)=\"(.*)\" ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						elif [[ "$line_alias" =~ alias\ ([^=]+)=\'(.*)\' ]]; then
							new_alias_name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						fi
						NEW_ALIAS_IS_FUNC+=('no')
						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_SUB_DIRS+=("$option_migrate_to_subdir")
						NEW_ALIAS_VALUES+=("$value")
						NEW_ALIAS_DESCS+=("$new_alias_desc")
						NEW_ALIAS_ARGS+=("")
						build_contents $(("${#NEW_ALIAS_NAMES[@]}" - 1))
					done

					# ----
					# HANDLE POSIX FUNCTIONS

					mapfile -t function_names < <(bash -c 'source '"$input_file"'; declare -F | awk "{print \$3}"')
					for new_alias_name in "${function_names[@]}"; do
						local final='' descriptiven='' body body_trimmed new_alias_name new_alias_path new_alias_content
						body="$(bash -c 'source '"$input_file"'; declare -f '"$new_alias_name")"
						body_trimmed="$(__print_lines "$body" | sed '1,2d; $d' | sed 's/^    //')"
						# Capture how many arguments each func snippets takes. This is not perfect but at least it gives some indication.
						local arguments=() count=0
						while read -r line; do
							local line="$line"
							while [[ "$line" =~ (\$[0-9]+) ]]; do
								local match="${BASH_REMATCH[0]}"
								if ! is-needle "$match" -- "${arguments[@]}"; then
									arguments+=("$match")
								fi
								line="${line/"$match"/}" # Remove the matched part from the line
								# echo "trim: [$line]"
								if [[ "$count" == 10 ]]; then
									break
								fi
							done
						done <<<"$body_trimmed"
						NEW_ALIAS_IS_FUNC+=('yes')
						NEW_ALIAS_NAMES+=("$new_alias_name")
						NEW_ALIAS_SUB_DIRS+=("$option_migrate_to_subdir")
						NEW_ALIAS_VALUES+=("$body_trimmed")
						NEW_ALIAS_DESCS+=("")
						NEW_ALIAS_ARGS+=("'${arguments[@]}'")
						build_contents $(("${#NEW_ALIAS_NAMES[@]}" - 1))
					done

					#	log_all_contents

					# validate parsed aliases and funcs
					eval_capture --statusvar=status -- validate_aliases_and_capture_failures

					# log_failure_and_success_positions

					local sel_fail_idx_pos sel_fail_idx_val proceed_with_successful='no'

          # fix a single failure
					function rectify() {
						if [[ -z "$sel_fail_idx_pos" ]]; then
							proceed_with_successful='yes'
							return 1
						fi
						local fixed='no'
						while [[ "$fixed" == "no" ]]; do
						  # TODO: if abort, then just set `sel_fail_idx_pos` to "" and the loop will exit
						  # >>> this requires edit funcs to return their status on abort.
							edit_name "$sel_fail_idx_val"
							if validate_single_simple "$sel_fail_idx_val"; then
								fixed='yes'
								trim_failure_arrays "$sel_fail_idx_pos"
								success_pos_add "$sel_fail_idx_val"
							fi
						done
					}

					if [[ "$option_fix_iterate" == 'yes' ]]; then
						local iterations="${#FAILING_POSITIONS[@]}"
						for ((i = 0; i < "$iterations"; i++)); do
							sel_fail_idx_pos=0
							sel_fail_idx_val="${FAILING_POSITIONS[$sel_fail_idx_pos]}"
							! rectify && break
						done
					else
						while [[ "${#FAILING_POSITIONS[@]}" -gt 0 ]]; do
							local index=0 choose_title="$migrate_prefix"
							choose_title+="${#FAILING_POSITIONS[@]} bad / ${#SUCCESS_POSITIONS[@]} good / ${#NEW_ALIAS_NAMES[@]} total | Select below to fix failing issue."
							choose_title+=$'\n'"ENTER: edit/fix selection | ESC/CANCEL: create validate only | Ctrl-C: Abort"
							local labels_failures=()
							for ((i = 0; i < "${#FAILING_POSITIONS[@]}"; i++)); do
								local label='' failing_idx="${FAILING_POSITIONS[i]}"
								label+="$(echo-style --error+bold "#$i: [$(get_dca_short_path "$failing_idx")] REASON: ${FAILING_ALIAS_REASON[$i]}")"
								label+=$'\n'"$(log_single_content "$failing_idx")"
								labels_failures+=("$label")
							done
							sel_fail_idx_pos="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${labels_failures[@]}")"
							sel_fail_idx_val="${FAILING_POSITIONS[$sel_fail_idx_pos]}"
							# debug_against_failures
							! rectify && break
						done
					fi

					# if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${FAILING_ALIAS_PATHS[index]}"$'\n'"Prompt again?"; then
					# 	break
					# fi

					if [[ "$proceed_with_successful" == 'yes' ]]; then
						echo-style --bold "[User cancelled]: Proceeding to create only valid DCAs.."
						create_new_alias_files --successful
					else
						create_new_alias_files
					fi

					# =======================================================
					# HANDLE OTHER SHELLS BELOW
					# =======================================================

				elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then
					if [[ "$interpreter" == "nu" ]]; then
						# HANDLE NUSHELL
						:
					elif [[ "$interpreter" == "elvish" ]]; then
						# HANDLE ELVISH
						:
					elif [[ "$interpreter" == "xonsh" ]]; then
						# HANDLE XONSH
						:
					fi
				else
					echo "Interpreter [$interpreter] not supported"
				fi
			fi
		}

		# remove this to make the <action> go live.
		# option_args=("$DOROTHY/user/sources/aliases.sh")
		for migrate_file in "${option_args[@]}"; do
			migrate_single_file "$migrate_file"
		done
	}

	# =======================================================
	# PREPARE

	if [[ -z "$option_action" ]]; then
		# help "No action provided"
		option_action="browse"
	fi

	# Check before running migration..
	if [[ -n "$option_migrate_to_subdir" ]]; then
		if ! is_valid_subdir_depth "$option_migrate_to_subdir"; then
			echo-style --error "Maximum sub dir depth allowed is [$ALLOW_MAX_SUB_DIRS]"
			exit
		fi
	fi

	# # NOTE: This becomes redundant when checking with `which <dca>`
	# # Because we collect things here, I can clean up some redundancy below.
	# collect_existing_alias_info

	# =======================================================
	# Act

	# This is a better one liner but my linter complains too much about
	# funcs being unreachable so for now i go with the switch case.
	# "act_$option_action"

	case "$option_action" in
	browse) act_browse ;;
	create) act_create ;;
	migrate) act_migrate ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		command_aliases_test
	else
		command_aliases "$@"
	fi
fi
