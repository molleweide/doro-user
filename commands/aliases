#!/usr/bin/env bash

# FIX: ( ) Apply correct return/exit statuses wherever something returns
#
# TODO:
# (*) create_aliases
#       Put handle (file creation) and (permission correction) in the same func
# ( ) Only allow N alias subdir depth
# MOVE TO CORE
# - ( ) aliases
# - ( ) get-interpreter
# - ( ) command-aliases
# - ( ) is-valid-path

# investigate AI for organizing the aliases

function command_aliases_test() (
	# Test that aliases are migrated and parsed correctly. Handle:
	# - surrounding comments properly.
	# - collect arguments order and naming?
	# - ensure uniqueness
	:
)

function command_aliases() (
	source "$DOROTHY/sources/bash.bash"
	__require_array 'mapfile'

	# short DCA = dorothy command aliases
	# migrate aliases to dorothy

	local USER_COMMAND_ALIASES_DIR="$DOROTHY/user/commands.aliases"
	local SHEBANG_BASH="#!/usr/bin/env bash"
	local BAT_CMD=(bat --style numbers --color always --language bash --paging=never)

	local ALL_EXISTING_ALIAS_PATHS=()
	local ALL_EXISTING_ALIAS_BASENAMES=()

	local supported=(
		sh
		bash
		zsh
		fish
	)
	local supported_posix=(
		sh
		bash
		zsh
		fish
	)
	local supported_non_posix=(
		nu
		elvish
		xonsh
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Helper command for managing "dorothy command aliases" (DCA), which are
			small executable files that functionally are treated and acts like aliases
			but are much easier to handle. Aliases are stupid and difficult to handle.
			Therefore using executable files instead for each alias makes them much
			easier to manage and it comes with the extra benefit that they are
			cross shell compatible which allows you to switch shell and still use
			any aliases that you are acustomed to.

			USAGE:
			command-aliases [...<options] [<action>] [-- [...<input>]]

			ACTIONS:

			command-aliases browse

			    Browse aliases in a convenient manner, eg. show/list/edit/remove/dupl/etc.
			    This is default if run standalone.

			command-aliases migrate -- [...<alias_file>]

			    Parse old aliases/functions from <source> and move them into standalone
			    DCAs under "user/commands.aliases/*". Migrate can take multiple files
			    at once.

			command-aliases new
			command-aliases create

			    Prompt to create new aliase, and put them under (*)

			command-aliases ensure annotated

			    Iterate all DCAs and check which ones do not contain initial
			    descriptive comments.

			OPTIONS:

			--to=<path>
			    If you are migrating a aliases of a specific type, eg. git aliases,
			    then you can specify path == "git/log", and then aliases will be
			    migrated into [commands.aliases/git/log*], so that all your logging
			    aliases are nicely put in a semantic location.

		EOF
		if [[ $# -ne 0 ]]; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# local option_args=()
	local option_action='' option_migrate_to_subdir='' option_args=()
	while [[ $# -ne 0 ]]; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--to='*) option_migrate_to_subdir="${item#*=}" ;;
		'browse') option_action="browse" ;;
		'new' | 'create') option_action="create" ;;
		'migrate') option_action="migrate" ;;
			# '--')
			#   # 	option_args+=("$item" "$@")
			#   break
			#   ;;
			#   # *) option_args+=("$item") ;;
		'--')
			option_args+=("$@")
			shift $#
			break
			;;
		*)
			help "Unknown argument was provided"
			;;
		esac
	done

	if [[ -z "$option_action" ]]; then
		# help "No action provided"
		option_action="browse"
	fi

	# =======================================================
	# HELPER

	# Ensure the path contains only valid characters
	# ( ) make standalone w/[--subpath --absolute --relative]
	function is_valid_path() {
		local input=$1
		local initial_slash="/?"
		local trailing_slash="/?"
		local special_chars_last="._-"
		# local char_classes="A-Za-z0-9"
		local char_classes="[:alpha:][:digit:]"
		local valid_chars="([$char_classes/]+)"
		local start='^'
		local end='$'
		# local regex='^(/)?([^/\0]+(/)?)+$'
		# local regex='^/?([A-Za-z0-9._-]+/?)*$'
		local regex="$start$valid_chars$end"
		if [[ ! "$input" =~ $regex ]]; then
			# echo "invalid path" >/dev/tty
			return 1
		# else
		# 	echo "valid path" >/dev/tty
		fi
	}

	# get paths of existing aliases
	function get_all_command_aliases() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		find "$USER_COMMAND_ALIASES_DIR" -type f | grep -Ev "$regex_rm_paths_with_files_extension"
	}

	function collect_existing_alias_info() {
		ALL_EXISTING_ALIAS_BASENAMES=()
		while read -r line; do
			ALL_EXISTING_ALIAS_PATHS+=("$line")
			ALL_EXISTING_ALIAS_BASENAMES+=("$(basename "$line")")
		done < <(echo-lines -- "$(get_all_command_aliases)" | echo-trim-empty-lines --stdin)
	}

	function add_command_aliases_dirs_to_path() {
		local path='' alias_dirs=()
		mapfile -t alias_dirs < <(find "$USER_COMMAND_ALIASES_DIR" -type d)
		# __print_lines "${alias_dirs[@]}"
		local path=''
		for p in "${alias_dirs[@]}"; do
			path+="$p:"
		done
		echo "$path$PATH"
		# export PATH
	}

	# if no args, then correct permissions for all alias paths
	# else, correct permissions for input <path>s
	function correct_permissions() {
	  return
		if [[ $# -eq 0 ]]; then
			local alias_paths=()
			mapfile -t alias_paths < <(get_all_command_aliases)
			fs-own --x -- "${alias_paths[@]}"
		else
			fs-own --x -- "$@" # correct permissions for inpus only
		fi
	}

	function make_destination() {
		if [[ -n "$option_migrate_to_subdir" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$option_migrate_to_subdir"
		elif [[ -n "${1-}" ]]; then
			echo "$USER_COMMAND_ALIASES_DIR/$1"
		else
			echo "$USER_COMMAND_ALIASES_DIR"
		fi

	}

	function try_create_alias_file() {
		local data=$1 destination=$2

		if ! is_unique_alias "$(basename "$destination")"; then
			echo "???"
			return 1
		fi

		if [[ ! -f "$destination" ]]; then
			: # echo "$data" >"$destination"
		else
			echo "Alias at [$(basename "$USER_COMMAND_ALIASES_DIR")/"$(basename "$destination")"] already exists!"
			return 1
		fi
	}

	# takes an array of <alias_path> <content> mappings
	function create_aliases() {
		: #
		# SINGLE
		#   create
		#   fix perms
		#     return status

		# MULT
		#   loop create mult -> if zero created return false
		#   bulk fix perms

		#   COLLECT FAILURES FOR FILES WHICH
		#     - ( ) could not be created
		#     - ( ) could not have perms corrected

	}

	# with nested alias subdirs we have to check for uniqueness
	# TODO: check if the name exists in the PATH, to prevent conflict
	# with existing commands.
	# which -a
	function is_unique_alias() {
		local alias=$1
		if is-needle "$alias" -- "${ALL_EXISTING_ALIAS_BASENAMES[@]}"; then
			echo-style --error "Alias with this name alriady exists" >/dev/tty
			return 1
		fi
		#
		#     >> [is-needle --all ...] can be used to process multiple needles.
		#     >>>>>>> use this when migrating files
		#       if is-needle --all "$@" -- "${ALL_EXISTING_ALIAS_BASENAMES[@]}"; then
		#       	return 1
		#       fi
		#     >>> but this is not good because it makes all aliases fail
	}

	# =======================================================
	# ACTIONS

	# ( ) choose
	# ( ) fuzzy-helper
	# BINDINGS
	#   ( ) create new DCA from selection.
	function act_browse() {
		local regex_rm_paths_with_files_extension='\.[^/]+$'
		local alias_paths=()
		local alias_names=()
		local alias_labels=()

		# -maxdepth 1
		mapfile -t alias_paths < <(get_all_command_aliases)
		for path in "${alias_paths[@]}"; do
			local header contents
			# ${path#*"commands.aliases"} does not work for trimming everything before
			# the match pattern. That is why the string looks a bit weird below.
			header="commands${path#*"commands"}"
			contents="$("${BAT_CMD[@]}" "$path")"
			alias_names+=("$header")
			alias_labels+=("$header"$'\n'"$contents")
		done

		__print_lines "${alias_labels[@]}"

		local index=0 choose_title="Aliases | Browser"
		while :; do
			index="$(choose "$choose_title" --default="$index" --match='$INDEX' --index -- "${alias_labels[@]}")"
			if ! confirm --ppid=$$ --positive -- "You selected alias:"$'\n'"${alias_labels[index]}"$'\n'"Prompt again?"; then
				break
			fi
		done

	}

	# Use `dorothy-new` command here later when it is finished.
	# ( ) check if name already exists. confirm...
	# ( ) if you specify a path then create sub dirs under (*)
	function act_create() {
		local name='' value=''desc='' sub_path='' confirm_final=''
		name="$(ask --linger 'Aliases create | What will the NAME be?')"
		value="$(ask --linger 'Aliases create | What will the VALUE be?')"
		desc="$(ask --linger 'Aliases create | What will the DESC be?')"

		# validate and confirm
		if confirm --ppid=$$ --negative -- 'Aliases create | Put it in sub path, eg. [commands.aliases/<my>/<dir>]?'; then
			sub_path="$(ask --linger 'Aliases create | What will the SUB PATH be?')"
			# ensure valid subpath
			while :; do
				if ! is_valid_path "$sub_path"; then
					echo "Enter invalid"
					sub_path="$(ask --linger "[$sub_path] is not valid | Input sub path again:")"
				elif ! confirm --ppid=$$ --positive -- "Are you OK with subpath: [$sub_path]"; then
					sub_path="$(ask --linger "Input subpath again:")"
				else
					echo "OK"
					break
				fi
			done
		fi

		local final=''
		final+="$SHEBANG_BASH"
		final+=$'\n'"# Name: $name"
		final+=$'\n'"# Desc: $desc"
		final+=$'\n'"$value"'"$@"'

		create_alias_at="$(make_destination "$sub_path")"

		local sub_path_question=''
		if [[ -n "$sub_path" ]]; then
			sub_path_question="/$sub_path"
		fi

		confirm_final="Aliases create | Proceed and create alias at ["$(basename "$USER_COMMAND_ALIASES_DIR")"$sub_path_question/$name]?"$'\n'
		confirm_final+="$(bat --style numbers --color always --language bash --paging=never <<<"$final")"

		if confirm --ppid=$$ --positive -- "$confirm_final"; then
			if try_create_alias_file "$final" "$create_alias_at/$name"; then
				correct_permissions "$create_alias_at/$name"
			else
				: # Failure, prompt redo process..
			fi
		else
			: # Failure, prompt redo process..
		fi
	}

	function act_migrate() {
		local migrate_aliases_to

		if [[ -n "$option_migrate_to_subdir" ]] && ! is_valid_path "$option_migrate_to_subdir"; then
			echo-style --error "Supplied invalid sub path: [$option_migrate_to_subdir]"
			exit 1
		fi

		migrate_aliases_to="$(make_destination)"

		function migrate_single_file() {
			local input_file=$1

			local output_test_string=''
			local output_name_body_mapping=()

			local interpreter=''

			interpreter="$(get-interpreter --name -- "$input_file")"
			if is-needle "$interpreter" -- "${supported[@]}"; then

				# =======================================================
				# HANDLE POSIX
				# =======================================================

				if is-needle "$interpreter" -- "${supported_posix[@]}"; then
					local aliases=() function_names=() function_bodies=()

					# ----
					# HANDLE POSIX ALIASES

					output_test_string+=$'\n###############################'
					output_test_string+=$'\n# ALIASES'
					output_test_string+=$'\n###############################'

					local alias_regex='^[[:space:]]*alias[[:space:]]+[a-zA-Z0-9_-]+='
					mapfile -t aliases < <(grep -E "$alias_regex" "$input_file" | echo-trim-each-line)
					for line_alias in "${aliases[@]}"; do
						local name='' value='' trailing_comment='' final=''
						# handle trim trailing comment
						if [[ "$line_alias" =~ ^([^\#]*)\s*#\s*(.*) ]]; then
							line_alias="${BASH_REMATCH[1]}"
							trailing_comment="${BASH_REMATCH[2]}"
						fi
						# handle split alias
						if [[ "$line_alias" =~ alias\ ([^=]+)=\"(.*)\" ]]; then
							name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						elif [[ "$line_alias" =~ alias\ ([^=]+)=\'(.*)\' ]]; then
							name="${BASH_REMATCH[1]}"
							value="${BASH_REMATCH[2]}"
						fi
						output_name_body_mapping+=("$name")
						final+="$SHEBANG_BASH"
						final+=$'\n'"# Name: $name"
						final+=$'\n'"# Desc: $trailing_comment"
						final+=$'\n'"$value "'"$@"'
						output_name_body_mapping+=("$final")
					done

					# ----
					# HANDLE POSIX FUNCTIONS

					output_test_string+=$'\n###############################'
					output_test_string+=$'\n# FUNCTIONS'
					output_test_string+=$'\n###############################'
					mapfile -t function_names < <(bash -c 'source '"$input_file"'; declare -F | awk "{print \$3}"')
					for function_name in "${function_names[@]}"; do
						local final='' body body_trimmed
						body="$(bash -c 'source '"$input_file"'; declare -f '"$function_name")"
						body_trimmed="$(__print_lines "$body" | sed '1,2d; $d' | sed 's/^    //')"
						# Capture how many arguments each func snippets takes
						# This is not perfect but at least it gives some indication.
						local arguments=()
						local count=0
						while read -r line; do
							local line="$line"
							while [[ "$line" =~ (\$[0-9]+) ]]; do
								local match="${BASH_REMATCH[0]}"
								if ! is-needle "$match" -- "${arguments[@]}"; then
									arguments+=("$match")
								fi
								line="${line/"$match"/}" # Remove the matched part from the line
								# echo "trim: [$line]"
								if [[ "$count" == 10 ]]; then
									break
								fi
							done
						done <<<"$body_trimmed"
						output_name_body_mapping+=("$function_name")
						final+="$SHEBANG_BASH"
						final+=$'\n'"# Name: $function_name"
						final+=$'\n'"# Desc: ..."
						final+=$'\n'"# Args: ${arguments[*]}"
						final+=$'\n'"$body_trimmed"
						output_name_body_mapping+=("$final")
					done

					# ----
					# loop each <name> <alias> pair
					local new_alias_paths=()
					local target_path='' target_paths=()
					for ((i = 0; i < "${#output_name_body_mapping[@]}"; i += 2)); do
						target_path="$migrate_aliases_to/${output_name_body_mapping[i]}"
						echo "$target_path"
						new_alias_paths+=("$target_path")
						bat --style numbers --color always --language bash --paging=never <<<"${output_name_body_mapping[i + 1]}"
						try_create_alias_file "${output_name_body_mapping[i + 1]}" "$target_path"
					done

					# ensure permissions
					if [[ "${#new_alias_paths[@]}" -gt 0 ]]; then
						correct_permissions "${new_alias_paths[@]}"
					fi

					# =======================================================
					# HANDLE OTHER SHELLS BELOW
					# =======================================================

				elif is-needle "$interpreter" -- "${supported_non_posix[@]}"; then

					if [[ "$interpreter" == "nu" ]]; then
						# HANDLE NUSHELL
						:
					elif [[ "$interpreter" == "elvish" ]]; then
						# HANDLE ELVISH
						:
					elif [[ "$interpreter" == "xonsh" ]]; then
						# HANDLE XONSH
						:
					fi
				else
					echo "Interpreter [$interpreter] not supported"
				fi
			fi
		}

		# remove this to make the <action> go live.
		# option_args=("$DOROTHY/user/sources/aliases.sh")
		for migrate_file in "${option_args[@]}"; do
			migrate_single_file "$migrate_file"
		done
	}

	# =======================================================
	# PREPARE

	# because we collect things here, I can clean up some redundancy below.
	collect_existing_alias_info

	# =======================================================
	# Act

	# This is a better one liner but my linter complains too much about
	# funcs being unreachable so for now i go with the switch case.
	# "act_$option_action"

	case "$option_action" in
	browse) act_browse ;;
	create) act_create ;;
	migrate) act_migrate ;;
	esac
)

# fire if invoked standalone
if [[ $0 == "${BASH_SOURCE[0]}" ]]; then
	if [[ $* == '--test' ]]; then
		command_aliases_test
	else
		command_aliases "$@"
	fi
fi
