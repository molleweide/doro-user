#!/usr/bin/env bash

# TODO: add flag for `minimal` so that one can quickly wrap scripts in the
# dorothy command pattern

# TODO: brainstorming ideas
#   ~ core/user
#       1. user is default
#       2. -[d] for core
#   ~ regular/local
#       1. regular is default
#       2. -[l] for local
#   ~ command/config
#       1. command is default
#       2. -[g] for config
#   ~ if config choose shell env
#       sh|bash|zsh|fish|nu
#       use capital letters for this.
#   ~ -E for edit the new file

#  NOTE: EXAMPLES
#   add -dg  -> add .bash config file to core
#   add -l some-file -> adds new local command to user
#   add -d some-cmd -> add new command to core
#   add -df -> add new command to core with flag-while-loop boilerplate
#   add -dfh -> add new command with help and flags boilerplate

# FIX: HOW TO SPLIT TEMPLATE INTO REUSABLE COMPONENTS
# Store the content directly in a variable without using cat or a subshell
# read -r MY_CONTENT <<EOF
# This is some text.
# You can put multiple lines here.
# EOF
# # Insert the variable into another heredoc segment with additional indentation
# cat <<EOF
# This is before the variable:
# More text here.
#     $MY_CONTENT
# This line is also indented.
# EOF

function dorothy_add_file() (
	source "$DOROTHY/sources/bash.bash"

	# =====================================
	# Help

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			  dorothy-add-file -[arstss] <filename>

			      DESCRIPTION:
			      Utility for quickly adding new files to dorothy core/user with necessary
			      boilerplate.

		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # EINVAL 22 Invalid argument
	}

	# =====================================
	# Input args

	# process
	local item new_name='' flags=''
	local is_core='no' hidden='no' is_config='no' for_shell='bash'
	local edit='no' add_help='no' add_flags='no'
	local minimal='no' complex='no'

	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'-'*)
			flags="${item#*-}"
			for ((i = 0; i < ${#flags}; i++)); do
				char="${flags:i:1}"
				case "$char" in
				c) is_core='yes' ;;    # core
				l) hidden='yes' ;;     # secret
				g) is_config='yes' ;;  # config
				S) for_shell='sh' ;;   # shell
				Z) for_shell='zsh' ;;  # shell
				F) for_shell='fish' ;; # shell
				N) for_shell='nu' ;;   # shell
				E) edit='yes' ;;       # edit
				H) add_help='yes' ;;   # add help
				A) add_flags='yes' ;;  # add args processing
				esac
			done
			;;
		*)
			if test -z "$new_name"; then
				new_name="$item"
			else
				help "An unrecognised argument was provided: $item"
			fi
			;;
		esac
	done

	function command_template() {
		local command_name="${1//-/_}"

		local eof_end_hack="EOF"

		cat <<-EOF
			#!/usr/bin/env bash

			function ${command_name}_test() (
			  source "\$DOROTHY/sources/bash.bash"
			  echo-segment --h1="TEST: \$0"
			  echo-segment --g1="TEST: \$0"
			  return 0
			)
			function $command_name() (
			  source "\$DOROTHY/sources/bash.bash"

			  function help {
			    cat <<-EOF >/dev/stderr
			      USAGE:
			        $1 ...

			      DESCRIPTION:
			        ...

			$eof_end_hack
			    if test "\$#" -ne 0; then
			    echo-error "\$@"
			    fi
			    return 22 # EINVAL 22 Invalid argument
			  }

			# =====================================
			# Args

			local item action=''
			while test "\$#" -ne 0; do
			  item="\$1"
			  shift
			  case "\$item" in
			    '--help' | '-h') help ;;
			    *)
			    if test -z "\$action"; then
				    action="\$item"
			    else
				    help "An unrecognised argument was provided: \$item"
			    fi
			    ;;
			  esac
			done

			# =====================================
			# Action

			if test -z "\$action"; then
			  help "No <new_name> provided."
			else
			  :
			fi
			)

			# fire if invoked standalone
			if test "\$0" = "\${BASH_SOURCE[0]}"; then
			  $command_name "\$@"
			fi
		EOF
	}

	function config_template() {
		cat <<-EOF
			#!/usr/bin/env bash
			# do not use \$(export) keyword in this file:
			# shellcheck disable=SC2034
		EOF
	}

	function add_help_snippet() {
		:
	}

	function add_args_snippet() {
		:
	}

	function add_new_file() {
		# echo "name:   $new_name"

		# Put together new file path destination
		local base="$DOROTHY/user"
		local sub_dir='commands'
		if test $is_core = "yes"; then
			base="$DOROTHY"
		fi
		if test $is_config = "yes"; then
			sub_dir="config"
		fi
		if test $hidden = "yes"; then
			sub_dir="$sub_dir.local"
		fi
		local final_dest="$base/$sub_dir/$new_name"

		# echo "dest: $final_dest"

		# Make sure we don't override an existing file
		if [ -e "$final_dest" ]; then
			echo "The file [$final_dest] already exists."
			return 0
		fi

		# Put together file template
		if test $is_config = 'yes'; then
			config_template >"$final_dest"
		else
			command_template "$new_name" >"$final_dest"
		fi

		chmod +x "$final_dest"

		echo "$final_dest"
	}

	# =====================================
	# Action

	if test -z "$new_name"; then
		help "No <new_name> provided."
	else
		add_new_file
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	dorothy_add_file "$@"
fi
