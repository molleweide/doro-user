#!/usr/bin/env bash

# NOTE: Consult these docs for a more in depth understanding concepts:
# https://www.gnu.org/software/libc/manual/html_node/index.html#SEC_Contents

# TODO: use `eval-helper --wrap --no-quiet --`

# NOTE: file descriptors
# https://stackoverflow.com/questions/5256599/what-are-file-descriptors-explained-in-simple-termse

# TODO: Watch and re-run on test changes
# https://unix.stackexchange.com/questions/287230/bash-script-to-check-if-a-file-is-modified-or-not
# pure bash file modified detection: https://unix.stackexchange.com/a/287615/390747
# https://superuser.com/questions/181517/how-to-execute-a-command-whenever-a-file-changes
# https://github.com/eradman/entr

# NOTE: keybinds / there are some existing epic keybinds for bash/shell

function bash_playground() (
  source "$DOROTHY/sources/bash.bash"

  # ===========================================================================
  # VARS

  # Try to keep this as close to man page chapters as possible?
  local BASH_MAN_PAGE_CHAPTERS=(
    "SHELL GRAMMAR"
    "PARAMETERS"
    "JOB CONTROL"
  )

  # ===========================================================================
  # HELPERS
  # Put stuff here that aids in the demoing of all chapter examples below.
  #

  # ===========================================================================
  # ACT / CHAPTERS
  #

  # ===================================
  # CHAPTER 1 SHELL GRAMMAR
  #
  chapter__shell_grammar() {
    echo-style --h1="SHELL GRAMMAR"

    echo-style --h2="PIPELINES"

    # TODO: demo everything below here.

    # A pipeline is a sequence of one or more commands separated by one of the control operators | or
    # |&.  The format for a pipeline is:
    #
    #        [time [-p]] [ ! ] command1 [ [|âŽª|&] command2 ... ]
    #
    # The standard output of command1 is connected via a pipe to the standard input of command2.  This
    # connection is performed before any redirections specified by the command1(see REDIRECTION below).
    # If |& is used, command1's standard error, in addition to its standard output, is connected to
    # command2's standard input through the pipe; it is shorthand for 2>&1 |.  This implicit
    # redirection of the standard error to the standard output is performed after any redirections
    # specified by command1.
    #
    # The return status of a pipeline is the exit status of the last command, unless the pipefail
    # option is enabled.  If pipefail is enabled, the pipeline's return status is the value of the last
    # (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully.
    # If the reserved word !  precedes a pipeline, the exit status of that pipeline is the logical
    # negation of the exit status as described above.  The shell waits for all commands in the pipeline
    # to terminate before returning a value.
    #
    # If the time reserved word precedes a pipeline, the elapsed as well as user and system time
    # consumed by its execution are reported when the pipeline terminates.  The -p option changes the
    # output format to that specified by POSIX.  When the shell is in posix mode, it does not recognize
    # time as a reserved word if the next token begins with a `-'.  The TIMEFORMAT variable may be set
    # to a format string that specifies how the timing information should be displayed; see the
    # description of TIMEFORMAT under Shell Variables below.
    #
    # When the shell is in posix mode, time may be followed by a newline.  In this case, the shell
    # displays the total user and system time consumed by the shell and its children.  The TIMEFORMAT
    # variable may be used to specify the format of the time information.
    #
    # Each command in a multi-command pipeline, where pipes are created, is executed in a subshell,
    # which is a separate process.  See COMMAND EXECUTION ENVIRONMENT for a description of subshells
    # and a subshell environment.  If the lastpipe option is enabled using the shopt builtin (see the
    # description of shopt below), the last element of a pipeline may be run by the shell process when
    # job control is not active.

    echo-style --h2="COMPOUND COMMANDS"

    # https://stackoverflow.com/questions/29261297/parenthesis-in-bash-subshell-vs-grouping
    # https://stackoverflow.com/questions/46092962/what-is-the-right-way-to-do-command-grouping-in-bash
    # https://unix.stackexchange.com/questions/127334/bash-subshell-creation-with-curly-braces
    # https://stackoverflow.com/questions/21246552/bash-command-groups-why-do-curly-braces-require-a-semicolon?rq=3
    # https://unix.stackexchange.com/questions/421020/what-is-the-exact-difference-between-a-subshell-and-a-child-process
    # https://unix.stackexchange.com/questions/138463/do-parentheses-really-put-the-command-in-a-subshell?noredirect=1&lq=1
    # https://unix.stackexchange.com/questions/524506/how-can-i-detect-if-im-in-a-subshell?noredirect=1&lq=1

    # NOTE: list / parentheses.
    # (list)

    (
      local list_x="xxx"
      echo "hello from (list)"
    )
    echo "(list) variable out side = [${list_x-}]"

    # NOTE: list / curly braces
    # {list}

    {
      local list_y="yyy"
      echo "hello from {list}"
    }
    echo "{list} variable out side = [${list_y-}]"

    # ((expr))
    local expr=$((1 + 1))
    echo "status of 1+1 = $expr: $?" # NOTE: This should be 1 according to manual on ((expression))
    local expr=$((1 - 1))
    echo "status of 1-1 = $expr: $?"

    # [[expression]]

    local string="Hello World"
    local pattern='(H[a-z]+)[[:space:]]*(W[a-z]+)'
    if [[ $string =~ $pattern ]]; then
      echo "Match found!"
      for i in "${!BASH_REMATCH[@]}"; do
        echo "$i: ${BASH_REMATCH[$i]}"
      done
    else
      echo "no match"
    fi
    if [[ "example@domain.com" =~ ([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,}) ]]; then
      echo "User: ${BASH_REMATCH[1]}"   # Prints the username
      echo "Domain: ${BASH_REMATCH[2]}" # Prints the domain
    fi

    # for name [ [ in [ word ... ] ] ; ] do list ; done

    # NOTE: if in word is ommitted then the list is executed once for each element in name

    # for path in "${option_paths[@]}"; do
    #   # ...
    # done

    # for (( expr1 ; expr2 ; expr3 )) ; do list ; done
    # for ((i = 0; i < ${#line}; i++)); do
    # 	if test "${line:i:1}" = '='; then
    # 		inherited+=("${line:0:i}") # name
    # 		inherited+=("${line:i+1}") # value
    # 		break
    # 	fi
    # done

    # select name [ in word ] ; do list ; done
    #
    # This allows for making very basic shitty menus
    #
    # select word in apple orange pear banana; do
    #     echo $word;
    # done
    # echo "reply = $REPLY"

    # case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac

    #
    # Coprocesses
    #

    # RECOMMENDED FORM:
    # coproc NAME { command [redirections]; }

    # The process id is NAME_PID for the spawned process.

    # https://www.geeksforgeeks.org/coproc-command-in-linux-with-examples/

    # The process id

    #
    # Shell Function Definitions
    #

    # This section in the man page is a bit incoherent. it says

    # not working..
    # fn_expr() [[ "aaa" == "aaa" ]]

    # This did not work
    # fn_expr () (( 1 + 1))
    # local e=$(fn_expr)
    # echo "e = $e"
  }

  # ===================================
  # CHAPTER 2 QUOTING
  #
  chapter__quoting() {
    echo-style --h1="QUOTING & ESCAPE CHARS"

    # Quoting is used to remove the special meaning of certain characters or words to the shell.
    # Quoting can be used to disable special treatment for special characters, to prevent reserved
    # words from being recognized as such, and to prevent parameter expansion.
    #
    # Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and
    # must be quoted if it is to represent itself.
    #
    # When the command history expansion facilities are being used (see HISTORY EXPANSION below), the
    # history expansion character, usually !, must be quoted to prevent history expansion.
    #
    # There are three quoting mechanisms: the escape character, single quotes, and double quotes.
    #
    # A non-quoted backslash (\) is the escape character.  It preserves the literal value of the next
    # character that follows, with the exception of <newline>.  If a \<newline> pair appears, and the
    # backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is
    # removed from the input stream and effectively ignored).
    #
    # Enclosing characters in single quotes preserves the literal value of each character within the
    # quotes.  A single quote may not occur between single quotes, even when preceded by a backslash.
    #
    # Enclosing characters in double quotes preserves the literal value of all characters within the
    # quotes, with the exception of $, `, \, and, when history expansion is enabled, !.  When the shell
    # is in posix mode, the ! has no special meaning within double quotes, even when history expansion
    # is enabled.  The characters $ and ` retain their special meaning within double quotes.  The
    # backslash retains its special meaning only when followed by one of the following characters: $,
    # `, ", \, or <newline>.  A double quote may be quoted within double quotes by preceding it with a
    # backslash.  If enabled, history expansion will be performed unless an !  appearing in double
    # quotes is escaped using a backslash.  The backslash preceding the !  is not removed.
    #
    # The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below).
    #
    # Character sequences of the form $'string' are treated as a special variant of single quotes.  The
    # sequence expands to string, with backslash-escaped characters in string replaced as specified by
    # the ANSI C standard.  Backslash escape sequences, if present, are decoded as follows:
    #        \a     alert (bell)
    #        \b     backspace
    #        \e
    #        \E     an escape character
    #        \f     form feed
    #        \n     new line
    #        \r     carriage return
    #        \t     horizontal tab
    #        \v     vertical tab
    #        \\     backslash
    #        \'     single quote
    #        \"     double quote
    #        \?     question mark
    #        \nnn   the eight-bit character whose value is the octal value nnn (one to three octal
    #               digits)
    #        \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex
    #               digits)
    #        \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH
    #               (one to four hex digits)
    #        \UHHHHHHHH
    #               the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH
    #               (one to eight hex digits)
    #        \cx    a control-x character
    #
    # The expanded result is single-quoted, as if the dollar sign had not been present.
    #
    # A double-quoted string preceded by a dollar sign ($"string") will cause the string to be
    # translated according to the current locale.  The gettext infrastructure performs the lookup and
    # translation, using the LC_MESSAGES, TEXTDOMAINDIR, and TEXTDOMAIN shell variables.  If the
    # current locale is C or POSIX, if there are no translations available, or if the string is not
    # translated, the dollar sign is ignored.  This is a form of double quoting, so the string remains
    # double-quoted by default, whether or not it is translated and replaced.  If the
    # noexpand_translation option is enabled using the shopt builtin, translated strings are single-
    # quoted instead of double-quoted.  See the description of shopt below under SHELLBUILTINCOMMANDS.

    __print_lines $'\aXrst \bFFF'
    __print_lines $'\eeeeee\Eaa\r'

  }

  #
  # CHAPTER 3 PARAMETERS
  #
  chapter__parameters() {
    echo-style --h1="PARAMETERS"
    echo-style --h2="PARAMETERS -> SHELL VARIABLES"

    # `$0` â€“ The name of the script being executed.
    # `$1-$9` â€“ The first nine command-line arguments.
    # `$#` â€“ The number of command-line arguments.
    # `$*` â€“ All command-line arguments as a single string.
    # `$@` â€“ All command-line arguments as an array.
    # `$?` â€“ The exit status of the last executed command.
    # `$$` â€“ The process ID of the current shell.
    # `$!` â€“ The process ID of the last background command.

    # there are a shit tone of shell variables

    echo "\$\- = $-"
    echo "\$0 = $0"

    echo "BASH = $BASH"

    echo "BASHOPTS (including enabled by dorothy):"
    #   echo "$BASHOPTS" | while IFS=':' read -r o; do
    # echo $'\t'"$o"
    # done
    IFS=':'
    for option in $BASHOPTS; do
      echo $'\t'"$option"
    done
    unset IFS

    # echo "\$! (most recent bkg job) = ${!-unset}"

    declare -i myvarx=1 myvary=1
    addto() {
      # the indirect reference to $1 allows us to manipulate the variable inside of
      # the function
      declare -n ref=$1
      local hmmm=$2
      ref+=1
      hmmm+=1
    }
    addto myvarx myvary
    myvary+=1
    echo "$myvarx $myvary"
    echo "\$\$ = $$"
    func1() {
      echo "func1(){} \$\$ = $$"
    }
    func2() (
      echo "func2()() \$\$ = $$"
    )
    func1
    func2
    local x=$(func1 >/dev/tty)
    local y=$(func2 >/dev/tty)

    # BASH_ARGC ????
    # BASH_ARGV ????

    echo "BASH_ARGV0 = $BASH_ARGV0"
    echo "BASH_CMDS: ???????"
    echo "${BASH_CMDS[@]}"

    echo "BASH_COMMAND = $BASH_COMMAND"

    echo "MAIL_PATH = ${MAIL_PATH-}"

    echo "PS1 = ${PS1-}"
    echo "PS2 = ${PS2-}"
    echo "PS3 = ${PS3-}"
    echo "PS4 = ${PS4-}"

    #############################################################################
    echo-style --h2="PARAMETERS -> ARRAYS"

    local fruits=(apple pear banana)
    echo "all fruits with \${fruits[@]}"
    echo "${fruits[@]}"
    echo "and now with * and IFS=','"
    IFS=,
    echo "${fruits[*]}"
    unset IFS
  }

  #
  #
  #
  chapter__parameter_expansion() {
    echo-style --h1="PARAMETER EXPANSION"

    echo-style --notice="There are 7 types of expansion:"$'\n' \
      --red "brace expansion"$'\n' \
      --blue "tilde expansion"$'\n' \
      --green "param/var expansion"$'\n' \
      --yellow "command substitution"$'\n' \
      --magenta "arithmetic expansion"$'\n' \
      --cyan "word splitting"$'\n' \
      --puple "pathname expansion"

    echo-style --h2="BRACE {} EXPANSION"

    echo "a{A..E} ->" a{A..E}
    echo "good for paths:"
    echo "some/path/{aaa,bbb} ->" some/path/{aaa,bbb}
    echo /usr/local/src/bash/{old,new,dist,bugs}
    echo /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}

    echo-style --h2="TILDE (~) EXPANSION"

    # https://linuxsimply.com/bash-scripting-tutorial/expansion/tilde-expansion/

    echo ~  # possible login name -> fallback to $HOME -> home of user executing.
    echo ~+ # PWS
    echo ~- # OLDPWD
    echo ~2+
    echo ~3-

    echo-style --h2="PARAMETER EXPANSION"

    local zz
    local xx=yy
    yy=zz
    zz=22
    # here !xx will print zz
    echo "${xx}; ${yy}; ${!xx}"

    local NAME="VARIABLE"
    local VARIABLE=42
    echo "NAME=${!NAME}"

    echo "\${custom:-default(xxxx)} = ${arst:-xxxx}"
    local adg
    echo "\${adg(null):=assign_default} = ${adg:=xxxx}"
    echo "adg = $adg (now having been assigned above)"
    # echo "\${param:?error_if_unset} = ${aaaaa:?throw error 1 aaa hasnt been set}"
    echo "\${param:+use this if param IS set}"

    local str="abcde"
    echo "\${abcde:1:3} -> ${str:1:3}"

    echo-style --notice "> "

    local test_a=1984
    local test_b=9652

    (
      IFS=":"
      echo "\${!test_*} = ${!test_*}"
      echo "\${!test_@} = ${!test_@}"
      # ${!prefix@}
    )
    echo "\${!fruits[@]} -> ${!fruits[*]}" # -> 0 1 2
    echo "length of fruits \${#fruits} = ${#fruits}"

    # ???????????????
    # ${parameter#word}
    # ${parameter##word}

    echo-style --notice "> # and % can be used to remove mathing prefix/suffix:"

    local prefix="hell"
    local suffix="ld"
    local string="hello-world"
    local strings=("a_test" "b_test" "c_test")
    local foo=${string#"$prefix"}
    local foo2=${foo%"$suffix"}
    echo "string = [hello world]"
    echo "\${string#\"\$prefix\"} -> $foo"
    echo "\${string%\"\$suffix\"} -> $foo2"
    echo "${foo2}"

    echo "strings=${strings[*]}"
    echo "\${strings[@]%\"_test\"} -> ${strings[*]%_test}"

    echo-style --notice "Param find and replace with \${param/?{/,#,%}pattern/replacement}"
    local parm="this is a param string"
    echo "parm:[$parm]; \${parm/string/xxxx} -> ${parm/string/xxxx}"

    echo-style --notice ">Change care with ^ ^^ , ,,"
    local t="my_test_string"
    local T="MY_TEST_STRING"
    echo "t = $t; T = $T"
    echo "\${t^} -> ${t^}"
    echo "\${t^^} -> ${t^^}"
    echo "\${T,} -> ${T,}"
    echo "\${T,,} -> ${T,,}"

    echo-style --notice "Parameter transformation with \${param@operator}"
    echo-quote "The expansion is either a transformation of the value of parameter or information about parameter itself, depending on the value of operator."

    # TODO: !!!!

    local op_string="/dir/dir/^my_testing_string_123_blaah!!"
    echo "op_string=$op_string"

    # U      The expansion is a string that is the value of parameter with lowercase alphabetic
    #        characters converted to uppercase.
    echo "Convert lowercase chars to upper: \${op_string@U} -> ${op_string@U}"

    # u      The expansion is a string that is the value of parameter with the first character
    #        converted to uppercase, if it is alphabetic.
    echo "Convert first char to upper: \${op_string@u} -> ${op_string@u}"
    echo "^^^ @u does not do anything if the string does NOT start with an alpha char."

    # L      The expansion is a string that is the value of parameter with uppercase alphabetic
    #        characters converted to lowercase.
    local op_string_2="'ABCDE'"
    echo "op_string_2=$op_string_2"
    echo "Convert all alpha to lowercase: \${op_string_2@L} -> ${op_string_2@L}"

    # Q      The expansion is a string that is the value of parameter quoted in a format that
    #        can be reused as input.
    echo "Quote for reusable input: \${op_string_2@Q} -> ${op_string_2@Q}"
    echo "^^^Notice how it surrounds param string with lots of stuff to ensure proper quotes"

    local op_string_3="aaa\nbbb"
    echo "op_string_3=$op_string_3"

    # E      The expansion is a string that is the value of parameter with backslash escape
    #        sequences expanded as with the $'...' quoting mechanism.
    echo "Expand escape chars into $'...': \${op_string_3@E} -> ${op_string_3@E}"

    # P      The expansion is a string that is the result of expanding the value of parameter as
    #        if it were a prompt string (see PROMPTING below).
    echo "Expand as prompt string: \${op_string_3@P} -> ${op_string_3@P}"

    # A      The expansion is a string in the form of an assignment statement or declare command
    #        that, if evaluated, will recreate parameter with its attributes and value.
    echo "Backwards assignment statement with @A:Fruits (with @A): ${fruits[*]@A}"
    echo "Dunno what this is useful for??"

    # K      Produces a possibly-quoted version of the value of parameter, except that it prints
    #        the values of indexed and associative arrays as a sequence of quoted key-value
    #        pairs (see Arrays above).
    echo "Quoting with K: \${op_string_2@K} -> ${op_string_2@K}"
    echo "Quoting with K: \${fruits[*]@K} -> ${fruits[*]@K}"

    # a      The expansion is a string consisting of flag values representing parameter's
    #        attributes.
    echo-style --red "@a prints the attributes of param"
    echo "Expansion with 'a': \${fruits[*]@a} -> ${fruits[*]@a}"
    declare -A assoc=([a]="alpha" [b]="beta")
    echo "Expansion with 'a': \${assoc@a} -> ${assoc@a}"

    # k      Like the K transformation, but expands the keys and values of indexed and
    #        associative arrays to separate words after word splitting.
    local fruits_2=("apple" "big banana" "gigantic pineapple")

    # NOTE:the following echoes break auto formatting
    #
    # echo "Quoting with K: \${fruits_2[*]@K} -> ${fruits_2[*]@K}"
    # echo "Quoting with k: \${fruits_2[*]@k} -> ${fruits_2[*]@k}"

    echo-style --red "^^ Notice that 'k' word split each fruit in fruits_2"

    echo-style --h2="COMMAND SUBSTITUTION"
    # Command substitution allows the output of a command to replace the command name.  There are two
    # forms:

    local cmd_sub1 cmd_sub2 nested
    cmd_sub1=$(echo "something"$'\n\n\n\n')

    __print_lines $cmd_sub1

    # Bash performs the expansion by executing command in a subshell environment and replacing the
    # command substitution with the standard output of the command, with any trailing newlines deleted.
    echo "----- (see how trailing new line is removed from prev output...)"

    # cmd_sub2=$(echo "aaaaa bbbb")

    # Embedded newlines are not deleted, but they may be removed during word splitting.  The command
    # substitution $(cat file) can be replaced by the equivalent but faster $(< file).

    # TODO: time both cat and < to see which is faster.

    # When the old-style backquote form of substitution is used, backslash retains its literal meaning
    # except when followed by $, `, or \.  The first backquote not preceded by a backslash terminates
    # the command substitution.  When using the $(command) form, all characters between the parentheses
    # make up the command; none are treated specially.

    # Command substitutions may be nested.  To nest when using the backquoted form, escape the inner
    # backquotes with backslashes.
    # TODO: nested
    # Eg. do wordcount on a process stdout that comes from another stdout.
    # nested=$( $())

    # If the substitution appears within double quotes, word splitting and pathname expansion are not
    # performed on the results.
    local cmd_sub_split cmd_sub_quoted
    cmd_sub_split=$()
    cmd_sub_quoted="$()"
    # TODO: show difference between split and not.

    echo-style --h2="ARITHMETIC EXPANSION (not much to see here..)"

    echo-style --h2="PROCESS SUBSTITUTION"

    # TODO: demo all these nice examples.
    # https://tecadmin.net/bash-process-substitution/
    # https://unix.stackexchange.com/questions/17107/process-substitution-and-pipe
    # https://unix.stackexchange.com/questions/640206/understanding-the-process-substitution-concept
    # https://stackoverflow.com/questions/51293767/what-is-the-difference-between-using-process-substitution-vs-a-pipe
    # https://unix.stackexchange.com/questions/393349/difference-between-subshells-and-process-substitution

    # Process substitution allows a process's input or output to be referred to using a filename.  It
    # takes the form of <(list) or >(list).  The process list is run asynchronously, and its input or
    # output appears as a filename.  This filename is passed as an argument to the current command as
    # the result of the expansion.  If the >(list) form is used, writing to the file will provide input
    # for list.  If the <(list) form is used, the file passed as an argument should be read to obtain
    # the output of list.  Process substitution is supported on systems that support named pipes
    # (FIFOs) or the /dev/fd method of naming open files.
    #
    # When available, process substitution is performed simultaneously with parameter and variable
    # expansion, command substitution, and arithmetic expansion.

    echo-style --h2="WORD SPLITTING"

    # TODO: show how trailing new lines are trimmed
    # TODO: what is embedded new lines?

    # The shell scans the results of parameter expansion, command substitution, and arithmetic
    # expansion that did not occur within double quotes for word splitting.

    # The shell treats each character of IFS as a delimiter, and splits the results of the other
    # expansions into words using these characters as field terminators.  If IFS is unset, or its value
    # is exactly <space><tab><newline>, the default, then sequences of <space>, <tab>, and <newline> at
    # the beginning and end of the results of the previous expansions are ignored, and any sequence of
    # IFS characters not at the beginning or end serves to delimit words.
    local ws1=~/some/path
    local ws2="    word_w_whitespace_on_both_sides    "
    local ws3="  :words:separated :by: colon:    "

    echo "\"\$ws1\" (quoted) -> $ws1"
    echo "\$ws1 (unquoted)   -> "$ws1

    echo "\"\$ws2\" (quoted) -> $ws2"
    echo "\$ws2 (unquoted)   -> "$ws2

    # If IFS has a value other
    # than the default, then sequences of the whitespace characters space, tab, and newline are ignored
    # at the beginning and end of the word, as long as the whitespace character is in the value of IFS
    # (an IFS whitespace character).  Any character in IFS that is not IFS whitespace, along with any
    # adjacent IFS whitespace characters, delimits a field.  A sequence of IFS whitespace characters is
    # also treated as a delimiter.  If the value of IFS is null, no word splitting occurs.

    echo "\"\$ws3\" (quoted) -> $ws3"
    IFS=':'
    echo "( setting IFT=':' )"
    echo "\$ws3 (unquoted)   -> "$ws3
    echo "Notice, w custom IFS, that now the surrounding whitespace did not get removed."
    unset IFS

    # Explicit null arguments ("" or '') are retained and passed to commands as empty strings.

    # TODO: demo this!!!
    #
    # Unquoted implicit null arguments, resulting from the expansion of parameters that have no values,
    # are removed.

    # TODO: demo this!!!
    #
    # If a parameter with no value is expanded within double quotes, a null argument
    # results and is retained and passed to a command as an empty string.

    # TODO: demo this!!!
    #
    # When a quoted null argument
    # appears as part of a word whose expansion is non-null, the null argument is removed.  That is,
    # the word -d'' becomes -d after word splitting and null argument removal.
    #
    # Note that if no expansion occurs, no splitting is performed.

    echo-style --h2="PATHNAME EXPANSION"

    # After word splitting, unless the -f option has been set, bash scans each word for the characters
    # *, ?, and [.

    # TODO: demo this
    #
    # If one of these characters appears, and is not quoted, then the word is regarded as
    # a pattern, and replaced with an alphabetically sorted list of filenames matching the pattern (see
    # Pattern Matching below).

    # TODO: demo this
    #
    # If no matching filenames are found, and the shell option nullglob is
    # not enabled, the word is left unchanged.

    # TODO: demo this
    #
    # If the nullglob option is set, and no matches are
    # found, the word is removed.

    # TODO: demo this
    #
    # If the failglob shell option is set, and no matches are found, an
    # error message is printed and the command is not executed.

    # TODO: demo this
    #
    # If the shell option nocaseglob is
    # enabled, the match is performed without regard to the case of alphabetic characters.

    # TODO: demo this
    #
    # When a
    # pattern is used for pathname expansion, the character ``.'' at the start of a name or immediately
    # following a slash must be matched explicitly, unless the shell option dotglob is set.

    # TODO: demo this
    #
    # In order
    # to match the filenames ``.'' and ``..'', the pattern must begin with ``.'' (for example, ``.?''),
    # even if dotglob is set.

    # TODO: demo this
    #
    # If the globskipdots shell option is enabled, the filenames ``.'' and
    # ``..'' are never matched, even if the pattern begins with a ``.''.

    # TODO: demo this
    #
    # When not matching pathnames,
    # the ``.'' character is not treated specially.

    # TODO: demo this
    #
    # When matching a pathname, the slash character must
    # always be matched explicitly by a slash in the pattern, but in other matching contexts it can be
    # matched by a special pattern character as described below under Pattern Matching.

    # TODO: Put a note under these that sais these are demoed in the path expansion
    # section.
    #
    # See the
    # description of shopt below under SHELL BUILTIN COMMANDS for a description of the nocaseglob,
    # nullglob, globskipdots, failglob, and dotglob shell options.

    # TODO: demo this.
    #
    # The GLOBIGNORE shell variable may be used to restrict the set of file names matching a pattern.
    # If GLOBIGNORE is set, each matching file name that also matches one of the patterns in GLOBIGNORE
    # is removed from the list of matches.

    # TODO: demo this.
    #
    # If the nocaseglob option is set, the matching against the
    # patterns in GLOBIGNORE is performed without regard to case.

    # TODO: demo this.
    #
    # The filenames ``.'' and ``..'' are
    # always ignored when GLOBIGNORE is set and not null.

    # TODO: demo this.
    #
    # However, setting GLOBIGNORE to a non-null
    # value has the effect of enabling the dotglob shell option, so all other filenames beginning with
    # a ``.'' will match.

    # TODO: demo this.
    #
    # To get the old behavior of ignoring filenames beginning with a ``.'', make
    # ``.*'' one of the patterns in GLOBIGNORE.

    # The dotglob option is disabled when GLOBIGNORE is
    # unset.

    # TODO: demo this.
    #
    # The pattern matching honors the setting of the extglob shell option.

    echo-style --h3="Pattern Matching"
    echo-style --notice="This comes as a subsection to Path Expansion in Man pages."

    # Any character that appears in a pattern, other than the special pattern characters described
    # below, matches itself.  The NUL character may not occur in a pattern.  A backslash escapes the
    # following character; the escaping backslash is discarded when matching.  The special pattern
    # characters must be quoted if they are to be matched literally.
    #
    # The special pattern characters have the following meanings:

    #         *      Matches any string, including the null string.  When the globstar shell option is
    #               enabled, and * is used in a pathname expansion context, two adjacent *s used as a
    #               single pattern will match all files and zero or more directories and
    #               subdirectories.  If followed by a /, two adjacent *s will match only directories
    #               and subdirectories.
    #        ?      Matches any single character.
    #        [...]  Matches any one of the enclosed characters.  A pair of characters separated by a
    #               hyphen denotes a range expression; any character that falls between those two
    #               characters, inclusive, using the current locale's collating sequence and character
    #               set, is matched.  If the first character following the [ is a !  or a ^ then any
    #               character not enclosed is matched.  The sorting order of characters in range
    #               expressions, and the characters included in the range, are determined by the
    #               current locale and the values of the LC_COLLATE or LC_ALL shell variables, if set.
    #               To obtain the traditional interpretation of range expressions, where [a-d] is
    #               equivalent to [abcd], set value of the LC_ALL shell variable to C, or enable the
    #               globasciiranges shell option.  A - may be matched by including it as the first or
    #               last character in the set.  A ] may be matched by including it as the first
    #               character in the set.
    #
    #               Within [ and ], character classes can be specified using the syntax [:class:],
    #               where class is one of the following classes defined in the POSIX standard:
    #               alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit
    #               A character class matches any character belonging to that class.  The word
    #               character class matches letters, digits, and the character _.
    #
    #               Within [ and ], an equivalence class can be specified using the syntax [=c=], which
    #               matches all characters with the same collation weight (as defined by the current
    #               locale) as the character c.
    #
    #               Within [ and ], the syntax [.symbol.] matches the collating symbol symbol.
    #
    # If the extglob shell option is enabled using the shopt builtin, the shell recognizes several
    # extended pattern matching operators.  In the following description, a pattern-list is a list of
    # one or more patterns separated by a |.  Composite patterns may be formed using one or more of the
    # following sub-patterns:
    #
    #        ?(pattern-list)
    #               Matches zero or one occurrence of the given patterns
    #        *(pattern-list)
    #               Matches zero or more occurrences of the given patterns
    #        +(pattern-list)
    #               Matches one or more occurrences of the given patterns
    #        @(pattern-list)
    #               Matches one of the given patterns
    #        !(pattern-list)
    #               Matches anything except one of the given patterns

    #     Theextglob option changes the behavior of the parser, since the parentheses are normally treated
    #     as operators with syntactic meaning.  To ensure that extended matching patterns are parsed
    #     correctly, make sure that extglob is enabled before parsing constructs containing the patterns,
    #     including shell functions and command substitutions.
    #
    #     When matching filenames, the dotglob shell option determines the set of filenames that are
    #     tested: when dotglob is enabled, the set of filenames includes all files beginning with ``.'',
    #     but ``.'' and ``..'' must be matched by a pattern or sub-pattern that begins with a dot; when it
    #     is disabled, the set does not include any filenames beginning with ``.'' unless the pattern or
    #     sub-pattern begins with a ``.''.  As above, ``.'' only has a special meaning when matching
    #     filenames.
    #
    #     Complicated extended pattern matching against long strings is slow, especially when the patterns
    #     contain alternations and the strings contain multiple matches.  Using separate matches against
    #     shorter strings, or using arrays of strings instead of a single long string, may be faster.
    #
    # Quote Removal
    #     After the preceding expansions, all unquoted occurrences of the characters \, ', and " that did
    #     not result from one of the above expansions are removed.

  }

  #
  #
  #
  chapter__redirection() {
    echo-style --h1="REDIRECTION"

    # Before a command is executed, its input and output may be redirected using a special notation
    # interpreted by the shell.  Redirection allows commands' file handles to be duplicated, opened,
    # closed, made to refer to different files, and can change the files the command reads from and
    # writes to.  Redirection may also be used to modify file handles in the current shell execution
    # environment.  The following redirection operators may precede or appear anywhere within a simple
    # command or may follow a command.  Redirections are processed in the order they appear, from left
    # to right.
    #
    # Each redirection that may be preceded by a file descriptor number may instead be preceded by a
    # word of the form {varname}.  In this case, for each redirection operator except >&- and <&-, the
    # shell will allocate a file descriptor greater than or equal to 10 and assign it to varname.  If
    # >&- or <&- is preceded by {varname}, the value of varname defines the file descriptor to close.
    # If {varname} is supplied, the redirection persists beyond the scope of the command, allowing the
    # shell programmer to manage the file descriptor's lifetime manually.  The varredir_close shell
    # option manages this behavior.
    #
    # In the following descriptions, if the file descriptor number is omitted, and the first character
    # of the redirection operator is <, the redirection refers to the standard input (file descriptor
    # 0).  If the first character of the redirection operator is >, the redirection refers to the
    # standard output (file descriptor 1).
    #
    # The word following the redirection operator in the following descriptions, unless otherwise
    # noted, is subjected to brace expansion, tilde expansion, parameter and variable expansion,
    # command substitution, arithmetic expansion, quote removal, pathname expansion, and word
    # splitting.  If it expands to more than one word, bash reports an error.
    #
    # Note that the order of redirections is significant.  For example, the command
    #
    #        ls > dirlist 2>&1
    #
    # directs both standard output and standard error to the file dirlist, while the command
    #
    #        ls 2>&1 > dirlist
    #
    # directs only the standard output to file dirlist, because the standard error was duplicated from
    # the standard output before the standard output was redirected to dirlist.
    #
    # Bash handles several filenames specially when they are used in redirections, as described in the
    # following table.  If the operating system on which bash is running provides these special files,
    # bash will use them; otherwise it will emulate them internally with the behavior described below.

    #        /dev/fd/fd
    #               If fd is a valid integer, file descriptor fd is duplicated.
    #        /dev/stdin
    #               File descriptor 0 is duplicated.
    #        /dev/stdout
    #               File descriptor 1 is duplicated.
    #        /dev/stderr
    #               File descriptor 2 is duplicated.
    #        /dev/tcp/host/port
    #               If host is a valid hostname or Internet address, and port is an integer port number
    #               or service name, bash attempts to open the corresponding TCP socket.
    #        /dev/udp/host/port
    #               If host is a valid hostname or Internet address, and port is an integer port number
    #               or service name, bash attempts to open the corresponding UDP socket.
    #
    # A failure to open or create a file causes the redirection to fail.
    #
    # Redirections using file descriptors greater than 9 should be used with care, as they may conflict
    # with file descriptors the shell uses internally.

    echo-style --h2="Redirecting Input"
    # echo-style --h2="Redirecting Output"
    # echo-style --h2="Appending Output"
    # echo-style --h2="Redirecting stdout and sderr"
    # echo-style --h2="Appending stdout and sderr"
    # echo-style --h2="Here Documents"
    # echo-style --h2="Here Strings"
    # echo-style --h2="Duplicating file descriptors"
    # echo-style --h2="moving file descriptors"
    # echo-style --h2="opening file descriptors for read/write"
  }

  #
  #
  #
  chapter__aliases() {
    echo-style --h1="ALIASES"
  }

  #
  #
  #
  chapter__functions() {
    echo-style --h1="FUNCTIONS"
  }

  #
  #
  #
  chapter__arithmetic_evaluation() {
    echo-style --h1="ARITHMETIC EVALUATION"
  }

  #
  #
  #
  chapter__conditional_expressions() {
    echo-style --h1="CONDITIONAL EXPRESSIONS"
    # QUIRKS
    # https://stackoverflow.com/questions/669452/are-double-square-brackets-preferable-over-single-square-brackets-in-b

    # look at `debug-terminal-stdin` for some good examples of how to debug
    # the environment with conditionals.

    # https://stackoverflow.com/questions/2188199/how-to-use-double-or-single-brackets-parentheses-curly-braces

    # NOTE: what is the difference btw = and ==

    # ----

    # Conditional expressions are used by the [[ compound command and the test and [ builtin commands
    # to test file attributes and perform string and arithmetic comparisons.  The test and [ commands
    # determine their behavior based on the number of arguments; see the descriptions of those commands
    # for any other command-specific actions.
    #
    # Expressions are formed from the following unary or binary primaries.  Bash handles several
    # filenames specially when they are used in expressions.  If the operating system on which bash is
    # running provides these special files, bash will use them; otherwise it will emulate them
    # internally with this behavior: If any file argument to one of the primaries is of the form
    # /dev/fd/n, then file descriptor n is checked.  If the file argument to one of the primaries is
    # one of /dev/stdin, /dev/stdout, or /dev/stderr, file descriptor 0, 1, or 2, respectively, is
    # checked.
    #
    # Unless otherwise specified, primaries that operate on files follow symbolic links and operate on
    # the target of the link, rather than the link itself.
    #
    # When used with [[, the < and > operators sort lexicographically using the current locale.  The
    # test command sorts using ASCII ordering.
    #
    # -a file
    #        True if file exists.
    # -b file
    #        True if file exists and is a block special file.
    # -c file
    #        True if file exists and is a character special file.
    # -d file
    #        True if file exists and is a directory.
    # -e file
    #        True if file exists.
    # -f file
    #        True if file exists and is a regular file.
    # -g file
    #        True if file exists and is set-group-id.
    # -h file
    #        True if file exists and is a symbolic link.
    # -k file
    #        True if file exists and its ``sticky'' bit is set.
    # -p file
    #        True if file exists and is a named pipe (FIFO).
    # -r file     True if file exists and is readable.
    # -s file     True if file exists and has a size greater than zero.
    # -t fd  True if file descriptor fd is open and refers to a terminal.
    # -u file
    #        True if file exists and its set-user-id bit is set.
    # -w file
    #        True if file exists and is writable.
    # -x file
    #        True if file exists and is executable.
    # -G file
    #        True if file exists and is owned by the effective group id.
    # -L file
    #        True if file exists and is a symbolic link.
    # -N file
    #        True if file exists and has been modified since it was last read.
    # -O file
    #        True if file exists and is owned by the effective user id.
    # -S file
    #        True if file exists and is a socket.
    # file1 -ef file2
    #        True if file1 and file2 refer to the same device and inode numbers.
    # file1 -nt file2
    #        True if file1 is newer (according to modification date) than file2, or if file1 exists and
    #        file2 does not.
    # file1 -ot file2
    #        True if file1 is older than file2, or if file2 exists and file1 does not.
    # -o optname
    #        True if the shell option optname is enabled.  See the list of options under the
    #        description of the -o option to the set builtin below.
    # -v varname
    #        True if the shell variable varname is set (has been assigned a value).
    # -R varname
    #        True if the shell variable varname is set and is a name reference.
    # -z string
    #        True if the length of string is zero.
    # string
    # -n string
    #        True if the length of string is non-zero.
    #
    # string1 == string2
    # string1 = string2
    #        True if the strings are equal.  = should be used with the test command for POSIX
    #        conformance.  When used with the [[ command, this performs pattern matching as described
    #        above (Compound Commands).
    #
    # string1 != string2
    #        True if the strings are not equal.
    #
    # string1 < string2
    #        True if string1 sorts before string2 lexicographically.
    #
    # string1 > string2
    #        True if string1 sorts after string2 lexicographically.
    #
    # arg1 OP arg2
    #        OP is one of -eq, -ne, -lt, -le, -gt, or -ge.  These arithmetic binary operators return
    #        true if arg1 is equal to, not equal to, less than, less than or equal to, greater than, or
    #        greater than or equal to arg2, respectively.  Arg1 and arg2 may be positive or negative
    #        integers.  When used with the [[ command, Arg1 and Arg2 are evaluated as arithmetic
    #        expressions (see ARITHMETIC EVALUATION above).
  }

  #
  #
  #
  chapter__simple_command_expansion() {
    echo-style --h1="SIMPLE COMMAND EXPANSION"
    # When a simple command is executed, the shell performs the following expansions, assignments, and
    # redirections, from left to right, in the following order.
    #
    # 1.     The words that the parser has marked as variable assignments (those preceding the command
    #        name) and redirections are saved for later processing.
    #
    # 2.     The words that are not variable assignments or redirections are expanded.  If any words
    #        remain after expansion, the first word is taken to be the name of the command and the
    #        remaining words are the arguments.
    #
    # 3.     Redirections are performed as described above under REDIRECTION.
    #
    # 4.     The text after the = in each variable assignment undergoes tilde expansion, parameter
    #        expansion, command substitution, arithmetic expansion, and quote removal before being
    #        assigned to the variable.
    #
    # If no command name results, the variable assignments affect the current shell environment.  In
    # the case of such a command (one that consists only of assignment statements and redirections),
    # assignment statements are performed before redirections.  Otherwise, the variables are added to
    # the environment of the executed command and do not affect the current shell environment.  If any
    # of the assignments attempts to assign a value to a readonly variable, an error occurs, and the
    # command exits with a non-zero status.
    #
    # If no command name results, redirections are performed, but do not affect the current shell
    # environment.  A redirection error causes the command to exit with a non-zero status.
    #
    # If there is a command name left after expansion, execution proceeds as described below.
    # Otherwise, the command exits.  If one of the expansions contained a command substitution, the
    # exit status of the command is the exit status of the last command substitution performed.  If
    # there were no command substitutions, the command exits with a status of zero.

  }

  #
  #
  #
  chapter__command_execution() {
    echo-style --h1="COMMAND EXECUTION"
    # After a command has been split into words, if it results in a simple command and an optional list
    # of arguments, the following actions are taken.
    #
    # If the command name contains no slashes, the shell attempts to locate it.  If there exists a
    # shell function by that name, that function is invoked as described above in FUNCTIONS.  If the
    # name does not match a function, the shell searches for it in the list of shell builtins.  If a
    # match is found, that builtin is invoked.
    #
    # If the name is neither a shell function nor a builtin, and contains no slashes, bash searches
    # each element of the PATH for a directory containing an executable file by that name.  Bash uses a
    # hash table to remember the full pathnames of executable files (see hash under SHELL BUILTIN
    # COMMANDS below).  A full search of the directories in PATH is performed only if the command is
    # not found in the hash table.  If the search is unsuccessful, the shell searches for a defined
    # shell function named command_not_found_handle.  If that function exists, it is invoked in a
    # separate execution environment with the original command and the original command's arguments as
    # its arguments, and the function's exit status becomes the exit status of that subshell.  If that
    # function is not defined, the shell prints an error message and returns an exit status of 127.
    #
    # If the search is successful, or if the command name contains one or more slashes, the shell
    # executes the named program in a separate execution environment.  Argument 0 is set to the name
    # given, and the remaining arguments to the command are set to the arguments given, if any.
    #
    # If this execution fails because the file is not in executable format, and the file is not a
    # directory, it is assumed to be a shell script, a file containing shell commands, and the shell
    # creates a new instance of itself to execute it.  This subshell reinitializes itself, so that the
    # effect is as if a new shell had been invoked to handle the script, with the exception that the
    # locations of commands remembered by the parent (see hash below under SHELL BUILTIN COMMANDS) are
    # retained by the child.
    #
    # If the program is a file beginning with #!, the remainder of the first line specifies an
    # interpreter for the program.  The shell executes the specified interpreter on operating systems
    # that do not handle this executable format themselves.  The arguments to the interpreter consist
    # of a single optional argument following the interpreter name on the first line of the program,
    # followed by the name of the program, followed by the command arguments, if any.
  }

  #
  #
  #
  chapter__command_execution() {
    echo-style --h1="COMMAND EXECUTION ENVIRONMENT"
    # The shell has an execution environment, which consists of the following:
    #
    # â€¢      open files inherited by the shell at invocation, as modified by redirections supplied to
    #        the exec builtin
    #
    # â€¢      the current working directory as set by cd, pushd, or popd, or inherited by the shell at
    #        invocation
    #
    # â€¢      the file creation mode mask as set by umask or inherited from the shell's parent
    #
    # â€¢      current traps set by trap
    #
    # â€¢      shell parameters that are set by variable assignment or with set or inherited from the
    #        shell's parent in the environment
    #
    # â€¢      shell functions defined during execution or inherited from the shell's parent in the
    #        environment
    #
    # â€¢      options enabled at invocation (either by default or with command-line arguments) or by set
    #
    # â€¢      options enabled by shopt
    #
    # â€¢      shell aliases defined with alias
    #
    # â€¢      various process IDs, including those of background jobs, the value of $$, and the value of
    #        PPID
    #
    # When a simple command other than a builtin or shell function is to be executed, it is invoked in
    # a separate execution environment that consists of the following.  Unless otherwise noted, the
    # values are inherited from the shell.
    #
    #
    # â€¢      the shell's open files, plus any modifications and additions specified by redirections to
    #        the command
    #
    # â€¢      the current working directory
    #
    # â€¢      the file creation mode mask
    #
    # â€¢      shell variables and functions marked for export, along with variables exported for the
    #        command, passed in the environment
    #
    # â€¢      traps caught by the shell are reset to the values inherited from the shell's parent, and
    #        traps ignored by the shell are ignored
    #
    # A command invoked in this separate environment cannot affect the shell's execution environment.
    #
    # A subshell is a copy of the shell process.
  }

  #
  #
  #
  chapter__environment() {
    echo-style --h1="ENVIRONMENT"
    # When a program is invoked it is given an array of strings called the environment.  This is a list
    # of name-value pairs, of the form name=value.
    #
    # The shell provides several ways to manipulate the environment.  On invocation, the shell scans
    # its own environment and creates a parameter for each name found, automatically marking it for
    # export to child processes.  Executed commands inherit the environment.  The export and declare -x
    # commands allow parameters and functions to be added to and deleted from the environment.  If the
    # value of a parameter in the environment is modified, the new value becomes part of the
    # environment, replacing the old.  The environment inherited by any executed command consists of
    # the shell's initial environment, whose values may be modified in the shell, less any pairs
    # removed by the unset command, plus any additions via the export and declare -x commands.
    #
    # The environment for any simple command or function may be augmented temporarily by prefixing it
    # with parameter assignments, as described above in PARAMETERS.  These assignment statements affect
    # only the environment seen by that command.
    #
    # If the -k option is set (see the set builtin command below), then all parameter assignments are
    # placed in the environment for a command, not just those that precede the command name.
    #
    # When bash invokes an external command, the variable _ is set to the full filename of the command
    # and passed to that command in its environment.
  }

  #
  #
  #
  chapter__exit_status() {
    echo-style --h1="EXIT STATUS"
    # The exit status of an executed command is the value returned by the waitpid system call or
    # equivalent function.  Exit statuses fall between 0 and 255, though, as explained below, the shell
    # may use values above 125 specially.  Exit statuses from shell builtins and compound commands are
    # also limited to this range.  Under certain circumstances, the shell will use special values to
    # indicate specific failure modes.
    #
    # For the shell's purposes, a command which exits with a zero exit status has succeeded.  An exit
    # status of zero indicates success.  A non-zero exit status indicates failure.  When a command
    # terminates on a fatal signal N, bash uses the value of 128+N as the exit status.
    #
    # If a command is not found, the child process created to execute it returns a status of 127.  If a
    # command is found but is not executable, the return status is 126.
    #
    # If a command fails because of an error during expansion or redirection, the exit status is
    # greater than zero.
    #
    # Shell builtin commands return a status of 0 (true) if successful, and non-zero (false) if an
    # error occurs while they execute.  All builtins return an exit status of 2 to indicate incorrect
    # usage, generally invalid options or missing arguments.
    #
    # The exit status of the last command is available in the special parameter $?.
    #
    # Bash itself returns the exit status of the last command executed, unless a syntax error occurs,
    # in which case it exits with a non-zero value.  See also the exit builtin command below.
  }

  #
  #
  #
  chapter__signals() {
    echo-style --h1="SIGNALS"
    # When bash is interactive, in the absence of any traps, it ignores SIGTERM (so that kill 0 does
    # not kill an interactive shell), and SIGINT is caught and handled (so that the wait builtin is
    # interruptible).  In all cases, bash ignores SIGQUIT.  If job control is in effect, bash ignores
    # SIGTTIN, SIGTTOU, and SIGTSTP.
    #
    # Non-builtin commands run by bash have signal handlers set to the values inherited by the shell
    # from its parent.  When job control is not in effect, asynchronous commands ignore SIGINT and
    # SIGQUIT in addition to these inherited handlers.  Commands run as a result of command
    # substitution ignore the keyboard-generated job control signals SIGTTIN, SIGTTOU, and SIGTSTP.
    #
    # The shell exits by default upon receipt of a SIGHUP.  Before exiting, an interactive shell
    # resends the SIGHUP to all jobs, running or stopped.  Stopped jobs are sent SIGCONT to ensure that
    # they receive the SIGHUP.  To prevent the shell from sending the signal to a particular job, it
    # should be removed from the jobs table with the disown builtin (see SHELL BUILTIN COMMANDS below)
    # or marked to not receive SIGHUP using disown -h.
    #
    # If the huponexit shell option has been set with shopt, bash sends a SIGHUP to all jobs when an
    # interactive login shell exits.
    #
    # If bash is waiting for a command to complete and receives a signal for which a trap has been set,
    # the trap will not be executed until the command completes.  When bash is waiting for an
    # asynchronous command via the wait builtin, the reception of a signal for which a trap has been
    # set will cause the wait builtin to return immediately with an exit status greater than 128,
    # immediately after which the trap is executed.
    #
    # When job control is not enabled, and bash is waiting for a foreground command to complete, the
    # shell receives keyboard-generated signals such as SIGINT (usually generated by ^C) that users
    # commonly intend to send to that command.  This happens because the shell and the command are in
    # the same process group as the terminal, and ^C sends SIGINT to all processes in that process
    # group.
    #
    # When bash is running without job control enabled and receives SIGINT while waiting for a
    # foreground command, it waits until that foreground command terminates and then decides what to do
    # about the SIGINT:
    #
    # 1.     If the command terminates due to the SIGINT, bash concludes that the user meant to end the
    #        entire script, and acts on the SIGINT (e.g., by running a SIGINT trap or exiting itself);
    #
    # 2.     If the command does not terminate due to SIGINT, the program handled the SIGINT itself and
    #        did not treat it as a fatal signal.  In that case, bash does not treat SIGINT as a fatal
    #        signal, either, instead assuming that the SIGINT was used as part of the program's normal
    #        operation (e.g., emacs uses it to abort editing commands) or deliberately discarded.
    #        However, bash will run any trap set on SIGINT, as it does with any other trapped signal it
    #        receives while it is waiting for the foreground command to complete, for compatibility.
  }

  #
  #
  #
  chapter__job_control() {
    echo-style --h1="PROCESSES & JOB CONTROL"

    lsof -p $$ # list open files for the this current running process.

    # Job control refers to the ability to selectively stop (suspend) the execution of processes and
    # continue (resume) their execution at a later point.  A user typically employs this facility via
    # an interactive interface supplied jointly by the operating system kernel's terminal driver and
    # bash.
    #
    # The shell associates a job with each pipeline.  It keeps a table of currently executing jobs,
    # which may be listed with the jobs command.  When bash starts a job asynchronously (in the
    # background), it prints a line that looks like:
    #
    #        [1] 25647
    #
    # indicating that this job is job number 1 and that the process ID of the last process in the
    # pipeline associated with this job is 25647.  All of the processes in a single pipeline are
    # members of the same job.  Bash uses the job abstraction as the basis for job control.
    #
    # To facilitate the implementation of the user interface to job control, the operating system
    # maintains the notion of a current terminal process group ID.  Members of this process group
    # (processes whose process group ID is equal to the current terminal process group ID) receive
    # keyboard-generated signals such as SIGINT.  These processes are said to be in the foreground.
    # Background processes are those whose process group ID differs from the terminal's; such processes
    # are immune to keyboard-generated signals.  Only foreground processes are allowed to read from or,
    # if the user so specifies with stty tostop, write to the terminal.  Background processes which
    # attempt to read from (write to when stty tostop is in effect) the terminal are sent a SIGTTIN
    # (SIGTTOU) signal by the kernel's terminal driver, which, unless caught, suspends the process.
    #
    # If the operating system on which bash is running supports job control, bash contains facilities
    # to use it.  Typing the suspend character (typically ^Z, Control-Z) while a process is running
    # causes that process to be stopped and returns control to bash.  Typing the delayed suspend
    # character (typically ^Y, Control-Y) causes the process to be stopped when it attempts to read
    # input from the terminal, and control to be returned to bash.  The user may then manipulate the
    # state of this job, using the bg command to continue it in the background, the fg command to
    # continue it in the foreground, or the kill command to kill it.  A ^Z takes effect immediately,
    # and has the additional side effect of causing pending output and typeahead to be discarded.
    #
    # There are a number of ways to refer to a job in the shell.  The character % introduces a job
    # specification (jobspec).  Job number n may be referred to as %n.  A job may also be referred to
    # using a prefix of the name used to start it, or using a substring that appears in its command
    # line.  For example, %ce refers to a stopped job whose command name begins with ce.  If a prefix
    # matches more than one job, bash reports an error.  Using %?ce, on the other hand, refers to any
    # job containing the string ce in its command line.  If the substring matches more than one job,
    # bash reports an error.  The symbols %% and %+ refer to the shell's notion of the current job,
    # which is the last job stopped while it was in the foreground or started in the background.  The
    # previous job may be referenced using %-.  If there is only a single job, %+ and %- can both be
    # used to refer to that job.  In output pertaining to jobs (e.g., the output of the jobs command),
    # the current job is always flagged with a +, and the previous job with a -.  A single % (with no
    # accompanying job specification) also refers to the current job.

  }

  chapter__prompting() {
    echo-style --h1="PROMPTING"
    # When executing interactively, bash displays the primary prompt PS1 when it is ready to read a
    # command, and the secondary prompt PS2 when it needs more input to complete a command.  Bash
    # displays PS0 after it reads a command but before executing it.  Bash displays PS4 as described
    # above before tracing each command when the -x option is enabled.  Bash allows these prompt
    # strings to be customized by inserting a number of backslash-escaped special characters that are
    # decoded as follows:
    #        \a     an ASCII bell character (07)
    #        \d     the date in "Weekday Month Date" format (e.g., "Tue May 26")
    #        \D{format}
    #               the format is passed to strftime(3) and the result is inserted into the prompt
    #               string; an empty format results in a locale-specific time representation.  The
    #               braces are required
    #        \e     an ASCII escape character (033)
    #        \h     the hostname up to the first `.'
    #        \H     the hostname
    #        \j     the number of jobs currently managed by the shell
    #        \l     the basename of the shell's terminal device name
    #        \n     newline
    #        \r     carriage return
    #        \s     the name of the shell, the basename of $0 (the portion following the final slash)
    #        \t     the current time in 24-hour HH:MM:SS format
    #        \T     the current time in 12-hour HH:MM:SS format
    #        \@     the current time in 12-hour am/pm format
    #        \A     the current time in 24-hour HH:MM format
    #        \u     the username of the current user
    #        \v     the version of bash (e.g., 2.00)
    #        \V     the release of bash, version + patch level (e.g., 2.00.0)
    #        \w     the value of the PWD shell variable ($PWD), with $HOME abbreviated with a tilde
    #               (uses the value of the PROMPT_DIRTRIM variable)
    #        \W     the basename of $PWD, with $HOME abbreviated with a tilde
    #        \!     the history number of this command
    #        \#     the command number of this command
    #        \$     if the effective UID is 0, a #, otherwise a $
    #        \nnn   the character corresponding to the octal number nnn
    #        \\     a backslash
    #        \[     begin a sequence of non-printing characters, which could be used to embed a
    #               terminal control sequence into the prompt
    #        \]     end a sequence of non-printing characters
    #
    # The command number and the history number are usually different: the history number of a command
    # is its position in the history list, which may include commands restored from the history file
    # (see HISTORY below), while the command number is the position in the sequence of commands
    # executed during the current shell session.  After the string is decoded, it is expanded via
    # parameter expansion, command substitution, arithmetic expansion, and quote removal, subject to
    # the value of the promptvars shell option (see the description of the shopt command under SHELL
    # BUILTIN COMMANDS below).  This can have unwanted side effects if escaped portions of the string
    # appear within command substitution or contain characters special to word expansion.

  }

  chapter__readline() {
    echo-style --h1="READLINE"
  }

  chapter__history() {
    echo-style --h1="HISTORY"
    # When the -o history option to the set builtin is enabled, the shell provides access to the
    # command history, the list of commands previously typed.  The value of the HISTSIZE variable is
    # used as the number of commands to save in a history list.  The text of the last HISTSIZE commands
    # (default 500) is saved.  The shell stores each command in the history list prior to parameter and
    # variable expansion (see EXPANSION above) but after history expansion is performed, subject to the
    # values of the shell variables HISTIGNORE and HISTCONTROL.
    #
    # On startup, the history is initialized from the file named by the variable HISTFILE (default
    # ~/.bash_history).  The file named by the value of HISTFILE is truncated, if necessary, to contain
    # no more than the number of lines specified by the value of HISTFILESIZE.  If HISTFILESIZE is
    # unset, or set to null, a non-numeric value, or a numeric value less than zero, the history file
    # is not truncated.  When the history file is read, lines beginning with the history comment
    # character followed immediately by a digit are interpreted as timestamps for the following history
    # line.  These timestamps are optionally displayed depending on the value of the HISTTIMEFORMAT
    # variable.  When a shell with history enabled exits, the last $HISTSIZE lines are copied from the
    # history list to $HISTFILE.  If the histappend shell option is enabled (see the description of
    # shopt under SHELL BUILTIN COMMANDS below), the lines are appended to the history file, otherwise
    # the history file is overwritten.  If HISTFILE is unset, or if the history file is unwritable, the
    # history is not saved.  If the HISTTIMEFORMAT variable is set, time stamps are written to the
    # history file, marked with the history comment character, so they may be preserved across shell
    # sessions.  This uses the history comment character to distinguish timestamps from other history
    # lines.  After saving the history, the history file is truncated to contain no more than
    # HISTFILESIZE lines.  If HISTFILESIZE is unset, or set to null, a non-numeric value, or a numeric
    # value less than zero, the history file is not truncated.
    #
    # The builtin command fc (see SHELL BUILTIN COMMANDS below) may be used to list or edit and re-
    # execute a portion of the history list.  The history builtin may be used to display or modify the
    # history list and manipulate the history file.  When using command-line editing, search commands
    # are available in each editing mode that provide access to the history list.
    #
    # The shell allows control over which commands are saved on the history list.  The HISTCONTROL and
    # HISTIGNORE variables may be set to cause the shell to save only a subset of the commands entered.
    # The cmdhist shell option, if enabled, causes the shell to attempt to save each line of a multi-
    # line command in the same history entry, adding semicolons where necessary to preserve syntactic
    # correctness.  The lithist shell option causes the shell to save the command with embedded
    # newlines instead of semicolons.  See the description of the shopt builtin below under SHELL
    # BUILTIN COMMANDS for information on setting and unsetting shell options.

  }

  chapter__history_expansion() {
    echo-style --h1="HISTORY EXPANSION"
  }

  chapter__shell_builtin__read() {

    echo-style --h1="SHELL BUILTIN COMMANDS"

    # read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u
    # fd] [name ...]
    #        One line is read from the standard input, or from the file descriptor fd supplied as an
    #        argument to the -u option, split into words as described above under Word Splitting, and
    #        the first word is assigned to the first name, the second word to the second name, and so
    #        on.  If there are more words than names, the remaining words and their intervening
    #        delimiters are assigned to the last name.  If there are fewer words read from the input
    #        stream than names, the remaining names are assigned empty values.  The characters in IFS
    #        are used to split the line into words using the same rules the shell uses for expansion
    #        (described above under Word Splitting).  The backslash character (\) may be used to remove
    #        any special meaning for the next character read and for line continuation.  Options, if
    #        supplied, have the following meanings:
    #        -a aname
    #               The words are assigned to sequential indices of the array variable aname, starting
    #               at 0.  aname is unset before any new values are assigned.  Other name arguments are
    #               ignored.
    #        -d delim
    #               The first character of delim is used to terminate the input line, rather than
    #               newline.  If delim is the empty string, read will terminate a line when it reads a
    #               NUL character.
    #        -e     If the standard input is coming from a terminal, readline (see READLINE above) is
    #               used to obtain the line.  Readline uses the current (or default, if line editing
    #               was not previously active) editing settings, but uses readline's default filename
    #               completion.
    #        -i text
    #               If readline is being used to read the line, text is placed into the editing buffer
    #               before editing begins.
    #        -n nchars
    #               read returns after reading nchars characters rather than waiting for a complete
    #               line of input, but honors a delimiter if fewer than nchars characters are read
    #               before the delimiter.
    #        -N nchars
    #               read returns after reading exactly nchars characters rather than waiting for a
    #               complete line of input, unless EOF is encountered or read times out.  Delimiter
    #               characters encountered in the input are not treated specially and do not cause read
    #               to return until nchars characters are read.  The result is not split on the
    #               characters in IFS; the intent is that the variable is assigned exactly the
    #               characters read (with the exception of backslash; see the -r option below).
    #        -p prompt
    #               Display prompt on standard error, without a trailing newline, before attempting to
    #               read any input.  The prompt is displayed only if input is coming from a terminal.
    #        -r     Backslash does not act as an escape character.  The backslash is considered to be
    #               part of the line.  In particular, a backslash-newline pair may not then be used as
    #               a line continuation.
    #        -s     Silent mode.  If input is coming from a terminal, characters are not echoed.
    #        -t timeout
    #               Cause read to time out and return failure if a complete line of input (or a
    #               specified number of characters) is not read within timeout seconds.  timeout may be
    #               a decimal number with a fractional portion following the decimal point.  This
    #               option is only effective if read is reading input from a terminal, pipe, or other
    #               special file; it has no effect when reading from regular files.  If read times out,
    #               read saves any partial input read into the specified variable name.  If timeout is
    #               0, read returns immediately, without trying to read any data.  The exit status is 0
    #               if input is available on the specified file descriptor, or the read will return
    #               EOF, non-zero otherwise.  The exit status is greater than 128 if the timeout is
    #               exceeded.
    #        -u fd  Read input from file descriptor fd.
    #
    #        If no names are supplied, the line read, without the ending delimiter but otherwise
    #        unmodified, is assigned to the variable REPLY.  The exit status is zero, unless end-of-
    #        file is encountered, read times out (in which case the status is greater than 128), a
    #        variable assignment error (such as assigning to a readonly variable) occurs, or an invalid
    #        file descriptor is supplied as the argument to -u.
  }

  # echo-style --h1="SHELL COMPATABILITY MODE"
  # echo-style --h1="RESTRICTED SHELL"

  chapter__files() {
    echo-style --h1="FILES"
    # /bin/bash
    #        The bash executable
    # /etc/profile
    #        The systemwide initialization file, executed for login shells
    # ~/.bash_profile
    #        The personal initialization file, executed for login shells
    # ~/.bashrc
    #        The individual per-interactive-shell startup file
    # ~/.bash_logout
    #        The individual login shell cleanup file, executed when a login shell exits
    # ~/.bash_history
    #        The default value of HISTFILE, the file in which bash saves the command history
    # ~/.inputrc
    #        Individual readline initialization file
  }

  # ============================================
  # ARGS

  function help {
    cat <<-EOF >/dev/stderr
			ABOUT:
			Bash man pages dorothy version.

			USAGE:
			bash_playground [--all]
			    Choose from a list what sections of the man pages you want to
			    view / run.
		EOF
    if test "$#" -ne 0; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }
  local item show_all='' action='' option_args=()
  while test "$#" -ne 0; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--all') show_all='yes' ;;
    *) help "An unrecognised argument was provided: $item" ;;
    esac
  done

  function menu_item_transform() {
    :
    # parameter expansion
    # replace whitespace with underscores.
  }

  # if all then call all functions.
  if [[ "$show_all" = 'yes' ]]; then
    for item in "${BASH_MAN_PAGE_CHAPTERS[@]}"; do
      chapter__"$(menu_item_transform "$item")"
    done
  else
    :
    # TODO: choose / fzf which sections to display.
    # local selection ="$(choose ...)"
    for item in "${selection[@]}"; do
      :
      # chapter__"$(menu_item_transform "$item")"
    done
  fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
  bash_playground "$@"
fi
