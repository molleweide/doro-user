#!/usr/bin/env bash

# NOTE: The carapace docs suck a huge bag of dicks and so you have to do a lot
# of manual testing to figure out how each spec works/operates in practice.

# NOTE: good spec examples
# https://carapace-sh.github.io/carapace-bin/spec/examples.html

# carapace spec docs
#   https://carapace-sh.github.io/carapace-spec/carapace-spec.html

# carapace spec examples:
#   https://github.com/carapace-sh/carapace-spec/tree/master/example
#   https://github.com/carapace-sh/carapace-spec/blob/master/example/pkill.yaml

# TEST: Carapace config `values`
# Values are defined with an optional description and optional style delimited by \t.
# ["value", "value\tdescription", "value\tdescription\tblue"]

# NOTE: Supposed to be flaky but could maybe be used.
# Use Carapaces man page spec generator
# https://carapace-sh.github.io/carapace-bin/spec/scrape.html#man
# https://github.com/carapace-sh/carapace-spec-man

# Documentation
# carapace-sh.github.io/carapace	documentation of the library
# carapace-sh.github.io/carapace-bin	documentation of the binary
# carapace-sh.github.io/carapace-spec	documentation of the spec
# carapace-sh.github.io/carapace-pixi	picture book introduction

function dorothy_autocomplete() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # Ensure that the autocomplete dir exists
  mkdir -p "$DOROTHY/autocomplete"

  # =====================================
  # Variables

  local dorothy_commands_dir="$DOROTHY/commands"

  local regex_lines_starting_with_hyphen="^[-]{1,2}.*$"

  local help_content

  # These could go into a helper func
  local regex_usage_section="USAGE:\s*([\s\S]*?)(?=\n\s*\w+:|$)"
  local regex_about_section="ABOUT:\s*([\s\S]*?)(?=\n[A-Z]+\:|\n{2,})"
  local regex_options_section="OPTIONS:\s*([\s\S]*?)(?=\n\s*[A-Z]+\s*:)"

  local OPTIONS_SECTIONS=()
  local ACTIONS_SECTIONS=()

  local fzf_base_opts=(
    --height=40%
    --ellipsis=..
  )

  # =====================================
  # Helpers

  __use_fzf() {
    if test "$use_fzf" = 'yes'; then
      return 0
    else
      return 1
    fi
  }

  local section_regex_base=":\s*([\s\S]*?)(?=\n\s*[A-Z]+\s*:)"

  get_regex_for_section() {
    local section_name=$1
    # __print_string "$section_name:\s*([\s\S]*?)(?=\n\s*\w+:|$)"
    __print_string "$section_name$section_regex_base"
  }

  # Unused
  get_help_contents() {
    local regex_help_func="^\s+function\s+help\s*{([\s\S]*?)}"
    local regex_heredoc_content="<<[-]?\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([\s\S]*?)^\s*\1\s*$"
    local help_contents="$(cat "$1" | echo-regexp -gm --find="$regex_help_func")"
    local res="$(echo "$help_contents" | echo-regexp -gm --find="$regex_heredoc_content")"
  }

  collect_about_section() {
    local help_content="$1"
    local about_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_about_section")"
    local about="$(echo "$about_section" | sed -n 2p)"
    __print_lines "$about"
  }

  collect_usage_section() {
    local help_content="$1"
    local usage_section
    usage_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_usage_section")"
    __print_lines "$usage_section"
  }

  # collect and print all lines containing option flags
  collect_option_flag_lines() {
    local help_content="$1"
    local options_section options_all
    options_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_options_section")"
    command_option_flag_lines="$(echo "$options_section" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
    __print_lines "$command_option_flag_lines"
  }

  loop_option_sections() {
    :
    # TODO: 1. trim first line of the options section
    # 2. split by white space
    local help_content="$1"
    local options_section options_all

    # local regex_opts="OPTIONS:\s*[\s\S]*?\n([\s\S]*?)(?=\n\s*[A-Z]+\s*:)"

    options_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_options_section")"

    local trimmed_string=$(echo "$options_section" | sed '1d')

    __print_lines "$trimmed_string"
    # command_option_flag_lines="$(echo "$options_section" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
  }

  insert_into_dynamic_array() {
    local array_name="$1"   # Name of the array passed as a string
    local new_value="$2"     # New value to insert

    # Use indirect reference to add new value to the array
    eval "$array_name+=(\"$new_value\")"
}

  # This works for splitting a section on empty lines
  # TODO: make this into a generalized helper
  # Takes a multiline input string, and splits it by empty lines into an array.
  # input:
  # - multiline string
  # - target array to insert each section into.
  # new name: `split_multiline_string_by_empty_lines`
  collect_sub_sections() {
    local section_name=$1
    # local sub_sections_array="$section_name"_SECTIONS
    local section_regex
    local sub_sections

    # make dynamic var reference (*)
    declare -n sub_sections_array="$section_name"_SECTIONS

    section_regex=$(get_regex_for_section "$section_name")
    sub_sections="$(echo "$help_content" | echo-regexp -gmn --find="$section_regex")"
    sub_sections="$(echo "$sub_sections" | sed '1d')"

    # Initialize an array to hold sections
    sections=()
    current_section=""

    # Read the multiline string line by line
    while IFS= read -r line; do
      if [[ -z "$line" ]]; then
        # If we encounter an empty line, store the current section if not empty
        if [[ -n "$current_section" ]]; then
          sections+=("$current_section")
          current_section=""
        fi
      else
        # Accumulate non-empty lines
        current_section+="$line"$'\n'
      fi
    done <<<"$sub_sections"

    # Store the last section if it exists
    if [[ -n "$current_section" ]]; then
      sections+=("$current_section")
    fi

    echo "# $section_name pre ######################"
    for section in "${sections[@]}"; do
      sub_sections_array+=("$section") # (*) now we can append normally to our var ref.
      # echo "$section"
      # echo "--------------------------"
    done
    echo "# $section_name post ######################"

  }

  # This splits thÂ action section based on new lines starting at the beginning
  # of the line.
  collect_action_section() {
    local help_content
    set +e
    help_content="$(dorothy --help 2>&1)"
    set -e
    local actions_section="$(echo "$help_content" | sed -n '/^ACTIONS:/,/^[A-Z][A-Z\s]*:/{/^ACTIONS:/!p;}')"

    # This variable is used to handle some special cases when subsequent lines
    # are starting at beginning of the line, so that we split each sub action
    # correctly.
    local prev_line_not_empty="prev_empty" # bash inverted boolean, eg. 0 = true

    # Loop over actions and separate by ----
    while IFS= read -r line; do
      if [[ "$line" =~ ^[^[:space:]] && -n "$line" && "$prev_line_not_empty" == "prev_empty" ]]; then
        # visually splitting each sub action for testing purposes
        echo "--------------------------------------------"
      fi
      echo "$line" # ($prev_line_not_empty)"
      #
      if test -z "$line"; then
        prev_line_not_empty="prev_empty"
      else
        prev_line_not_empty="_"
      fi
    done <<<"$actions_section"
  }

  # =====================================
  # Actions

  create_carpace_spec_for_command() {
    local command_name=$1
    local final_spec
    local about_text
    local command_option_flag_lines
    local command_sub_actions

    OPTIONS_SECTIONS=()
    ACTIONS_SECTIONS=()

    set +e # prevent errexit
    help_content="$("$command_name" --help 2>&1)"
    set -e

    # TODO: [ ] reset the options and actions section arrays

    about_text="$(collect_about_section "$help_content")"

    command_option_flag_lines=$(collect_option_flag_lines "$help_content")

    # collect options
    collect_sub_sections "OPTIONS"

    # collect actions

    # ------------------------------------------------------------------
    # Put together final spec file for $command_name
    final_spec="$(
      __print_lines \
        "# yaml-language-server: \$schema=https://carapace.sh/schemas/command.json" \
        "name: $command_name" \
        "description: ${about_text[*]}"
    )"

    # FLAGS -------------------------------------------------------
    # = flag takes an argument
    # * flag is repeatable
    # ? flag takes an optional argument
    # & flag is hidden
    # ! flag is required
    #
    # https://github.com/carapace-sh/carapace-spec/blob/master/example/traverse.yaml
    #
    # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: flag
    # flags:
    #   -e=: executables
    #   -f, --file=: file
    # completion:
    #   flag: ????????????
    #     e: ["$executables"]
    #     file: ["$files"]

    # TODO: [ ] check if has flags
    # TODO: [ ] fix spec flag formatting
    # each flag is a map of short/long-hand -> description
    # FIX: i probably need to do a custom section split for each option,
    # and then parse each option section one by one, so that I can capture
    # the flag and description into separate variables.

    final_spec+=($'\n'"flags:")
    for item in "${command_option_flag_lines[@]}"; do
      final_spec+=($'\n'"  $item")
      # final_spec+=("\t$item")
    done

    # PERSISTENT FLAGS --------------------------------------------
    #

    # COMPLETION --------------------------------------------
    #
    # TODO: [ ] check if has/should add completions
    #
    # completion > flags

    # TODO: [ ] try add flag completions if has option flags

    # completion > Positional
    # I believe that sub actios should be added as positional actions.
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/positional.html
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positional
    # completion:
    #   positional: NOTE: these are completed in order, so pos1 before pos2
    #     - [pos1, positional1]
    #     - [pos2, positional2]
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positionalany
    # completion: NOTE: here, the order is arbitrary.
    #   positionalany: [one, two, three]

    # TODO: [ ] positional args.
    # Before embarking on pos args, i have to first try the flags options and
    # see how this works.

    # TODO: [ ] positional any
    # same as above..

    # DASH
    # Positional arguments after `--`
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/dash.html
    #
    # NOTE: dash | dash-any
    # completes in the same way as positional above but after the double dash
    # separator.

    # TODO: [ ] start have a look at macros
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/macros.html
    # Macros allow for hooking into more advanced lib funcs.

    # TODO: [ ] investigate variable replacement
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/variables.html

    __print_lines "${final_spec[*]}"

    __print_lines "${final_spec[*]}" >"$DOROTHY/autocomplete/$command_name.yaml"

    # collect_action_section
    # local opt_sec=$(loop_option_sections "$help_content")
    # split_multiline_string_on_empty_lines "$opt_sec"

    echo "##################################"

    echo "${#OPTIONS_SECTIONS[@]}"

    __print_lines "${OPTIONS_SECTIONS[@]}"

  }

  # =====================================
  # Arguments

  function help {
    cat <<-EOF >/dev/stderr
			USAGE:
			dorothy-autocomplete [...options] <file> -- ...

			  DESCRIPTION:
			  Auto generate carapace-spec shell completions for dorothy commands.
			  Either for a single command, a filter, or all commands a new.
		EOF
    if test "$#" -ne 0; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # process
  # local item option_args=() option_file='' option_multiple='ok' option_quiet
  # option_quiet="$(echo-quiet-enabled -- "$@")"
  local option_command_single='' option_all='no' use_fzf='yes'
  while test "$#" -ne 0; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--no-fzf'* | '--fzf'*)
      use_fzf="$(get-flag-value --affirmative --fallback="$use_fzf" -- "$item")"
      ;;
    '--all') options_all='yes' ;;
    '--command='*) option_command_single="${item#*=}" ;;
    # '--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet-enabled
    # '--multiple=ok' | '--multiple=warn-skip' | '--multiple=warn-apply') option_multiple="${item#*=}" ;;
    # '--')
    #   option_args+=("$@")
    #   shift $#
    #   break
    #   ;;
    # '--'*) help "An unrecognised flag was provided: $item" ;;
    *)
      if test -z "$option_file"; then
        option_file="$item"
      else
        help "An unrecognised argument was provided: $item"
      fi
      #   ;;
      ;;
    esac
  done

  local fzf_heading__prefix='SELECTION (Current question: '
  local fzf_heading__suffix=')'
  get_fzf_heading() {
    __print_string "$fzf_heading__prefix${1-????}$fzf_heading__suffix"
  }
  if test -n "$option_command_single"; then
    # the single command name is selected,
    # todo: try to find command in $dorothy/commands.
    create_carpace_spec_for_command "$option_command_single"
  elif test "$$options_all" = "yes"; then
    :
    # todo: loop over all commands and render for each of them.
  else
    get_all_commands() {
      # this is slow as fuck
      find "$dorothy_commands_dir" -maxdepth 1 -type f | while read -r file; do
        basename "$file"
      done
    }
    local selected_command
    if __use_fzf; then
      selected_command="$(
        # find "$DOROTHY/commands" -maxdepth 1 -type f  | fzf "${fzf_base_opts[@]}" \
        get_all_commands | fzf "${fzf_base_opts[@]}" \
          --header "$(get_fzf_heading "You have to select an ACTION")"
      )"
      create_carpace_spec_for_command "$selected_command"
    else
      action="$(
        choose all dorothy commands
      )"
    fi
  fi

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
  if test "$*" = '--test'; then
    :
  else
    dorothy_autocomplete "$@"
  fi
fi
