#!/usr/bin/env bash

# carapace spec docs
#   https://carapace-sh.github.io/carapace-spec/carapace-spec.html

# carapace spec examples:
#   https://github.com/carapace-sh/carapace-spec/tree/master/example
#   https://github.com/carapace-sh/carapace-spec/blob/master/example/pkill.yaml

# ????
# https://github.com/carapace-sh/carapace-spec-man

# Documentation
# carapace-sh.github.io/carapace	documentation of the library
# carapace-sh.github.io/carapace-bin	documentation of the binary
# carapace-sh.github.io/carapace-spec	documentation of the spec
# carapace-sh.github.io/carapace-pixi	picture book introduction

function dorothy_autocomplete() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # Ensure that the autocomplete dir exists
  mkdir -p "$DOROTHY/autocomplete"

  # =====================================
  # Variables

  local regex_lines_starting_with_hyphen="^[-]{1,2}.*$"

  # these could go into a helper func
  local regex_about_section="ABOUT:\s*([\s\S]*?)(?=\n[A-Z]+\:|\n{2,})"
  local regex_options_section="OPTIONS:\s*([\s\S]*?)(?=\n\s*[A-Z]+\s*:)"

  # =====================================
  # Helpers

  function get_help_contents() {
    # FIX: exclude the surrounding EOF lines
    local regex_help_func="^\s+function\s+help\s*{([\s\S]*?)}"
    local regex_heredoc_content="<<[-]?\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([\s\S]*?)^\s*\1\s*$"
    local help_contents="$(cat "$1" | echo-regexp -gm --find="$regex_help_func")"
    local res="$(echo "$help_contents" | echo-regexp -gm --find="$regex_heredoc_content")"
  }

  # =====================================
  # Actions

  example1() {
    cab <<-EOF
			    # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
			name: mycmd
			description: my command
			flags:
			  --optarg?: optarg flag
			  -r, --repeatable*: repeatable flag
			  -v=: flag with value
			persistentflags:
			  --help: bool flag
			completion:
			  flag:
			    optarg: ["one", "two\twith description", "three\twith style\tblue"]
			    v: ["$files"]
			commands:
			- name: sub
			  description: subcommand
			  completion:
			    positional:
			      - ["$list(,)", "1", "2", "3"]
			      - ["$directories"]
		EOF
  }

  create_carpace_spec_for_command() {
    local command_name=$1 help_content final_spec

    set +e # prevent errexit
    help_content="$("$command_name" --help 2>&1)"
    set -e

    # TODO: build the yaml config file.
    # 1. [x] start by just injecting the name.
    # 2. [x] description
    # 2. [ ] loop across all options.
    # 3. [ ] handle actions.

    # TEST: continue reading [https://carapace-sh.github.io/carapace-spec/carapace-spec/command/parsing.html]

    # TODO: move this to its own func
    # try to get the "ABOUT" section
    local about_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_about_section")"
    local about="$(echo "$about_section" | sed -n 2p)"

    #  # NOTE: OPTIONS
    #  # Loop over all option segments and capture descriptions.
    #  # If successive options without newline and a description at the end all
    #  # have the same description.

    local options_section options_all
    options_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_options_section")"
    options_all="$(echo "$help_content" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
    # __print_lines "$options_all"

    final_spec="$(
      __print_lines \
        "# yaml-language-server: \$schema=https://carapace.sh/schemas/command.json" \
        "name: $command_name" \
        "description: ${about[*]}"
    )"

    # FLAGS
    # = flag takes an argument
    # * flag is repeatable
    # ? flag takes an optional argument
    # & flag is hidden
    # ! flag is required
    #
    # https://github.com/carapace-sh/carapace-spec/blob/master/example/traverse.yaml
    #
    # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: flag
    # flags:
    #   -e=: executables
    #   -f, --file=: file
    # completion:
    #   flag: ????????????
    #     e: ["$executables"]
    #     file: ["$files"]

    final_spec+=($'\n'"flags:")
    for item in "${options_all[@]}"; do
      final_spec+=($'\n'"  $item")
      # final_spec+=("\t$item")
    done

    # POSITIONAL
    # I believe that sub actios should be added as positional actions.
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/positional.html
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positional
    # completion:
    #   positional: NOTE: these are completed in order, so pos1 before pos2
    #     - [pos1, positional1]
    #     - [pos2, positional2]
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positionalany
    # completion: NOTE: here, the order is arbitrary.
    #   positionalany: [one, two, three]

    # DASH
    # Positional arguments after `--`
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/dash.html
    #
    # NOTE: dash | dash-any
    # completes in the same way as positional above but after the double dash
    # separator.

    __print_lines "${final_spec[*]}"

    __print_lines "${final_spec[*]}" >"$DOROTHY/autocomplete/$command_name.yaml"

  }

  # =====================================
  # Arguments

  function help {
    cat <<-EOF >/dev/stderr
			USAGE:
			dorothy-autocomplete [...options] <file> -- ...

			  DESCRIPTION:
			  Auto generate carapace-spec shell completions for dorothy commands.
			  Either for a single command, a filter, or all commands a new.
		EOF
    if test "$#" -ne 0; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # process
  # local item option_args=() option_file='' option_multiple='ok' option_quiet
  # option_quiet="$(echo-quiet-enabled -- "$@")"
  local option_command_single='' option_all='no'
  while test "$#" -ne 0; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--all') options_all='yes' ;;
    '--command='*) option_command_single="${item#*=}" ;;
    # '--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet-enabled
    # '--multiple=ok' | '--multiple=warn-skip' | '--multiple=warn-apply') option_multiple="${item#*=}" ;;
    # '--')
    #   option_args+=("$@")
    #   shift $#
    #   break
    #   ;;
    # '--'*) help "An unrecognised flag was provided: $item" ;;
    *)
      if test -z "$option_file"; then
        option_file="$item"
      else
        help "An unrecognised argument was provided: $item"
      fi
      #   ;;
      ;;
    esac
  done

  # TODO: if no command/all selected, then use fzf or chose to seect a command.

  # local fzf_heading__prefix='SELECTION (Current question: '
  # local fzf_heading__suffix=')'
  #
  # get_fzf_heading() {
  #   # local final header=
  #   #
  #   __print_string "$fzf_heading__prefix${1-????}$fzf_heading__suffix"
  # }
  #
  # local fzf_base_opts=(
  #   --height=40%
  #   --ellipsis=..
  # )
  #
  # local selection_prev=()
  #
  # if test -z "$action"; then
  #   if __use_fzf; then
  #     action="$(
  #       __print_lines "${fzf_actions[@]}" | fzf "${fzf_base_opts[@]}" \
  #         --header "$(get_fzf_heading "You have to select an ACTION")"
  #
  #       # NOTE: display next lines by adding $'\n'
  #
  #     )"
  #   else
  #     action="$(
  #     choose all dorothy commands
  #     )"
  #   fi
  #   selection_prev+=("action = $action")
  # fi

  # dorothy --help

  # TODO: Re-use my dorothy-new command to see how I did the
  # templating.

  # TODO: capture each chunk
  # ABOUT
  # USAGE
  # OPTIONS
  # ACTIONS

  local regex_usage_section="USAGE:\s*([\s\S]*?)(?=\n\s*\w+:|$)"

  local lines_starting_with_hyphen
  local help_content

  # Get help command content
  set +e
  help_content="$(dorothy --help 2>&1)"
  set -e

  # echo-style --h1 "dorothy gen autocomp"

  # echo-style --notice="lines starting with hyphen"
  # lines_starting_with_hyphen="$(echo "$help_content" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
  # __print_lines "${lines_starting_with_hyphen[@]}"
  #
  # echo-style --notice="usage section"
  # local usage_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_usage_section")"
  # __print_lines "$usage_section"

  # NOTE: ACTIONS
  # Loop over all sub action segments and then for each get the action name
  # and description etc.

  local regex_actions_section="ACTIONS:\s*([\s\S]*?)(?=\n[A-Z]+[\s:]*|\s*$)"

  local regex_sub_action="(^[a-zA-Z|<>\s]+(?:\s+\[.*\])?\n(?:\s+.*\n?)*)+"

  echo-style --notice="Actions section"
  # local actions_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_actions_section")"

  local actions_section="$(echo "$help_content" | sed -n '/^ACTIONS:/,/^[A-Z][A-Z\s]*:/{/^ACTIONS:/!p;}')"

  # __print_lines "${actions_section[@]}"

  # This variable is used to handle some special cases when subsequent lines
  # are starting at beginning of the line, so that we split each sub action
  # correctly.
  local prev_line_not_empty="prev_empty" # bash inverted boolean, eg. 0 = true

  # Loop over actions and separate by ----
  while IFS= read -r line; do
    if [[ "$line" =~ ^[^[:space:]] && -n "$line" && "$prev_line_not_empty" == "prev_empty" ]]; then
      echo "----------------------"
      # fi
    fi
    echo "$line" # ($prev_line_not_empty)"
    #
    if test -z "$line"; then
      prev_line_not_empty="prev_empty"
    else
      prev_line_not_empty="_"
    fi
  done <<<"$actions_section"

  # __print_lines "$actions_section"

  # echo-style --g1 "dorothy gen autocomp"

  if test -n "$option_command_single"; then
    :
    # the single command name is selected,
    #
    # TODO: try to find command in $dorothy/commands.

    create_carpace_spec_for_command "$option_command_single"
  elif test "$$options_all" = "yes"; then
    :
    # TODO: loop over all commands and render for each of them.
  else

    :
    # ask should we select a single command or do for all???
  fi

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
  if test "$*" = '--test'; then
    config_helper_test
  else
    dorothy_autocomplete "$@"
  fi
fi
