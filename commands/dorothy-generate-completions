#!/usr/bin/env bash

# NOTE: The carapace docs suck a huge bag of dicks and so you have to do a lot
# of manual testing to figure out how each spec works/operates in practice.

# NOTE: good spec examples
# https://carapace-sh.github.io/carapace-bin/spec/examples.html

# carapace spec docs
#   https://carapace-sh.github.io/carapace-spec/carapace-spec.html

# carapace spec examples:
#   https://github.com/carapace-sh/carapace-spec/tree/master/example
#   https://github.com/carapace-sh/carapace-spec/blob/master/example/pkill.yaml

# TEST: Carapace config `values`
# Values are defined with an optional description and optional style delimited by \t.
# ["value", "value\tdescription", "value\tdescription\tblue"]


# NOTE: Supposed to be flaky but could maybe be used.
# Use Carapaces man page spec generator
# https://carapace-sh.github.io/carapace-bin/spec/scrape.html#man
# https://github.com/carapace-sh/carapace-spec-man

# Documentation
# carapace-sh.github.io/carapace	documentation of the library
# carapace-sh.github.io/carapace-bin	documentation of the binary
# carapace-sh.github.io/carapace-spec	documentation of the spec
# carapace-sh.github.io/carapace-pixi	picture book introduction

function dorothy_autocomplete() (
  source "$DOROTHY/sources/bash.bash"
  __require_array 'mapfile'

  # Ensure that the autocomplete dir exists
  mkdir -p "$DOROTHY/autocomplete"

  # =====================================
  # Variables

  local regex_lines_starting_with_hyphen="^[-]{1,2}.*$"

  # These could go into a helper func
  local regex_usage_section="USAGE:\s*([\s\S]*?)(?=\n\s*\w+:|$)"
  local regex_about_section="ABOUT:\s*([\s\S]*?)(?=\n[A-Z]+\:|\n{2,})"
  local regex_options_section="OPTIONS:\s*([\s\S]*?)(?=\n\s*[A-Z]+\s*:)"

  # =====================================
  # Helpers

  # Unused
  get_help_contents() {
    local regex_help_func="^\s+function\s+help\s*{([\s\S]*?)}"
    local regex_heredoc_content="<<[-]?\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*([\s\S]*?)^\s*\1\s*$"
    local help_contents="$(cat "$1" | echo-regexp -gm --find="$regex_help_func")"
    local res="$(echo "$help_contents" | echo-regexp -gm --find="$regex_heredoc_content")"
  }

  collect_about_section() {
    local help_content="$1"
    local about_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_about_section")"
    local about="$(echo "$about_section" | sed -n 2p)"
    __print_lines "$about"
  }

  collect_usage_section() {
    local help_content="$1"
    local usage_section
    usage_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_usage_section")"
    __print_lines "$usage_section"
  }

  # collect and print all lines containing option flags
  collect_option_flag_lines() {
    local help_content="$1"
    local options_section options_all
    options_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_options_section")"
    command_option_flag_lines="$(echo "$options_section" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
    __print_lines "$command_option_flag_lines"
  }

  # =====================================
  # Actions

  # example1() {
  #   cat <<-EOF
  # 	    # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
  # 	name: mycmd
  # 	description: my command
  # 	flags:
  # 	  --optarg?: optarg flag
  # 	  -r, --repeatable*: repeatable flag
  # 	  -v=: flag with value
  # 	persistentflags:
  # 	  --help: bool flag
  # 	completion:
  # 	  flag:
  # 	    optarg: ["one", "two\twith description", "three\twith style\tblue"]
  # 	    v: ["$files"]
  # 	commands:
  # 	- name: sub
  # 	  description: subcommand
  # 	  completion:
  # 	    positional:
  # 	      - ["$list(,)", "1", "2", "3"]
  # 	      - ["$directories"]
  # EOF
  # }

  # NOTE: This one checks repos for first positional arg, and then remote
  # refs for the second pos arg
  #
  # example_github() {
  #   cat <<-EOF
  #   # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
  #   name: github
  #   completion:
  #   positional:
  #   - ["\$carapace.tools.gh.OwnerRepositories"] # \${C_ARG0}
  #   - ["\$carapace.tools.git.LsRemoteRefs({url: 'https://github.com/\${C_ARG0}', branches: true, tags: true})"]
  #   EOF
  # }

  create_carpace_spec_for_command() {
    local command_name=$1
    local help_content
    local final_spec
    local about_text
    local command_option_flag_lines
    local command_sub_actions

    set +e # prevent errexit
    help_content="$("$command_name" --help 2>&1)"
    set -e

    about_text="$(collect_about_section "$help_content")"

    command_option_flag_lines=$(collect_option_flag_lines "$help_content")

    # ------------------------------------------------------------------
    # Put together final spec file for $command_name
    final_spec="$(
      __print_lines \
        "# yaml-language-server: \$schema=https://carapace.sh/schemas/command.json" \
        "name: $command_name" \
        "description: ${about_text[*]}"
    )"

    # FLAGS -------------------------------------------------------
    # = flag takes an argument
    # * flag is repeatable
    # ? flag takes an optional argument
    # & flag is hidden
    # ! flag is required
    #
    # https://github.com/carapace-sh/carapace-spec/blob/master/example/traverse.yaml
    #
    # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: flag
    # flags:
    #   -e=: executables
    #   -f, --file=: file
    # completion:
    #   flag: ????????????
    #     e: ["$executables"]
    #     file: ["$files"]

    # TODO: [ ] check if has flags
    # TODO: [ ] fix spec flag formatting

    final_spec+=($'\n'"flags:")
    for item in "${command_option_flag_lines[@]}"; do
      final_spec+=($'\n'"  $item")
      # final_spec+=("\t$item")
    done

    # PERSISTENT FLAGS --------------------------------------------
    #

    # COMPLETION --------------------------------------------
    #
    # TODO: [ ] check if has/should add completions
    #
    # completion > flags

    # TODO: [ ] try add flag completions if has option flags

    # completion > Positional
    # I believe that sub actios should be added as positional actions.
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/positional.html
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positional
    # completion:
    #   positional: NOTE: these are completed in order, so pos1 before pos2
    #     - [pos1, positional1]
    #     - [pos2, positional2]
    #
    #     # yaml-language-server: $schema=https://carapace.sh/schemas/command.json
    # name: positionalany
    # completion: NOTE: here, the order is arbitrary.
    #   positionalany: [one, two, three]

    # TODO: [ ] positional args.
    # Before embarking on pos args, i have to first try the flags options and
    # see how this works.

    # TODO: [ ] positional any
    # same as above..

    # DASH
    # Positional arguments after `--`
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/command/completion/dash.html
    #
    # NOTE: dash | dash-any
    # completes in the same way as positional above but after the double dash
    # separator.

    # TODO: [ ] start have a look at macros
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/macros.html
    # Macros allow for hooking into more advanced lib funcs.

    # TODO: [ ] investigate variable replacement
    # https://carapace-sh.github.io/carapace-spec/carapace-spec/variables.html

    __print_lines "${final_spec[*]}"

    __print_lines "${final_spec[*]}" >"$DOROTHY/autocomplete/$command_name.yaml"

  }

  # =====================================
  # Arguments

  function help {
    cat <<-EOF >/dev/stderr
			USAGE:
			dorothy-autocomplete [...options] <file> -- ...

			  DESCRIPTION:
			  Auto generate carapace-spec shell completions for dorothy commands.
			  Either for a single command, a filter, or all commands a new.
		EOF
    if test "$#" -ne 0; then
      echo-error "$@"
    fi
    return 22 # EINVAL 22 Invalid argument
  }

  # process
  # local item option_args=() option_file='' option_multiple='ok' option_quiet
  # option_quiet="$(echo-quiet-enabled -- "$@")"
  local option_command_single='' option_all='no'
  while test "$#" -ne 0; do
    item="$1"
    shift
    case "$item" in
    '--help' | '-h') help ;;
    '--all') options_all='yes' ;;
    '--command='*) option_command_single="${item#*=}" ;;
    # '--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet-enabled
    # '--multiple=ok' | '--multiple=warn-skip' | '--multiple=warn-apply') option_multiple="${item#*=}" ;;
    # '--')
    #   option_args+=("$@")
    #   shift $#
    #   break
    #   ;;
    # '--'*) help "An unrecognised flag was provided: $item" ;;
    *)
      if test -z "$option_file"; then
        option_file="$item"
      else
        help "An unrecognised argument was provided: $item"
      fi
      #   ;;
      ;;
    esac
  done

  # TODO: if no command/all selected, then use fzf or chose to seect a command.

  # local fzf_heading__prefix='SELECTION (Current question: '
  # local fzf_heading__suffix=')'
  #
  # get_fzf_heading() {
  #   # local final header=
  #   #
  #   __print_string "$fzf_heading__prefix${1-????}$fzf_heading__suffix"
  # }
  #
  # local fzf_base_opts=(
  #   --height=40%
  #   --ellipsis=..
  # )
  #
  # local selection_prev=()
  #
  # if test -z "$action"; then
  #   if __use_fzf; then
  #     action="$(
  #       __print_lines "${fzf_actions[@]}" | fzf "${fzf_base_opts[@]}" \
  #         --header "$(get_fzf_heading "You have to select an ACTION")"
  #
  #       # NOTE: display next lines by adding $'\n'
  #
  #     )"
  #   else
  #     action="$(
  #     choose all dorothy commands
  #     )"
  #   fi
  #   selection_prev+=("action = $action")
  # fi

  # dorothy --help

  # TODO: Re-use my dorothy-new command to see how I did the
  # templating.

  # TODO: capture each chunk
  # ABOUT
  # USAGE
  # OPTIONS
  # ACTIONS

  local lines_starting_with_hyphen
  local help_content

  # Get help command content
  set +e
  help_content="$(dorothy --help 2>&1)"
  set -e

  # echo-style --h1 "dorothy gen autocomp"

  # echo-style --notice="lines starting with hyphen"
  # lines_starting_with_hyphen="$(echo "$help_content" | echo-regexp -gmn --find="$regex_lines_starting_with_hyphen")"
  # __print_lines "${lines_starting_with_hyphen[@]}"
  #

  # NOTE: ACTIONS
  # Loop over all sub action segments and then for each get the action name
  # and description etc.

  local regex_actions_section="ACTIONS:\s*([\s\S]*?)(?=\n[A-Z]+[\s:]*|\s*$)"

  local regex_sub_action="(^[a-zA-Z|<>\s]+(?:\s+\[.*\])?\n(?:\s+.*\n?)*)+"

  echo-style --notice="Actions section"
  # local actions_section="$(echo "$help_content" | echo-regexp -gmn --find="$regex_actions_section")"

  local actions_section="$(echo "$help_content" | sed -n '/^ACTIONS:/,/^[A-Z][A-Z\s]*:/{/^ACTIONS:/!p;}')"

  # __print_lines "${actions_section[@]}"

  # This variable is used to handle some special cases when subsequent lines
  # are starting at beginning of the line, so that we split each sub action
  # correctly.
  local prev_line_not_empty="prev_empty" # bash inverted boolean, eg. 0 = true

  # Loop over actions and separate by ----
  while IFS= read -r line; do
    if [[ "$line" =~ ^[^[:space:]] && -n "$line" && "$prev_line_not_empty" == "prev_empty" ]]; then
      echo "----------------------"
      # fi
    fi
    echo "$line" # ($prev_line_not_empty)"
    #
    if test -z "$line"; then
      prev_line_not_empty="prev_empty"
    else
      prev_line_not_empty="_"
    fi
  done <<<"$actions_section"

  # __print_lines "$actions_section"

  # echo-style --g1 "dorothy gen autocomp"

  if test -n "$option_command_single"; then
    :
    # the single command name is selected,
    #
    # TODO: try to find command in $dorothy/commands.

    create_carpace_spec_for_command "$option_command_single"
  elif test "$$options_all" = "yes"; then
    :
    # TODO: loop over all commands and render for each of them.
  else

    :
    # ask should we select a single command or do for all???
  fi

)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
  if test "$*" = '--test'; then
    config_helper_test
  else
    dorothy_autocomplete "$@"
  fi
fi
